---
title: "Comparative RNA-Seq Analysis"
author: "Thomas Nicholson"
date: "14/09/2020"
output: 
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    number_sections: true
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1) 
# suppressMessages(library(comparativeSRA))
library(tidyverse)
library(VennDiagram)
library(shiny)
library(ggplot2)
library(gplots)
library(viridis)
library(RColorBrewer)
library(stringi)
#library(plyr)
library(devtools)
#library(tidyr)
library(shinyjs)
library(shinyWidgets)
library(DT)
library(lubridate)
library(dplyr)
library(svglite)
library(genoPlotR)
library(drake)
library(ape)
library(Biostrings)
library(ggtree)
# library(treeio)
library(geiger)
library(ROSE)
library(reshape2)
library(igraph)
library("viridis") 
library(randomForest)
library(ROCR)
library(corrplot)
library(kableExtra)
library(reticulate)
library(rjson)
library(GenomicRanges)
library(comparativeSRA)
library(ggpubr)
filePath <- "~/phd/RNASeq/r_files/"
# use_python("/Users/thomasnicholson/anaconda3/bin/python")
# use_condaenv("comparativesrna")
source('~/bin/r_git/R/render_toc.R')
```
```{r functions, include=F}
plotKnownvsConserved <- function(dat, columns, not_zero = F){
  dat <- dat%>%mutate(conserved = F)
if(not_zero){
  for(i in 1:nrow(dat)){
    dat[i, ncol(dat)] <- ("1" %in% dat[i, columns])
    if(dat[i, ncol(dat)] == F){
    dat[i, ncol(dat)] <- ("0-1" %in% dat[i, columns])
    }

  }
}else{
  for(i in 1:nrow(dat)){
    dat[i, ncol(dat)] <- ("1" %in% dat[i, columns])
  }
}


  conservedSet <- dat%>%filter(conserved)
  knownSet <- dat%>%filter(new_feature == F)

  vennSet <- conservedSet%>%bind_rows(knownSet)%>%unique()



  area1 <- nrow(subset(vennSet, conserved == T))
  area2 <- nrow(subset(vennSet, new_feature == F))
  cross.area <- nrow(subset(vennSet, new_feature == F & conserved == T))

  grid.newpage()
  draw.pairwise.venn(area1 = area1, area2 = area2, cross.area = cross.area, fill = c("blue", "red"),
                     scaled = T,
                     #cat.default.pos= "text",
                     #cat.pos = c(-50, 50),
                     #category = c("Conserved and Expressed", "Known")
                     category = c("", "")
  )
}

assignConservationLevel <- function(ids_lookup, main_col = 7, genera_col, species_col, any_col = c(7:ncol(ids_lookup))){
  ids_lookup <- ids_lookup%>%mutate(type = "")
  for(i in 1:nrow(ids_lookup)){
    if("1" %in% ids_lookup[i, main_col]){
      ids_lookup[i, ncol(ids_lookup)] <- "Family_1"
    }else if("0-1" %in% ids_lookup[i, main_col]){
      ids_lookup[i, ncol(ids_lookup)] <- "Family_0-1"
    }else if("1" %in% ids_lookup[i, genera_col]){
      ids_lookup[i, ncol(ids_lookup)] <- "Genera_1"
    }else if("0-1" %in% ids_lookup[i, genera_col]){
      ids_lookup[i, ncol(ids_lookup)] <- "Genera_0-1"
    }else if("1" %in% ids_lookup[i, species_col]){
      ids_lookup[i, ncol(ids_lookup)] <- "Species_1"
    }else if("0-1" %in% ids_lookup[i, species_col]){
      ids_lookup[i, ncol(ids_lookup)] <- "Species_0-1"
    }else if("1" %in% ids_lookup[i, any_col]){
      ids_lookup[i, ncol(ids_lookup)] <- "Species_1"
    }else if("0-1" %in% ids_lookup[i, any_col]){
      ids_lookup[i, ncol(ids_lookup)] <- "Species_0-1"
    }

  }
  return(ids_lookup)
}
firstup <- function(x) {
  substr(x, 1, 1) <- toupper(substr(x, 1, 1))
  x
}

cumulativeCounts <- function(dists, smooth = T){

  groups <- unique(dists$group)
  for(i in groups){
    dat <- dists %>% filter(group == i)
    dat <- dat %>% mutate(count = 1) %>% 
    arrange(-max_dist) %>% group_by(group) %>% 
    mutate(cumulativeCount = cumsum(count)) %>% ungroup() %>% 
    group_by(group, max_dist) %>% summarise(cumulative_prop = max(cumulativeCount)/ nrow(dat))
    
    if(smooth){
      dat <- as.data.frame(spline(x = dat$max_dist,y =  dat$cumulative_prop))
    }
    dat <- dat %>% ungroup() %>% mutate(group = i)
    if(exists('combinedDat')){
      combinedDat <- combinedDat %>% bind_rows(dat)
    }else{
      combinedDat <- dat 
    }
  }
  return(combinedDat)  

}

```
```{python pysetup, eval=F, include=F}
import sys
from Bio import SeqIO
import Bio
import pandas as pd
import seaborn as sns
import os
import random
#from BCBio import GFF
from Bio.Seq import Seq
import matplotlib.pyplot as plt
import numpy as np
from pylab import savefig
from matplotlib.pyplot import figure
import json
run_all = False
```
```{python py_functions, eval=F, include=F}
def package_test():
	print("comparativesrna.py loaded")

def file_len(fname):
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
    return i


def intergenicSequence(accession, my_seq, shuffled):
    start = 0
    end = 0
    random_seq = Seq("AG", generic_dna)
    try:

        in_handle = open("/Users/thomasnicholson/phd/RNASeq/sequences/%s.gff" % accession)
        for rec in GFF.parse(in_handle):
            for feature in rec.features:
                qualifiers = feature.qualifiers
                try:
                    location = feature.location
                    end = location.start
                    intergeneicSeq = my_seq[start:end]
                    if shuffled == True:
                        shuffledSeq = ''.join(random.sample(str(intergeneicSeq), len(intergeneicSeq)))
                        random_seq = random_seq + shuffledSeq
                    else:
                        random_seq = random_seq + intergeneicSeq
                    start = location.end
                    #print(len(random_seq))
                except KeyError:
                    pass

        in_handle.close()

    except IOError:
        print("/Users/thomasnicholson/phd/RNASeq/sequences/%s.gff not found" % accession)
        sys.exit(2)
    return random_seq


def intergenicPositions(accession):
    start = 0
    end = 0
    positions = [0]
    try:

        in_handle = open("/Users/thomasnicholson/phd/RNASeq/sequences/%s.gff" % accession)
        for rec in GFF.parse(in_handle):
            i = 0
            for feature in rec.features:
                qualifiers = feature.qualifiers
                try:
                    qualifiers['gene_biotype']
                except KeyError:
                    continue
                try:
                    i += 1
                    location = feature.location
                    end = location.start - 49
                    if end < start:
                        continue
                    tmpPos = range(start,end)
                    positions = positions + tmpPos
                    start = location.end + 50
                except KeyError:
                    pass

        in_handle.close()

    except IOError:
        print("/Users/thomasnicholson/phd/RNASeq/sequences/%s.gff not found" % accession)
        sys.exit(2)
    return positions


def makeoutputdirectory(write_path):
    if os.path.isdir(write_path) == False:
        try:
            os.mkdir(write_path)
        except OSError:
            print("Creation of the directory %s failed" % write_path)
            sys.exit(2)
    directory = os.listdir(write_path)
    if len(directory) != 0:
        print("Examples of files in %s" % write_path)
        print(directory[0:4])
        query_user = input("%s is not an empty directory. Continue anyway y/n (this may write over existing files): " % write_path)
        if query_user == "y":
            print("Using %s as directory" % write_path)
        else:
            print("Exiting script")
            sys.exit(2)


def concatenateSequence(fastaFile):
    my_seq = fastaFile[0].seq
    i = 0
    for seq in fastaFile:
        if i == 0:
            i += 1
            continue
        i += 1
        my_seq = my_seq + seq.seq
    return my_seq


def selectRandomLocation(inFile, positions,fileLength, random_seq, accession):

    randomFile = open("/Users/thomasnicholson/phd/RNASeq/new_calls/random/python_version_1/%s_random_no_shuffle_new_calls.txt" % accession, "w")
    randomFile.write("start\tend\tstrand\tsequence\n")

    shuffledIndexes = random.sample(positions, fileLength)
    seqLength = len(random_seq)
    seqIndexes = random.sample(range(0,seqLength), fileLength)

    srnaLengths = []
    srnaStrands = []
    srnaIDs = []
    i = 0
    for line in inFile:
        i += 1
        words = line.rstrip()
        words = words.split("\t")
        start = words[2]
        try:
            start = int(start)
        except ValueError:
            continue
        end = words[3]
        end = int(end)
        srna = words[-1]
        srna_length = end - start
        srnaLengths.append(srna_length)
        strand = words[4]
        srnaStrands.append(strand)
        srnaIDs.append(srna)
    for i in range(0,len(shuffledIndexes)):
        index = shuffledIndexes[i]
        length = srnaLengths[i]
        strand = srnaStrands[i]
        seqIndex = seqIndexes[i]
        srna = srnaIDs[i]
        if strand == "+":
            start = index
            end = start + length
            seqStart = seqIndex
            seqEnd  = seqStart + length
        else:
            end = index
            start = end - length
            seqEnd = seqIndex
            seqStart  = seqEnd - length
        if start < 1:
            continue
        if end < 1:
            continue
        if length < 50:
            continue
        if length > 500:
            continue
        if seqStart < 1:
            continue
        if seqEnd < 1:
            continue
        if seqEnd > seqLength:
            continue
        if seqStart > seqLength:
            continue
        sequence  = random_seq[seqStart:seqEnd]
        randomFile = open("/Users/thomasnicholson/phd/RNASeq/new_calls/random/python_version_1/%s_random_no_shuffle_new_calls.txt" % accession, "a")
        randomFile.write("%s\t%s\t%s\t%s\n" % (start, end, strand, sequence))

        srna_type = "random"

        write_path = "/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/negative_control_no_shuffle"
        srnaFile = open("%s/%s.fna" % (write_path, accession), "a")
        srnaFile.write(">%s[%s-%s,%s,%s]\n%s\n" % (srna, seqStart, seqEnd, strand, srna_type, sequence))


def getreaddepths(accession):
    try:
        df = None
        for filename in os.listdir("/Users/thomasnicholson/phd/RNASeq/plot_files/%s/" % accession):
            filesize = os.path.getsize(
                "/Users/thomasnicholson/phd/RNASeq/plot_files/%s/%s" % (accession, filename))
            if filesize == 0:
                print("No data in %s" % filename)
                continue
            plotFile = pd.read_csv(
                os.path.join("/Users/thomasnicholson/phd/RNASeq/plot_files/%s/" % accession, filename),
                sep='\t', header=None)
            print(filename)
            plotFile['selected'] = plotFile.iloc[:].max(axis=1)
            tmpDf = plotFile.iloc[:, 2]
            if df is not None:
                df = pd.concat([df.reset_index(drop=True), tmpDf], axis=1)
            else:
                df = tmpDf
        dfOut = df
        dfOut['mean'] = df.iloc[:].mean(axis=1)
        dfOut['median'] = df.median(axis=1)
        dfOut['max'] = df.max(axis=1)
        return dfOut

    except IOError:
        print("Cannot open a file in /Users/thomasnicholson/phd/RNASeq/plot_files/%s/" % accession)


def sRNA_read_depths(inFile, read_depths_df,accession, random):
    if random == False:
        outFile  = open("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/read_depths/%s_read_depths.txt" % accession, 'w')
        outFile.write("ID\tstart\tend\tgroup\tfeature\tmean_mean\tmean_median\tmean_max\tmedian_mean\tmedian_median\tmedian_max\tmax_mean\tmax_median\tmax_max\n")
        outFile.close()
        outFile  = open("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/read_depths/%s_read_depths.txt" % accession, 'a')
    else:
        outFile  = open("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/read_depths_negative_control/%s_read_depths.txt" % accession, 'w')
        outFile.write("ID\tstart\tend\tgroup\tfeature\tmean_mean\tmean_median\tmean_max\tmedian_mean\tmedian_median\tmedian_max\tmax_mean\tmax_median\tmax_max\n")
        outFile.close()
        outFile  = open("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/read_depths_negative_control/%s_read_depths.txt" % accession, 'a')

    if random == False:
        for line in inFile:
            words = line.rstrip()
            words = words.split("\t")
            srna = words[-1]
            start = words[2]
            try:
                start = int(start)
            except ValueError:
                continue
            end = words[3]
            end = int(end)
            new_feature = words[8]
            feature = words[1]
            if new_feature == "FALSE":
                srna_type = "known"
            else:
                srna_type = "novel"

            subsetDF = read_depths_df[start:end]

            mean_mean = subsetDF['mean'].mean()
            mean_median = subsetDF['mean'].median()
            mean_max = subsetDF['mean'].max()
            median_mean = subsetDF['median'].mean()
            median_median = subsetDF['median'].median()
            median_max = subsetDF['median'].mean()
            max_mean = subsetDF['max'].mean()
            max_median = subsetDF['max'].median()
            max_max = subsetDF['max'].max()

            outFile.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % (srna, start, end, srna_type, feature, mean_mean, mean_median, mean_max, median_mean, median_median, median_max, max_mean, max_median, max_max))
    else:
        i = 0
        for line in inFile:
            i += 1
            words = line.rstrip()
            words = words.split("\t")
            srna = "%s_%s" % (accession, i)
            start = words[0]
            try:
                start = int(start)
            except ValueError:
                continue
            end = words[1]
            end = int(end)
            feature = "intergenic"
            srna_type = "negative_control"

            subsetDF = read_depths_df[start:end]

            mean_mean = subsetDF['mean'].mean()
            mean_median = subsetDF['mean'].median()
            mean_max = subsetDF['mean'].max()
            median_mean = subsetDF['median'].mean()
            median_median = subsetDF['median'].median()
            median_max = subsetDF['median'].mean()
            max_mean = subsetDF['max'].mean()
            max_median = subsetDF['max'].median()
            max_max = subsetDF['max'].max()

            outFile.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % (
            srna, start, end, srna_type, feature, mean_mean, mean_median, mean_max, median_mean, median_median,
            median_max, max_mean, max_median, max_max))


def single_fasta(fastaFile, folder):
    for seq in fastaFile:
        id = seq.id
        outname = id.split("[")
        outname = outname[0]
        my_seq = seq.seq
        outFile = open("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/%s/%s.fna" % (folder, outname), "w")
        outFile.write(">%s\n%s\n" % (id, my_seq))


def openNHMMER(nhmmername):
    nhmmerDF = pd.read_csv(nhmmername, delim_whitespace=True, header=None, comment='#')
    nhmmerDF.columns = ["target_name", "accession", "query_name", "accession_2", "hmmfrom", "hmmto", "alifrom", "alito", "envfrom", "envto", "sq_len", "strand", "E_value", "score", "bias", "description_of_target"]
    nhmmerDF[["ID", "descriptors"]] = nhmmerDF.target_name.str.split("[", expand = True)
    nhmmerDF[["ID_2", "descriptors_2"]] = nhmmerDF.query_name.str.split("[", expand = True)
    d = nhmmerDF.groupby('ID')['ID_2'].apply(list).to_dict()
    return(d)


def openReadDepths(readdepthsname, d):
    readdepthsDF = pd.read_csv(readdepthsname, sep = "\t", comment='#')
    readdepthsDF = readdepthsDF[readdepthsDF['ID'] != "ID"]

    ##when being done in jupyter the columns were all read in as string and the lines below were necessary...
    ##it seems to work fine now

    # print(readdepthsDF.dtypes)
    # readdepthsDF[["mean_value", "mean_decimal"]] = readdepthsDF.max_mean.str.split(".", expand = True)
    # print(1)
    # readdepthsDF[["median_value", "median_decimal"]] = readdepthsDF.max_median.str.split(".", expand = True)
    # readdepthsDF[["max_value", "max_decimal"]] = readdepthsDF.max_max.str.split(".", expand = True)
    # readdepthsDF[['mean_value', 'median_value', 'max_value']] = readdepthsDF.loc[:,['mean_value', 'median_value', 'max_value']].apply(pd.to_numeric)


    readdepthsDF["mean_value"] = readdepthsDF['max_mean']
    readdepthsDF["median_value"] = readdepthsDF['max_median']
    readdepthsDF["max_value"] = readdepthsDF['max_max']
    readdepthsDF[['mean_value', 'median_value', 'max_value']] = readdepthsDF.loc[:,['mean_value', 'median_value', 'max_value']].apply(pd.to_numeric)


    idList = list(d.keys())
    readdepthsKept = readdepthsDF[readdepthsDF['ID'].isin(idList)]
    return(readdepthsKept)


def writeReadDepths(outname, readDepths, d):
    seen = []
    d2 = {}
    i = 0

    outFile = open(outname, "w")
    outFile.write(
        "ID\tmean_mean\tmean_median\tmean_max\tmedian_mean\tmedian_median\tmedian_max\tmax_mean\tmax_median\tmax_max\tID_2\n")
    outFile.close()
    outFile = open(outname, "a")
    values = []
    for key in d:
        #     print(i)
        #     i += 1
        #     if i > 100:
        #         break
        #     if key in seen:
        #         continue
        #     print(key)
        #     print(seen)
        values = d[key]
        seen.append(values)
        df = readDepths[readDepths['ID'].isin(values)]
        #     print(df['mean_value'].dtypes)

        #     print(df['mean_value'].dtypes)
        mean_mean = df['mean_value'].mean()
        mean_median = df['mean_value'].median()
        mean_max = df['mean_value'].max()
        median_mean = df['median_value'].mean()
        median_median = df['median_value'].median()
        median_max = df['median_value'].max()
        max_mean = df['max_value'].mean()
        max_median = df['max_value'].median()
        max_max = df['max_value'].max()
        #     print(key)
        #     print("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % (key,mean_mean,mean_median,mean_max,median_mean,median_median,median_max,max_mean,max_median,max_max,values))
        outFile.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % (
        key, mean_mean, mean_median, mean_max, median_mean, median_median, median_max, max_mean, max_median, max_max,
        values))
    outFile.close()


def writeSequences(inFile,my_seq,accession,write_path):
    i = 0
    for line in inFile:
        i += 1
        words = line.rstrip()
        words = words.split("\t")
        srna = words[-1]
        start = words[2]
        try:
            start = int(start)
        except ValueError:
            continue
        end = words[3]
        end = int(end)
        if end - start > 50:
            strand = words[4]
            new_feature = words[8]
            feature = words[1]
            overlap = words[7]
            if new_feature == "FALSE":
                srna_type = "known"
            else:
                srna_type = "novel"
            srnaSeq = my_seq[start:end]
            srnaSeqRev = srnaSeq.reverse_complement()
            if strand == "-":
                srnaSeq = srnaSeqRev
            if srna_type == "known":
                srnaPCFile = open("%s/positive_control/%s.fna" % (write_path, accession), "a")
                srnaPCFile.write(">%s[%s-%s,%s,%s,%s,%s]\n%s\n" % (srna, start, end, strand, srna_type, feature, overlap, srnaSeq))
            else:
                srnaPredictedFile = open("%s/predicted/%s.fna" % (write_path, accession), "a")
                srnaPredictedFile.write(">%s[%s-%s,%s,%s,%s,%s]\n%s\n" % (srna, start, end, strand, srna_type, feature, overlap, srnaSeq))
                
def get_overlap_vals(subsetDat, overlaps):
    dat_len = len(subsetDat.index)
    overlapping_ids = []
    lengths = []
    start_val = 0
    end_val = 0
    for i in range(0,dat_len):
        query_val = subsetDat.iloc[i]['query_id']    
        new_start_val = min([subsetDat.iloc[i]['target_start'], subsetDat.iloc[i]['target_end']])
        new_end_val = max([subsetDat.iloc[i]['target_start'], subsetDat.iloc[i]['target_end']]) 
        if end_val > new_start_val:
            overlapping_ids.append(query_val)
            len_1 = end_val - start_val
            len_2 = new_end_val - new_start_val
            shortest_seq = min([len_1, len_2])
            overlap_start = max([start_val, new_start_val])
            overlap_end = min([end_val, new_end_val])
            overlap = (overlap_end - overlap_start)/shortest_seq
            overlaps.append(overlap)
        else:
            end_val = new_end_val
            start_val = new_start_val
            overlapping_ids = [query_val]
    return(overlaps)

def get_overlap_list(subsetDat):
    overlapping_ids = []
    overlap_list = []
    lengths = []
    start_val = 0
    end_val = 0
    shortest_seq = max(subsetDat['target_end'])
    dat_len = len(subsetDat.index)
    for i in range(0,dat_len):
        query_val = subsetDat.iloc[i]['query_id']    
        new_start_val = min([subsetDat.iloc[i]['target_start'], subsetDat.iloc[i]['target_end']])
        new_end_val = max([subsetDat.iloc[i]['target_start'], subsetDat.iloc[i]['target_end']])  
        if end_val > new_start_val:
            len_2 = new_end_val - new_start_val
            shortest_seq = min([shortest_seq, len_2])
            overlap_start = max([start_val, new_start_val])
            overlap_end = min([end_val, new_end_val])
            overlap = (overlap_end - overlap_start)/shortest_seq
            
            if overlap >= 0.5 and overlap_end - overlap_start >= 50:
                if query_val not in overlapping_ids:
                    overlapping_ids.append(query_val)
                end_val = max([end_val, new_end_val])
            else:
                overlap_list.append(overlapping_ids)
                shortest_seq = max(subsetDat['target_end'])
                end_val = new_end_val
                start_val = new_start_val
                overlapping_ids = [query_val]
        else:
            overlap_list.append(overlapping_ids)
            end_val = new_end_val
            start_val = new_start_val
            overlapping_ids = [query_val]
        if i == dat_len - 1:
            overlap_list.append(overlapping_ids)
    return(overlap_list)

def get_overlap_count(overlap_list, d):
    for l in overlap_list:
        list_len = len(l)
        if list_len == 0:
            continue
        for i in range(0,list_len - 1):
            for j in range(i+1, list_len):
                ids =[l[i], l[j]]
                ids.sort()
                current_id = "_".join(ids)
                if current_id in d:
                    d[current_id] += 1
                else:
                    d[current_id] = 1
    return(d)

def unique_set_of_overlaps(all_overlaps, ids_checked, id1, id2):
    make_new = True
    counter = 0
    if id1 in ids_checked:
        if id1 in all_overlaps:
            if id2 not in all_overlaps[id1]:
                all_overlaps[id1].append(id2)    
        else:
            counter = 0
            item_list = []
            for item in all_overlaps:
                if id1 in all_overlaps[item]:
                    item_list.append(item)
                    if id2 not in all_overlaps[item]:
                        all_overlaps[item].append(id2)
                    make_new = False
                    counter += 1
            if counter > 1:
                print(item_list[1:])
                for item in item_list[1:]:
                    for value in all_overlaps[item]:
                        if value not in all_overlaps[item_list[0]]:
                            all_overlaps[item_list[0]].append(value)
                    all_overlaps.pop(item, None)
                     
    else:
        ids_checked.append(id1)
    return(all_overlaps, ids_checked, make_new, counter)                
                
def combined_alignments(query, combined_d, ids_checked, query_matches):
    combined_ids = [query]
    ids_checked.append(query)
    max_query = query
    for i in range(0, len(query_ids)):
        ids =[query, query_ids[i]]
        ids.sort()
        current_id = "_".join(ids)
        if current_id in query_matches:
            if query_ids[i] in ids_checked:
                for key, value in combined_d.items():
                    if query_ids[i] in value:
                        max_query = key
            else:
                combined_ids.append(query_ids[i])
                ids_checked.append(query_ids[i])
                
                
    if max_query in combined_d:
        for item in combined_ids:
            if item not in combined_d[max_query]:
                combined_d[max_query].append(item)
    else:
        combined_d[max_query] = combined_ids
    return(combined_d, ids_checked)



```
```{r toc, echo=FALSE, include=F} 
render_toc("~/bin/r_git/R/shiny_html/analysis_markdown_pdf.Rmd")
```


#Overview {#overview}

***

##Abstract

Small non-coding RNAs are involved in regulation of a wide range of cell processes. There are a number of tools that exist that try to identify these RNAs using a range of methods, however challenges with predicting non-coding RNAs from the sequence alone and transcriptional noise making the use of RNASeq data unreliable has hindered annotation of functional elements. While these methods manage to predict RNAs it can be hard to determine whether results from RNASeq data are the result of a real RNA or noise and to deal with this problem we are using a comparative approach by taking RNASeq data from multiple genomes within a clade. We have designed a pipeline that identifies peaks in intergenic regions of RNASeq data that may by functional RNAs and uses genome alignments to check if there are conserved regions of expression that would indicate the transcription that is observed is for functional RNAs. By using a comparative approach we aim to improve the signal to noise ratio in our results and better list of candidate small non-coding RNAs.


##Intro {#srna_overview} 

Prokaryotes are the most numerous organisms on Earth, making a vast impact on every aspect of biology. A key component of the function of prokaryotes is how small non-coding RNAs (sRNA) contribute to cell functions (Gorski et al. 2017; Wagner and Romby 2015). RNAs play a critical role in a wide range of biological functions such as:

-   Transcription/Translation

    -   rRNA, tRNA, 6sRNA etc.

-   Immune response

    -   CRISPR-cas

-   Gene regulation

    -   Riboswitches, sRNAs binding to mRNA etc.

-   Virulence

![Figure 1. Examples of ncRNAs in bacteria](sRNA_examples.png)

Identifying sRNAs has been a significant challenge (Freyhult et al. 2006). While a number of different approaches are available each have limitations. Annotations based on sequence can be done based on known RNA families (Kalvari et al. 2018) are possible but cannot find novel sRNAs and are more likely to find the most highly conserved sRNAs. As many sRNAs are not widely conserved (Lindgreen et al. 2014) this means use of comparative transcriptomics will be more limited for non-coding RNA analysis, and experiments more carefully designed to ensure that the evolutionary distance between analyzed genomes is considered, to make the analysis of the data meaningful.  Experimental approaches such as transposon insertion sequencing (Barquist et al. 2013) can find novel sRNAs, these experiments are time consuming and expensive. High-throughput RNA sequencing allowed for another way to look for sRNAs throughout genomes, using RNA-Seq experiments to look for signals of expression. This allows novel features to be identified, and conservation is not going to contribute. The challenge with using data from RNA-Seq experiments has been in identifying putative sRNAs from the expression data. Transcriptional noise, the expression of non-functional transcripts (Jose et al. 2019), has been shown to occur (Struhl 2007; Lybecker et al. 2014; Wade and Grainger 2014) with spurious promoters likely to be resulting in a lot of transcripts that have no function (Costa 2007; Hüttenhofer et al. 2005), with Lloréns-Rico et al. (2016) showing that AT% of genomes correlates with the number of sRNAs found, suggesting that this is the result of suprious promoters. Many tools that aim to predict putative sRNAs (Leonard et al. 2019; Yu et al. 2018; Mcclure et al. 2013) struggle to agree on predictions from the same dataset with the number of predicted transcripts and the exact start and end of the transcripts differing greatly. Experimental conditions are also very important with sRNAs often responding to environmental cues (Gottesman et al. 2006). These tools are likely struggling as the non-functional transcripts are not easily distinguished from functional sRNAs using expression data alone. A more comprehensive approach that carries out downstream analysis is necessary to better separate the transcriptional noise from the putative sRNAs. 

##Results {#res}

```{r results_setup_values, include=F}

pc_models <- list.files("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/alignments/", pattern = ".stk")

pc_models_nr <- list.files("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/alignments_rnaalifold/", pattern = ".stk")


genera_list <- list.files("~/phd/RNASeq/genera/")
genera_list <- genera_list[genera_list != "test"]
genera_count <- length(genera_list)
strain_count <- 0
experiment_count <- 0
for(genus in genera_list){
  strain_list <- list.files(paste("~/phd/RNASeq/genera/", genus, sep = ""), pattern = ".data")
  n.strains <- length(strain_list)
  if(n.strains == 0){
    next
  }
  for(strain in strain_list){
    experiment_list <- list.files(paste("~/phd/RNASeq/genera", genus, strain, "plot_files/", sep = "/"), pattern = "ncRNA.plot")
    n.experiments <- length(experiment_list)
    if(n.experiments == 0){
      next
    }
    experiment_count <- experiment_count + n.experiments
    strain_count <- strain_count + 1
  }
}

known_files <- list.files("~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/positive_control/single_seqs/done", pattern = ".fna")
known_count <- length(known_files)

novel_files <- list.files("~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/predicted/single_seqs/", pattern = ".fna")
novel_count <- length(novel_files)

novel_alignments <- list.files("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments_rnaalifold/", pattern = ".stk")
novel_alignments <- length(novel_alignments)

nc_alignments <- list.files("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/alignments_rnaalifold/", pattern = ".stk")
nc_alignments <- length(nc_alignments)

```


A clade of Gammaproteobacteria was selected. These included a number of well studied species, with a number of RNA-seq experiments to analyse and less well studied species that had fewer RNA-seq experiments and less known about the sRNAs. 

![Figure 2. Taxonomy of the genera in the selected clade and the number of strains for each genus](/Users/thomasnicholson/phd/RNASeq/figures/subset_tree.png)

A representative set of bacterial genomes were also selected. We took 2 genomes from each genus available in the Refseq95 dataset. Annotations of ncRNAs were made using the rFam models. 

There were `r prettyNum(length(pc_models))` Rfam models that were found in these genomes, with `r prettyNum(length(pc_models_nr))` models analysed after combining models that overlapped (e.g. eukaryotic SSU and bacterial SSU), 4 were found across all genomes in the gammaproteobacteria clade. There were also a number of models found in large numbers of genomes, however there were far more showing up in well studied species. 

```{r, echo=F}
load("~/bin/r_git/R/r_files/upsetSubsetPC.Rda")

UpSetR::upset(upsetSubsetPC, sets = colnames(upsetSubsetPC), mb.ratio = c(0.55, 0.45), order.by = "freq", nintersects = 15, keep.order = T)

```


Analysis of `r prettyNum(experiment_count)` RNA-seq data sets across `r prettyNum(strain_count)` genomes (from `r prettyNum(genera_count)` genera) resulted in `r prettyNum((known_count + novel_count), big.mark = ",")` unique regions of expression being identified in intergenic regions of these genomes. These were separated into previously annotated sRNAs, of which there were `r prettyNum(known_count, big.mark = ",")` and `r prettyNum(novel_count, big.mark = ",")` novel expressed regions. These were clustered into `r prettyNum(novel_alignments, big.mark = ",")` putative sRNA models that do not match known sRNAs. The same approach using random intergenic regions resulted in `r prettyNum(nc_alignments, big.mark = ",")` models that do not match known sRNAs or predicted sRNAs.



Similar patterns were observed in the clustering of the putative sRNAs, with the Enterobacteriaceae having large clusters and other closely related species and genera sharing a few putative sRNAs. Overall there are more sRNAs being predicted here than previously found meaning it is important to differentiate the sRNAs from transcriptional noise.

```{r, echo=F}
load('~/bin/r_git/R/r_files/upsetSubsetPredicted.Rda')


UpSetR::upset(upsetSubsetPredicted, sets = colnames(upsetSubsetPredicted), mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)
```

The distribution of the number of sequences per alignment is similar across each of the groups, with the majority of the models containing a single sequence and exponentially fewer alignemtns as the number of sequences increases.

```{r, echo=F}
seqs_per_alignment_pred <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/seqs_per_alignment.txt")
seqs_per_alignment_pc <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/seqs_per_alignment.txt")
seqs_per_alignment_nc <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/seqs_per_alignment.txt")

seqs_per_alignment_pred <- seqs_per_alignment_pred %>% mutate(group = "Predicted")

seqs_per_alignment_pc <- seqs_per_alignment_pc %>% mutate(group = "Positive Control")

seqs_per_alignment_nc <- seqs_per_alignment_nc %>% mutate(group = "Negative Control")

seqs_per_alignment <- seqs_per_alignment_pred %>% bind_rows(seqs_per_alignment_pc, seqs_per_alignment_nc)

ggplot() + 
  geom_freqpoly(data = seqs_per_alignment, aes(x = V1, y = ..density.., group = group, color = group), binwidth = 2) +
  xlim(min = 0, max = 40)


```

With a large number of known sRNAs and putative sRNA showing conservation over a large distance the first measure considered for evaluating the quality of an sRNA was evolutionary conservation. The maximum evolutionary distance between genomes contributing to the same model drops off quickly for each of the data sets showing that most sRNAs are not highly conserved and other approaches will be needed, however for the sRNAs that are highly conserved it is a good measure to use for analysing putative sRNAs. 

```{r, echo=F}
load("~/bin/r_git/R/r_files/dists_cum_count.Rda")

ggplot() +
  geom_line(data = dists_cum_count, aes(x= max_dist, y = cumulative_prop, group = group, colour = group))

```


Use of evolutionary conservation to determine whether any given non-conding sequence is an sRNA is a good approach for highly conserved sRNAs with an AUC of 0.849 (Figure 2), however does not provide any way of analysing novel sRNAs that may have evolved more recently. Another way of evaluating conservation is to look at covariation in the models. A number of different approaches to scoring the observed covariation were used, with each performing similarly (AUC=0.680), however this scoring approach appears more complex with highly conserved sRNAs able to be differentiated from random sequences very well, while less conserved sRNAs cannot be differentiated at all, which can be seen on the ROC curve (Figure 2).

In order to determine whether an expressed region is an sRNAs or spurious expression when there is no significant conservation other measures can also be used. The expression levels and the conservation of that expression when the sRNA is found in more than one genome is another reasonable approach. Like the evolutionary conservation measure, expression levels are able to be used to distinguish sRNAs from random sequence well (AUC = 0.854, Figure 2.), however there is the same problem that occurred with evolutionary conservation, where the sRNAs that are highly conserved are more likely to be highly expressed in a wide range of conditions, thus not accounting for newer sRNAs that have condition specific expression. 

Taking into account the secondary structure of sRNAs and looking at the conservation of the secondary structure, along with the minimum free energy (MFE) of a given structure is another measure that can be used in determining whether a given sequence might be an sRNA. For this, three measures were used. The absolute value of the MFE  (AUC=0.617) which on it’s own provides little towards predicting sRNAs, the z-score of the MFE, obtained by shuffling the given sequence multiple times and calculating MFE for each shuffle and the presence of common RNA motifs within the structure. The MFE z-score performs well (AUC=0.792) compared to the MFE value alone, and scoring motifs found in a sequence also gave better predictive value (AUC=0.669) than absolute MFE.


Another consideration when looking at non-coding RNAs and the promoter regions is the GC content, as some groups (Lloréns-Rico et al. 2016) have suggested that most of the expression is noise. Using GC content to predict sRNAs performed worst (AUC=0.543) out of all the measures and appear very similar to random.

![Figure 2. ROC](/Users/thomasnicholson/phd/RNASeq/figures/roc_curve_all_ccombinations.png)

Attempting to use any of these predictive measures to analyse the set of putative sRNAs from expressed regions resulted in a lot of models that were no different to random sequences still showing up, and did not help with determining the level of transcriptional noise that could be expected.  It is necessary to combine these metrics together in order to better predict sRNAs.

When looking at which measure correlates together (Figure 3.) there are two clusters with minimal overlap. As expected evolutionary distance and covariation correlate, while the secondary structure measures all correlate, along with the expression level measures. GC content shows a slight correlation with MFE, an effect that disappears when the z-score is used.

```{r, echo=F}
load("~/bin/r_git/R/r_files/rhoMatrix.Rda")
load("~/bin/r_git/R/r_files/sigMatrix.Rda")


heatmap.2(rhoMatrix, cellnote=sigMatrix,notecex=1.5,notecol="black", col=rev(redblue(40)), density.info="none", trace="none", dendrogram=c("column"), symm=F,symkey=T,symbreaks=T, scale="none", key.title = "", srtRow=45, adjRow=c(0, 1), srtCol=45, adjCol=c(1,1), breaks=(-20:20)/20,
margins = c(8, 8), cexRow=1.5, cexCol=1.5,font=2)

```

When all of the metrics were analysed together using a random forest the separation of these two clusters was observed again (Figure 4.) Expression levels and MFE were the most significant measures in predicting sRNAs, with evolutionary conservation also contributing. All of the metrics performed significantly better than random, including the GC content. 

```{r, echo=F}
load("~/bin/r_git/R/r_files/rf_classifier.Rda")
varImpPlot(rf_classifier)
```

A summary of the best performing metrics can be seen in Table 1 where the sensitivity of each of the individual measures is poor, while the random forest managed to capture 87% of the known sRNAs. When the positive predictive value is considered it can be seen that due to the high number of expressed regions, although these metrics showed strong predictive value in the ROC curves, the overall predictive value is very low. Only the random forest prediction is able to keep the sensitivity high while not including large numbers of models built from random sequence.  

Using the random forest predictions we can establish a likely upper and lower bound for transcriptional noise. When maximising the sensitivity of the random forest predictions the precision goes down to 62.7% with 2.5% of the random sequences being labelled as sRNAs. With this threshold 14.7% of the predicted sRNAs are no different to random intergenic sequences as a lower estimate of noise.  When balancing precision and sensitivity, 53.7% of the predicted sRNAs are labeled as random sequences. Taking into account the 12.8% of known sRNAs that are also labeled as random sequences, an upper bound would be ~40% of non-coding RNA expression is noise. 

```{r, echo=F}
load("~/bin/r_git/R/r_files/randomForestDistribution.Rda")

ggplot() +
  geom_path(data = randomForestDistribution, aes(x = x, y = y, group = group, color = group))
```

Further analysis of the expressed regions predicted as sRNAs shows that many of them are likely the result of expression of a codon that made it through filtering steps and while this is not transcriptional noise, it shows that it can be difficult to differentiate expression of a protein coding region from an sRNA if there is any overlap of expression.


##Overview of Methods {#methods}

```{r data_counts, include=F}
genera_list <- list.files("~/phd/RNASeq/genera/")
genera_list <- genera_list[genera_list != "test"]
genera_count <- length(genera_list)
strain_count <- 0
experiment_count <- 0
for(genus in genera_list){
  strain_list <- list.files(paste("~/phd/RNASeq/genera/", genus, sep = ""), pattern = ".data")
  n.strains <- length(strain_list)
  if(n.strains == 0){
    next
  }
  for(strain in strain_list){
    experiment_list <- list.files(paste("~/phd/RNASeq/genera", genus, strain, "plot_files/", sep = "/"), pattern = "ncRNA.plot")
    n.experiments <- length(experiment_list)
    if(n.experiments == 0){
      next
    }
    experiment_count <- experiment_count + n.experiments
    strain_count <- strain_count + 1
  }
}

```

Here, we have looked at a number of different tools and tried two different approaches to attempt to better categorise the expressed regions into putative sRNAs, sRNAs matching known families and transcriptional noise. 

This was done by taking RNA-Seq data from a clade of Gammaproteobacteria was selected: 

-   \>6 families
-   `r genera_count` genera
-   `r strain_count` strain
-   `r experiment_count` experiments

These included a number of well studied species, with a number of RNA-seq experiments to analyse and less well studied species that had fewer RNA-seq experiments and less known about the sRNAs. 


From these experiments, sRNAs were predicted based on expressed regions in RNA-Seq data using multiple RNA-Seq datasets for each genome.

These predicted regions can be used to evaluate signal to noise in expression data by classifying the RUFs into two categories:

- Similar to known sRNAs
- Indistinguishable from randomly selected regions

Categorising the RUFs requires using metrics that can idenitfy sRNAs. A number of different measures were chosen:

-   Conservation of transcription
-   Conservation of sequence
-   GC content
-   Covariation observed in sequence alignments
-   Secondary structure
-   Presence of ncRNA motifs


These metrics were evaluated using two datasets:

-   Annotations from a search of Rfam models

-   Random intergenic sequences of the same lengths as the predicted sRNAs


A representative set of bacterial genomes were selected by taking two genomes from each genus available in the Refseq95 dataset. These genoem were used for the conservation of sequence step and the annotations using rFam models.

![Figure 4. Workflow of methods]()


##Summary of strains used {#strains_used}

```{r summary_of_strains, echo = F, eval = T, results='asis'}
load("~/bin/r_git/R/r_files/accession_info.Rda")
accession_info <- accession_info %>% 
  mutate(strain_short = substr(Strain, start = 1, stop = 30)) %>% 
  select(Accession, RNASeq.file.counts, strain_short)

set.seed(101)
rand.selection <- runif(10, min = 1, max = nrow(accession_info))

accession_info[rand.selection,] %>%  
  kable(caption = "Table 1. Number of experiments per strain") %>%
  kable_styling()

load("~/bin/r_git/R/r_files/assembly_summary.Rda") # made from ~/phd/RNASeq/SRA_bacteria_RNAseq.txt


assembly_summary <- assembly_summary %>% separate(col = SPECIES, into = c("Genus"), extra = "drop", remove = F, sep = " ")


genomes <- assembly_summary %>% filter(DESIGN == "PAIRED", grepl(pattern = "Illumina", x = INSTRUMENT)) %>% group_by(Genus) %>% select(Genus, GENOME_ACCESSION) %>% unique() %>% summarise(genome_count = n())
experiments <- assembly_summary %>% filter(DESIGN == "PAIRED", grepl(pattern = "Illumina", x = INSTRUMENT)) %>% group_by(Genus) %>% select(Genus, GENOME_ACCESSION, ACCESSION) %>% unique() %>% summarise(experiment_count = n())

counts <- genomes %>% full_join(experiments, by = "Genus")

load("~/bin/r_git/R/r_files/sraDatAll.Rda")

rand.selection <- runif(5, min = 1, max = nrow(assembly_summary))

assembly_summary[rand.selection,] %>%  
  kable(caption = "Table 2. List of experiments (1)") %>%
  kable_styling()

rand.selection <- runif(5, min = 1, max = nrow(sraDatAll))

sraDatAll[rand.selection,]%>%  
  kable(caption = "Table 3. List of experiments (2)") %>%
  kable_styling()

```

#Data Selection {#data_selection}

##Strains and experiments
How to get the summary table for the genera for the RNA-seq data:

-   Search the [SRA](https://www.ncbi.nlm.nih.gov/sra/) section of ncbi with the genus name and ['Organism'] tag.

-   Select "Send results to Run selector"

-   Select the "Metadata" button of the "Total" row and "Download" Column.

-   `cat SraRunTable* >> ~/phd/RNASeq/sra_run_tables.csv`

    -   This appears to have columns out of order so it is important to consider that there might be more data available and to search sraDatAll for genus names to check.

```{r selecting_more_data, echo=F, eval=F}
run_all <- F
if(run_all){
datAll <- read.csv("~/phd/RNASeq/sra_run_tables.csv")

assayTypes <- datAll %>% group_by(Assay.Type) %>% summarise(count = n())
sraDatAll <- datAll %>% filter(grepl(pattern = "RNA", x = Assay.Type))
                      
                      
dat <- sraDatAll %>% filter(grepl(pattern = "Illumina", Instrument), LibraryLayout == "PAIRED") %>% unique()

dat <- dat %>% select(Run, Experiment, Organism, Strain, ReleaseDate, Sample.Name, SRA.Study, LibraryLayout, LibrarySelection, LibrarySource, Instrument) %>% mutate_all(as.character)

# datAll <- datAll %>% select(Run, Experiment, Organism, Strain, ReleaseDate, Sample.Name, SRA.Study, LibraryLayout, LibrarySelection, LibrarySource, Instrument) %>% mutate_all(as.character)

SRA_bacteria_RNASeq_v2 <- dat
SRA_bacteria_RNASeq_v2_all <- sraDatAll
save(SRA_bacteria_RNASeq_v2, file ="~/bin/r_git/R/r_files/SRA_bacteria_RNASeq_v2.Rda")
save(SRA_bacteria_RNASeq_v2_all, file ="~/bin/r_git/R/r_files/SRA_bacteria_RNASeq_v2_all.Rda")


load("~/bin/r_git/R/r_files/SRA_bacteria_RNASeq_v2.Rda")
load("~/bin/r_git/R/r_files/SRA_bacteria_RNASeq_v2_all.Rda")

sraDat <- SRA_bacteria_RNASeq_v2
sraDatAll <- SRA_bacteria_RNASeq_v2_all

strainsCount <- sraDatAll %>% group_by(Organism, Strain) %>% summarise(count = n())

sraDatAll <- sraDatAll %>% separate(col = Organism, into = "genus", sep = " ", remove = F, extra = 'drop')
library.options <- c("PAIRED", "SINGLE")
sraDatAll1 <- sraDatAll %>% filter(LibraryLayout %in% library.options) 
sraDatAll2 <- sraDatAll %>% filter(SRA.Study %in% library.options) %>% select(-genus) %>% mutate(LibraryLayout = SRA.Study)
sraDatAll3 <- sraDatAll %>% filter(AvgSpotLen %in% library.options) %>% select(-genus) %>% mutate(LibraryLayout = AvgSpotLen)
sraDatAll4 <- sraDatAll %>% filter(Sample.Name %in% library.options) %>% select(-genus) %>% mutate(LibraryLayout = Sample.Name)
sraDatAll5 <- sraDatAll %>% filter(genus %in% library.options) %>% mutate(LibraryLayout = genus) %>% select(-genus) 
sraDatAll6 <- sraDatAll %>% filter(LibrarySelection %in% library.options) %>% select(-genus) %>% mutate(LibraryLayout = LibrarySelection)
sraDatAll7 <- sraDatAll %>% filter(Platform %in% library.options) %>% select(-genus) %>% mutate(LibraryLayout = Platform)



sraDatAll2 <- sraDatAll2  %>% 
  dplyr::mutate(Organism = Bytes)%>% separate(col = Organism, into = "genus", sep = " ", remove = F, extra = 'drop')
sraDatAll3 <- sraDatAll3 %>% 
  dplyr::mutate(Organism = DATASTORE.filetype)%>% separate(col = Organism, into = "genus", sep = " ", remove = F, extra = 'drop')
sraDatAll4 <- sraDatAll4 %>%  
  dplyr::mutate(Organism = Bases)%>% separate(col = Organism, into = "genus", sep = " ", remove = F, extra = 'drop')
sraDatAll5 <- sraDatAll5 %>% 
  dplyr::mutate(Organism = Sample.Name)%>% separate(col = Organism, into = "genus", sep = " ", remove = F, extra = 'drop')
sraDatAll6 <- sraDatAll6 %>% 
  dplyr::mutate(Organism = Platform)%>% separate(col = Organism, into = "genus", sep = " ", remove = F, extra = 'drop')
sraDatAll7 <- sraDatAll7 %>% 
  dplyr::mutate(Organism = SRA.Study)%>% separate(col = Organism, into = "genus", sep = " ", remove = F, extra = 'drop')




genusCount1 <- sraDatAll1 %>% group_by(genus) %>% summarise(count = n())
genusCount2 <- sraDatAll2 %>% group_by(genus) %>% summarise(count = n())
genusCount3 <- sraDatAll3 %>% group_by(genus) %>% summarise(count = n())
genusCount4 <- sraDatAll4 %>% group_by(genus) %>% summarise(count = n())
genusCount5 <- sraDatAll5 %>% group_by(genus) %>% summarise(count = n())
genusCount6 <- sraDatAll6 %>% group_by(genus) %>% summarise(count = n())
genusCount7 <- sraDatAll7 %>% group_by(genus) %>% summarise(count = n())

genusCount <- genusCount1 %>% bind_rows(genusCount2, genusCount3, genusCount4, genusCount5, genusCount6, genusCount7)


sraDatAll <- sraDatAll1 %>% bind_rows(sraDatAll2, sraDatAll3, sraDatAll4, sraDatAll5, sraDatAll6, sraDatAll7)

sraDatAll <- sraDatAll %>% select(Run, Experiment, Organism, Strain, genus, LibraryLayout, ReleaseDate, Sample.Name, SRA.Study, LibrarySelection, LibrarySource, Instrument) %>% mutate_all(as.character)

save(sraDatAll, file = "~/bin/r_git/R/r_files/sraDatAll.Rda")
}

```


The genome accession for each added genome was looked up on [NCBI](https://www.ncbi.nlm.nih.gov/) using the strain name in the file or by search for the given experiment in the [SRA](https://www.ncbi.nlm.nih.gov/sra/) section:

-   Take the experiment ID e.g SRR3742546

-   Search [SRA](https://www.ncbi.nlm.nih.gov/sra/) or [NCBI](https://www.ncbi.nlm.nih.gov/) and select the SRA result for this ID
    
-   Select the 'Organism:' link

-   Select the Genome option from the box of options currently on the upper right of the page. It will probably have a 1 which is a clickable link beside it. Click this link.
    
-   From the reference genome section select the Refseq ID of the Chr option. 

-   This will open a genbank file that should list Assembly accession. Select this.

-   From the full report copy the GenBank assembly accession: e.g GCA_002504285.1

-   Create a folder for the genus

-   Create a folder using the GenBank assembly accession e.g. `mkdir GCA_002504285.1.data/`

-   Create an experiments_list.txt file listing all of the SRA experiments for the given genome and save the file in the genus folder.
    
-   Run [*callPeaksforGenome.sh*](#section-callpeaksforgenome) *-g* *\<GCA Accession\>* *-s*

A taxonomy table was generated with the code below. This had to be supplemented by going through manually to correct mistakes, or fill in missing data.

-   *genera_list.txt* was made by hand by searching for RNASeq files for each genus as above and if found, the genus was added to the file. 

    -   this would not be practical for a bigger clade.

```{python get_taxonomy, eval=F}
genera = pd.read_csv('/Users/thomasnicholson/bin/python_git/python_files/genera_list.txt', header = None)
df_len = len(genera)

genera['Kingdom'] = 1
genera['Phylum'] = 1
genera['Class'] = 1
genera['Order'] = 1
genera['Family'] = 1
genera['Genus'] = genera.iloc[:,0]

i = -1
for item in genera.iloc[:,0]:
    i += 1
    html_link = 'https://en.wikipedia.org/wiki/%s' % item
    print(html_link)
    
    
    try:
        html_page = urllib.request.urlopen(html_link)
    except urllib.error.HTTPError as exception:
        next
    record_values = False
    pos_val = 0
    taxonomy_levels = []
    for line in html_page:
        mystr = line.decode("utf8")
        if record_values == False:
            if "<td>Kingdom" in mystr:
                record_values = True
            elif "<td>Domain" in mystr:
                record_values = True                
        else:

            if pos_val > 5:
                break
            if 'href="/wiki/' in mystr:
                pos_val += 1
#                 print(pos_val)
                level_name = mystr.split("/")[2]
                level_name = level_name.split('"')[0]
                print(level_name)
#                 print(genera.iloc[i,:])
                genera.iloc[i,pos_val]  = level_name


```

##Subset of genomes {#subest_of_all_genomes}

Two genomes from each genera (from REFSEQ95) were selected as a representative set of genomes

-   This is done on the server (biochemcompute.uod.otago.ac.nz) using [Rstudio](http://biochemcompute.uod.otago.ac.nz:8787/) from the browser

```{r get_genomes_for_analysis, eval=F}
assembly_summary <- read.table("/Volumes/scratch/brownlab/chrisbr/DB/REFSEQ_REPREF/bacteria/assembly_summary_repref.txt", sep = "\t", fill = T, quote = "", comment.char = "")
assembly_summary <- assembly_summary %>% select(V1, V5, V8, , V18, V20, V12, V6)
colnames(assembly_summary) <- c("accession.1", "type", "species", "accession.2", "genome_link", "assembly.type", "some_number")

assembly_summary <- assembly_summary %>% separate(col = species, into = "genus", sep = " ", extra = 'drop', remove = F)

all_genera <- assembly_summary %>% group_by(genus) %>% summarise(count_all = n())
dat <- assembly_summary %>% filter(assembly.type != "Scaffold")
genera <- dat %>% group_by(genus) %>% summarise(count = n())

genera <- genera %>% full_join(all_genera, by = 'genus')


complete_genomes <- assembly_summary %>% filter(assembly.type == "Complete Genome")
contigs <- assembly_summary %>% filter(assembly.type == "Contig")

complete_genomes <- complete_genomes %>% 
  group_by(genus) %>% 
  mutate(counter = row_number()) %>% 
  filter(counter < 3) %>% 
  mutate(group = "complete")

contigs <- contigs %>% 
  group_by(genus) %>% 
  mutate(counter = row_number() + 2) %>% 
  filter(counter < 5) %>% 
  mutate(group = "contig")

complete_genomes <- complete_genomes %>% 
  bind_rows(contigs) %>% 
  group_by(genus) %>% 
  arrange(counter) %>% 
  mutate(counter.2 = row_number()) %>% 
  filter(counter.2 < 3)

files <- complete_genomes %>% mutate(species.2 = str_replace_all(string = species, pattern = " ", "_")) %>% mutate(file_path = paste(substr(genus, 1, 1), "/", species.2, "-", some_number, "\\#", accession.1, "/", sep = "")) %>% ungroup() %>% select(file_path)

write.table(x = files, file = "~/bin/r_git/R/r_files/server_genomes_file_paths.txt", quote = F, row.names = F, col.names = F)

write.table(x = complete_genomes$accession.2, file = "~/phd/RNASeq/all_taxa_accession.txt", quote = F, row.names = F, col.names = F)
write.table(x = complete_genomes$species, file = "~/phd/RNASeq/all_taxa_names.txt", quote = F, row.names = F, col.names = F)
```

*genera_list_predicted.txt* was made by taking the genus names that have been used in the analysed set.

The phylip tree was downloaded from NCBI's [Taxonomy Browser](#https://www.ncbi.nlm.nih.gov/Taxonomy/CommonTree/wwwcmt.cgi)

`mv phyliptree.phy ~/phd/RNASeq/genera_tree_predicted.phy`

```{r tree_viewer, echo=T, include=F, eval=F}
  tree <- read.tree("~/phd/RNASeq/upsetr.tree")

p <- ggtree(tree) + 
  geom_tiplab(align = T) 

p

ggsave(filename = "~/phd/RNASeq/figures/upsetr_tree.svg", plot = p, width = 8, height = 16)

```

#Predicting sRNAs {#predicting_srnas}

***

##Download data and map reads {#data_download}

**Scripts involved for each Accession**

-   [*callPeaksforGenome.sh*](#section-callpeaksforgenome) *-g* *\<GCA Accession\>* *-s*

    -   The *-s* flag is now used to indicate that a file named *experiments_list.txt* should be used for the list of RNASeq accessions. This is due to the new file containing accessions being less organised and requiring this new input.

    -   Only accessions with \>4 RNA-Seq files are analysed

    -   [*fetch_genomes_from_GCA.sh*](#section-fetch_genomes_from_gca.sh) *-r* *\<GCA Accession\>* *-g*

        -   The genome and gff files are downloaded from ncbi using the GCA acession
        -   *-g* flag is for downloading GFF file

    -   The RNA-Seq data is downloaded using *fasterq-dump* with a given accession

        -   these are selected from a file (shown below) containing a list of RNA-Seq experiment IDs for each strain. (Old)
        -   filtered for paired ends, Illumina HiSeq

    -   [*sra2plot.1.0.3.sh*](#section-sra2plot.1.0.3.sh) *-s* *\<SRA Accession\>* *-r* *\<GCA Accession\>* *-d* *-n* *\<Number of CPUs\>*

        -   Maps the reads
        -   *-d* turns off the downloading function of the script as this is being done separately

    -   [*removeProteinCodingRNA.R*](#section-removeproteincodingrna.r) *-f* *\<SRA Accession\>* *-g* *\<GCA Accession\>*

    -   [*run_rnaPeakCalling.R*](#section-run_rnapeakcalling.r) *-f* *\<SRA Accession\>* *-g* *\<GCA Accession\>*

    -   [*rfamscan*](#section-rfamscan) *\<GCA Accession\>*

        -   Searches the given genome for rFam models and reformats output into GFF format
        -   [*cmscanToGffWrapper.R*](#section-cmscantogffwrapper.r) *-f* *\<GCA Accession\>.tblout* *-g* *\<GCA Accession\>*

    -   [*combine_gff_files.R*](#section-combine_gff_files.r) -f *./gff_files/* *-o* *\<GCA Accession\>*


***


##Call peaks on individual RNA-Seq experiments {#call_peaks}


Description:

-   A plot file is produced. This contains a number for each nucleotide that indicates read depth.

-   The read depth is normalised and any region where the read depth is above a threshold for \>50 nt is called a peak.

    -   Threshold is set to the equivalent of \~15 nt read depth before normalisation

-   The protein coding regions are ignored



###RUF peak calling

The peak calling steps appeared to have something wrong so it was rewritten:

-   [*run_rnaPeakCalling.2.0.R*](#section-run_rnapeakcalling.2.0.r)

    -   This runs over all current plot files in the subfolders of *~/phd/RNASeq/genera/* and uses a slightly different approach to before

    -   It has everything hardcoded including file locations and no checks for overwriting existing files so before running this code
    
###Move old calls {#move_old_calls}

Moves existing `${experiment}_sra_calls.gff` files to an *old/* folder. This will prevent them from being included in the `${accession}_new_calls.txt` file from the [*combine_gff_files.R*](#section-combine_gff_files.r) script.

```{bash move_old_calls, eval=F}
##done in ~/phd/RNASeq/genera/

cd ~/phd/RNASeq/genera/
for genus in *;
do
#genus="Escherichia"


cd ~/phd/RNASeq/genera/${genus}


for folder in *.data;
do

cd ~/phd/RNASeq/genera/${genus}/${folder}/gff_files/

mkdir -p old

mv *_sra_calls.gff old


done
done
```


##Combining GFF file {#combining_gff_files}


At this stage each individual RNA-Seq file has a corresponding gff file of RUFs. There is also the original GFF file containing ncRNAs (along with CDS). Predictions of ncRNAs are made using rfam models and the output is made into a GFF file. There are 2 GFF files containing *known* sRNAs and a number of GFF files containing predicted RUFs.

-   feature files (.gff) files were all combined into a single `${accession}_new_calls.txt` file.

    -   [*combine_gff_files.R*](#section-combine_gff_files.r) *(done in gff_files folder)*

-   After combining all the individual calls for each genome there were a total of 8906 putative sRNAs.

-   For each sRNA that was predicted, a random intergenic region was selected.

    -   [*get_random_srna_sequences.py*](#section-get_random_srna_sequences.py) *-a* *\<GCA Accession\>*
    -   the file containing new calls for a given genome was used.
    -   this was done by randomly selecting a start site and taking the sequence from that location (for the same length as the orignial predicted sRNA).
    -   coding regions were removed

```{r, include=F}
files <- list.files("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/alignments/", pattern = ".stk")
file_count <- length(files)
```

-   There were `r file_count` random regions chosen


To simluate noise a set of regions were predicted based on selecting random regions of genomes of the equivalent size to the predicted RUFs in order to give a baseline of what is expected from different sRNA prediction approaches. 

-   All `${accession}_new_calls.txt` files are moved to *~/phd/RNASeq/new_calls/*


It is necessary to rerun the [*combine_gff_files.R*](#section-combine_gff_files.r) script for each strain due to the RUFs being predicted again after the intial run of the combine_gff_files.R

```{bash run_combine_gff_over_all_accessions, eval=F}
cd ~/phd/RNASeq/genera/
for genus in *;
do
  cd ~/phd/RNASeq/genera/${genus}
  for folder in *.data;
  do
    accession=`basename $folder .data`
    echo $genus $accession
    cd ~/phd/RNASeq/genera/${genus}/${folder}/
    combine_gff_files.R -f ./gff_files/ -o $accession
  done
done
```

##Get sRNA Sequences {#get_srnas}

Once the`${accession}_new_calls.txt` files have been made the predicted sequences are needed.


###Predicted RUFs

The fasta files and calls files for each individual strain are all moved to common folders.

```{bash move_files_to_common_folders, eval=F}
cd ~/phd/RNASeq/sequences
cp ~/phd/RNASeq/genera/*/*/*.fna ./
cd ~/phd/RNASeq/new_calls
mkdir -p old
mv *_new_calls.txt old/
cp ~/phd/RNASeq/genera/*/*/*_new_calls.txt ./
```      
      
Each of the calls files are then used to obtain the coordinates (contig, start and end locations) for each RUF. These are then extracted from the genome fasta files and written to a common fasta file. Writing to a common file is useful, although a later step of writing each RUF to a unique file is necessary as a result. Combining these steps would have been sensible.

-   [*get_sRNA_sequences.py*](#section-get_srna_sequences.py) is currently used

-   `esl-sfetch` with a while loop for each file would be better if this is ever redone

      
```{bash get_sRNA_sequences_loop, eval=F, include=T}
##done in ~/phd/RNASeq/new_calls/
cd ~/phd/RNASeq/srna_seqs/version_1/
mkdir -p seqs_predicted
cd ~/phd/RNASeq/new_calls/
for file in *.txt; 
do 
  accession=`basename $file _new_calls.txt`; 
  echo $accession; get_sRNA_sequences.py -a $accession; 
done
```

###Random regions

The random sequences are obtained in a similar way using [*get_random_srna_sequences.py*](#section-get_random_srna_sequences.py). 

-   `esl-sfetch` with a while loop for each file would be better if this is ever redone


```{bash get_random_srna_sequences_loop, eval = F}
##done in ~/phd/RNASeq/new_calls/
for file in *.txt; do accession=`basename $file _new_calls.txt`; echo $accession; get_random_srna_sequences.py -a $accession; done
```



###Fasta files for each RUF

This step creates a fasta file for each RUF. This is needed so that nhmmer can be used as the input for the query can only be a single sequence or alignment (from what I could figure out). The script [*single_fasta_files.py*](#section-single_fasta_files.py) is used although this could have been built into [*get_sRNA_sequences.py*](#section-get_srna_sequences.py).

```{bash single_fasta_files_loop, eval = F}
##done in ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}
group="positive_control"
cd ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}

mkdir -p single_seqs

if [[ $group == "predicted" ]]; then

fasta_file="predicted.fna"

elif [[ $group == "positive_control" ]]; then
fasta_file="predicted_known.fna"

else;
echo "${group} not a valid option for group variable"
fasta_file=""


fi

cat GCA*.fna >> ${fasta_file}
single_fasta_files.py -i seqs_predicted/${group}/${fasta_file} -f seqs_predicted/${group}/single_seqs/


```


##Build models {#run_nhmmer}

Each of the measures used for evaluating RUFs are improved by alignments with more unique sequences. In order to build models for each RUF (and control group) a number of steps were done.

-  The following steps are described for the *predicted* data set but this also applys to the *negative* *control* dataset

-   The *positive* *control* dataset steps are described [later](#section-cmscan_rfam)

###Predicted nhmmer (first iteration)

```{r, include=F}
known_files <- list.files("~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/positive_control/single_seqs/done/", pattern = ".fna")
known_count <- length(known_files)

novel_files <- list.files("~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/predicted/single_seqs/", pattern = ".fna")
novel_count <- length(novel_files)

```

The predicted RUFs are built into model by searching the set of predicted RUFs in an all by all search. This first step is done in order to make later steps reducing redundanc easier.

-   The RUFs have been split into those that overlap with a known sRNA (`r prettyNum(known_count, big.mark = ',')`) and those that are novel (`r prettyNum(novel_count, big.mark = ',')`)

-   nhmmer needs to be run on both datasets.


There are some files showing up that shouldn't be there.

To get rid of them:

`group="predicted"`

`cd ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}/single_seqs`

`mkdir done/`

` mv GCA* done/`

`rm *.fna`

`mv done/* ./`


```{bash run_srna_nhmmer_loop_initial, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}
group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}

mkdir single_seqs/done/

run_sRNA_nhmmer.sh -d ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}/predicted*.fna -f single_seqs/ -e fna

```

-   the output extension uses *.fna* instead of *.stk* which needs to be changed

```{bash change_fna_stk, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}/alignments
group="predicted"

cd ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}/alignments

for file in *.fna;
do
outname=`basename $file .fna`

mv $file $outname.stk

done

```

The removing duplicates step of run_sRNA_nhmmer.sh is not working. This does the same thing.

```{bash remove_duplicates_from_nhmmer, eval=F}

##done in ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}/alignments

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}/alignments

mkdir -p ignore
mkdir -p keep

for file in *.stk; 
do 

lines=`wc -l < $file`; 
echo $lines; 

if (( $lines == 0 ));  then
mv $file ignore
fi

done


for file in *.stk; 
do

grep ^"#=GS" $file  | cut -d '[' -f1 | rev | cut -d ' ' -f1 | rev > move_files.txt

mv $file keep/

while read line; 
do

mv $line.stk ignore/

done < move_files.txt

done

mv keep/* ./

```


The next step involves using the server and in order to do this all the files need to be copied into a folder.

Run on server (*biochemcompute.uod.otago.ac.nz*):

```{bash server_transfer_setup, eval=F}
##done in ~/phd/RNASeq/srnas/${group}
group="predicted"
cd ~/phd/RNASeq/srnas/${group}
mkdir -p initial_alignments
```

Run locally:

```{bash transfer_to_server,eval=F}
cd ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/predicted/alignments
scp *.stk bioc:./phd/RNASeq/srnas/predicted/initial_alignments
```

###Predicted nhmmer (second iteration)

Each of the alignments for predicted RUFs are used as queries to search against the set of representative genomes in order to expand the number of sequences used and to determine the evolutionary conservation of each RUF.

Run on server (*biochemcompute.uod.otago.ac.nz*):

-   `screen -list` to see screens

-   `screen -r $ID ` to reattach screen

```{bash run_srna_nhmmer_loop_large_alignments, eval=F}
##done in ~/phd/RNASeq/srnas/${group}
group="predicted"
cd ~/phd/RNASeq/srnas/${group}
run_sRNA_nhmmer.sh -d ~/phd/RNASeq/representative_genomes.fna -f initial_alignments/ -o large_alignments/ -e stk -E 1e-5
```


# Known sRNAs{#known_srna}

The known sRNAs are used for two purposes:

-   The ribosomal small subunit is used to calculate phylogenetic distances for each of the genomes used

-   All rFam models with sRNAs < 500 nt are used as a *positive* *control* dataset

##Find known sRNAs

###cmscan with RFam families {#cmscan_rfam}

The RFam families were downloaded from [Rfam](https://rfam.xfam.org/):

-   Click *FTP*

    -   Select Guest as user and connect
    
    -   open Current (14.4)
    
Two files were downloaded:

-   *Rfam.cm* contains all the models for the families

    -   The *RFam.cm* file needed to be unzipped `gunzip Rfam.cm.gz`.

-   *Rfam.clanin.txt* contains clan information


These files were used to search against the set of representative genomes and analysed genomes.

```{bash run_csmscan_across_multiple_files, eval=F, include=T}
#in ~/phd/RNASeq/representative_genomes
#in ~/phd/RNASeq/analysed_genomes
mkdir check_files
for file in *.fna; 
do 

  runname=`basename $file .fna`;  

  if [ -f "check_files/${runname}.tmp.out" ]; then 
    echo "Already exists: $runname"; 
    continue;
  else 
    echo "$runname";  
  fi;  
  
  rfamscan $file;  
  > check_files/$runname.tmp.out;  

done

```

This search gave an output for each genome containing coordinates (contig, start, end, strand) for the location of sequences matching Rfam families. These files needed to be combined and reformatted so that the nucelotide sequences of the matches could be obtained. This was done for each group:

`group="representative_genomes"`

`group="analysed_genomes"`

The outputs combined with `cat *.tblout >> ../${group}.tblout`. This output was reformatted so that it could be easily read into R `cat ${group}.tblout | sed 's/  /\t/g' | tr -s '\t' | sed 's/\t /\t/g' | sed 's/ \t/\t/g' | sed 's/ /\t/3' | sed 's/ /\t/' | sed 's/ /\t/' | sed 's/ /_/g' | sed 's/_!/\t!/g' | tr -s '\t' | sed 's/Pseudomonas\t/Pseudomonas_/g' > ${group}.tab`


All of the genomes for each group were combined into one file for easier coding of the step involving getting the sequences `cat *.fna >> ../${group}.fna`

The files were then marked as completed:

`mkdir done`

`mv *.fna done/`

`mv *.tblout done/`

###Lookup table (genomes and contigs)

The results from cmscan and nhmmer use contig accessions for the target accessions, while the genomes that were used have genome accessions. It was therefore necessary to create a lookup table of genome and contig accessions.

- done on server (biochemcompute.uod.otago.ac.nz) initially

```{bash genome_contig_pairs, eval=F}
#done from ~/phd/RNASeq/representative_genomes/

cd ~/phd/RNASeq/representative_genomes/

> ../genome_contig_pairs.txt
for file in GC*.fna;  
do   

  ID=`echo $file | cut -d '.' -f1,2 | cut -d "_" -f1,2`;   
  grep ^">" $file | cut -d ' ' -f1 | sort | uniq | sed 's/>//g' | sed -e "s/$/   $ID/" >> ../genome_contig_pairs.txt;   
done
```

`cd ~/phd/RNASeq/`

`scp bioc:./phd/RNASeq/genome_contig_pairs.txt ./`

```{bash genome_contig_pairs_analysed_genomes, eval=F}
#done from ~/phd/RNASeq/representative_genomes/
cd ~/phd/RNASeq/
for file in ./genera/*/*/GC*.fna;  
do   
echo $file
  ID=`basename $file | cut -d '.' -f1,2 | cut -d "_" -f1,2`;
  grep ^">" $file | cut -d ' ' -f1 | sort | uniq | sed 's/>//g' | sed -e "s/$/   $ID/" >> ./genome_contig_pairs.txt;   
done
```


###Coordinates from cmsearch

The reformatted cmscan output is used to create files `${family}_locations.txt` for each of the Rfam families of  the coordinates of all the matching regions from the representative and analysed genomes.
    
-   This was done on the server (biochemcompute.uod.otago.ac.nz) using [Rstudio](http://biochemcompute.uod.otago.ac.nz:8787/) from the browser

-   representative genomes

```{r cmsearch_res_pc, eval=F}

##file made with cat RF00177.tbl | sed 's/  /\t/g' | tr -s '\t' | sed 's/\t /\t/g' | sed 's/ \t/\t/g' | sed 's/ /\t/3' | sed 's/ /\t/' | sed 's/ /\t/' | sed 's/ /_/g' | sed 's/_!/\t!/g' | tr -s '\t' | sed 's/Pseudomonas\t/Pseudomonas_/g' > RF00177.tab along with manually replacing some incorrect _ and \t 

dat <- read.table("~/phd/RNASeq/representative_genomes.tab", sep = "", quote = "", comment.char = "#", fill = T)

contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("query.name", "genome")

dat <- dat[,2:18]

colnames(dat) <- c("description.of.target", "target.name", "query.name", "accession", "accession.2", "mdl", "mdl.from", "mdl.to", "seq.from", "seq.to", "strand", "trunc", "pass", "gc", "bias", "score", "e.value")

dat <- dat %>% filter(!is.na(e.value))

dat <- dat %>% group_by(target.name, query.name) %>% 
  arrange(as.numeric(e.value)) %>% 
  mutate(order.num = row_number()) %>% 
  filter(order.num == 1) %>% 
  ungroup()





smalldat <- dat %>% 
  select(target.name, query.name, seq.from, seq.to, strand, e.value, mdl.from, mdl.to)

smalldat <- smalldat %>% left_join(contig_labels, by = 'query.name') %>% 
  group_by(genome, target.name) %>% 
  arrange(as.numeric(e.value)) %>%
  mutate(order.num = row_number()) %>% 
  filter(order.num == 1) %>% 
  ungroup()

RF00177 <- smalldat %>% filter(target.name == "RF00177") 


for(item in unique(smalldat$target.name)){
  print(item)
  modelDat <- smalldat %>% filter(target.name == item)
  if(nrow(modelDat) == 0){
    continue
  }
  modelDat <- modelDat %>% select(query.name, seq.from, seq.to, strand)
  
write.table(x = modelDat, file = paste("~/phd/RNASeq/rfam_files/locations/", item,"_locations.txt", sep = ""), row.names = F, col.names = F, quote = F, sep = "\t")
  

}

  write.table(x = RF00177 %>% select(query.name, seq.from, seq.to, strand), file = "~/phd/RNASeq/rfam_files/RF00177_locations.txt", row.names = F, col.names = F, quote = F, sep = "\t")


```

-   analysed genomes

```{r cmsearch_res_analysed_genomes, eval=F}

##file made with cat RF00177.tbl | sed 's/  /\t/g' | tr -s '\t' | sed 's/\t /\t/g' | sed 's/ \t/\t/g' | sed 's/ /\t/3' | sed 's/ /\t/' | sed 's/ /\t/' | sed 's/ /_/g' | sed 's/_!/\t!/g' | tr -s '\t' | sed 's/Pseudomonas\t/Pseudomonas_/g' > RF00177.tab along with manually replacing some incorrect _ and \t 

dat <- read.table("~/phd/RNASeq/analysed_genomes.tab", sep = "", quote = "", comment.char = "#", fill = T)

contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("query.name", "genome")

dat <- dat[,2:18]

colnames(dat) <- c("description.of.target", "target.name", "query.name", "accession", "accession.2", "mdl", "mdl.from", "mdl.to", "seq.from", "seq.to", "strand", "trunc", "pass", "gc", "bias", "score", "e.value")

dat <- dat %>% filter(!is.na(e.value))

dat <- dat %>% group_by(target.name, query.name) %>% 
  arrange(as.numeric(e.value)) %>% 
  mutate(order.num = row_number()) %>% 
  filter(order.num == 1) %>% 
  ungroup()





smalldat <- dat %>% 
  select(target.name, query.name, seq.from, seq.to, strand, e.value, mdl.from, mdl.to)

smalldat <- smalldat %>% left_join(contig_labels, by = 'query.name') %>% 
  group_by(genome, target.name) %>% 
  arrange(as.numeric(e.value)) %>%
  mutate(order.num = row_number()) %>% 
  filter(order.num == 1) %>% 
  ungroup()

RF00177 <- smalldat %>% filter(target.name == "RF00177") 


for(item in unique(smalldat$target.name)){
  print(item)
  modelDat <- smalldat %>% filter(target.name == item)
  if(nrow(modelDat) == 0){
    continue
  }
  modelDat <- modelDat %>% select(query.name, seq.from, seq.to, strand)
  
write.table(x = modelDat, file = paste("~/phd/RNASeq/analysed_genomes_rfam_files/locations/", item,"_locations.txt", sep = ""), row.names = F, col.names = F, quote = F, sep = "\t")
  

}

  write.table(x = RF00177 %>% select(query.name, seq.from, seq.to, strand), file = "~/phd/RNASeq/rfam_files/RF00177_locations.txt", row.names = F, col.names = F, quote = F, sep = "\t")


```

###Get sequences

The `${family}_locations.txt` were then used to extract the nucelotide sequence of all matching regions from each of the corresponding fasta files. 

-   The fasta files needed to be indexed with `esl-sfetch --index ${group}.fna` 

A later step ([cmalign](#section-make_cm_files)) uses a lot of memory. To keep this step managable the files were limited to 20 sequences per file, with multiple files being created for each Rfam family if needed.

-   This is [later](#section-combine_alignments) combined with `esl-alimerge`

```{bash get_nucelotide_sequences, eval = F}   

##from ~/phd/RNASeq/rfam_files/

# > RF00177_rep_seqs.fna

i=0
file_count=1
> RF00177_files/RF00177_rep_seqs_${file_count}.fna
while read line; 
do 
  i=`expr $i + 1`
  if (( $i > 50 )); then
  i=0
  file_count=`expr $file_count + 1`
  > RF00177_files/RF00177_rep_seqs_${file_count}.fna
  fi

  
  contig=`echo $line | cut -d ' ' -f1`; 
  contig_start=`echo $line | cut -d ' ' -f2`; 
  contig_end=`echo $line | cut -d ' ' -f3`; 
  contig_strand=`echo $line | cut -d ' ' -f4`;  
  
  length=`expr $contig_end - $contig_start`
  
  length=`echo $length | tr -d '-'`
  
  if (( $length < 1400 )); then
  echo "$contig too short" 
  continue
  fi

    esl-sfetch -c ${contig_start}..${contig_end} ../representative_genomes/representative_genomes.fna $contig        >> RF00177_files/RF00177_rep_seqs_${file_count}.fna;

done < RF00177_locations.txt


##from ~/phd/RNASeq/rfam_files/locations
##or
##from ~/phd/RNASeq/analysed_genomes_rfam_files/locations
for file in *_locations.txt;
do
outname=`basename $file _locations.txt`

echo $outname

i=0
file_count=1
mkdir -p ../${outname}_files/
> ../${outname}_files/${outname}_rep_seqs_${file_count}.fna
while read line; 
do 
  i=`expr $i + 1`
  if (( $i > 50 )); then
  i=0
  file_count=`expr $file_count + 1`
  > ../${outname}_files/${outname}_rep_seqs_${file_count}.fna
  fi

  
  contig=`echo $line | cut -d ' ' -f1`; 
  contig_start=`echo $line | cut -d ' ' -f2`; 
  contig_end=`echo $line | cut -d ' ' -f3`; 
  contig_strand=`echo $line | cut -d ' ' -f4`;  
  
  length=`expr $contig_end - $contig_start`
  
  length=`echo $length | tr -d '-'`
  


    esl-sfetch -c ${contig_start}..${contig_end} ../../${group}.fna $contig        >> ../${outname}_files/${outname}_rep_seqs_${file_count}.fna;

done < ${outname}_locations.txt



done < $file
done


```

###Make cm files {#make_cm_files}

The files with sequences for each rFam model need to be in stockholm alignment format which is done by running cmalign against the Rfam model.

```{bash make_cm_files, eval=F}
##from ~/phd/RNASeq/rfam_files/
##or
##~/phd/RNASeq/analysed_genomes_rfam_files

for folder in *_files; 
do 

  
  cmmodel=`basename $folder _files`;  

  
  cmfetch  ~/phd/RNASeq/Rfam.cm $cmmodel > current.cm;
  > $folder/ali_files.txt; 
  
  
  for file in $folder/*.fna; 
  do
  
    shortname=`basename $file`;
    outname=`basename $shortname .fna`;  
    cmalign -g --dnaout -o $folder/$outname.cm current.cm $file;  
    echo "$outname.cm" >> $folder/ali_files.txt;  
    
  done;  
done

```


###Remove empty files

Some of the files do not contain sequences and cause problems for the [merging](#section-combine_alignments) step. 

-   I think this is due to some earlier mistakes creating extra empty files that were not removed


```{bash remove_empty_files, eval=F}
for folder in *_files; 
do
  cd $folder
  
  > ali_files_2.txt
  
  while read line; 
  do
  
    line_length=`wc -l $line | cut -d ' ' -f1`
    
    if (( $line_length > 0 )); then
      echo $line >> ali_files_2.txt
    fi
    
  done < ali_files.txt
  mv ali_files_2.txt ali_files.txt
  cd ..

done
```


###Combine alignments {#combine_alignments}

Once the alignments have been built, it is possible to combine these alignments with `esl-alimerge` while also masking these alignments to the original model so that the alignments are kept very similar to the rfam family, while providing coordinates of the locations of sequences for the *representative* and *analysed* genomes.


```{bash combine_alignments, eval=F}
for folder in *_files;
do
  cd $folder
  outname=`basename $folder _files`
  echo $outname
  esl-alimerge --list ali_files.txt | esl-alimask --rf-is-mask - > $outname.stk
  cd ..
  
done
```


These files are downloaded from the server:

-   `cd ~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/alignments`

-   `scp bioc:./phd/RNASeq/rfam_files/alignments/* ./`


##Phylogenetic Distance

The bacterial ribosomal small subunit (RF00177) was used to get the phylogeneitc distances between all the genomes. This was done using [Phylip](https://evolution.genetics.washington.edu/phylip.html).

###Rename IDs

The phylip format for files uses shortened ID, limited to 10 characters. This means there needs to be a lookup table to reverse this in later steps.

```{r rename_alignment_ids, eval=F}
dat <- read.table("~/phd/RNASeq/RF00177.stk", sep = "\t", fill = T, comment.char = "", quote = "", header = F)

dat <- dat %>% separate(V1, into = c("a", "b", "c"), sep = " ", extra = 'merge', remove = F)

dat <- dat %>% mutate(id_test = ifelse(grepl(pattern = "/",x = b), T, F))


current_ids <- dat %>% filter(id_test) %>% select(b) %>% unique()

current_ids <- current_ids %>% separate(col = b, into = "id", extra = "drop", remove=F, sep = "/") %>% mutate(phylip_id = substr(x = b, start = 1, stop = 10))

write.csv(x = current_ids, file = "~/phd/RNASeq/uids_RF00177_alignment.txt", quote = F, row.names = F)
save(current_ids, file = "~/bin/r_git/R/r_files/current_ids.Rda")

```

###Reformat matrix

The phylip tool dnadist was used to create a distance matrix based on the SSU alignment.

The stockholm file was reformatted `esl-reformat phylip RF00177.stk > RF00177_rep_seqs_all.phylip` and this was used in dnadist as an input, with *RF00177_rep_seqs_all.dists* as the output. All settings used were defaults.

The matrix that is made is not in an easily useable format:

-   `cat  RF00177_rep_seqs_all.dists | tr '\n' ' ' | sed 's/ N/\nN/g' > RF00177_rep_MATRIX_all.dists`




##Negative control for matches to known elements {#check_negaitves}

Using known or predicted sRNAs for the negative control regions will reduce the effectiveness of the anaylis. Although the regions originally selected were not from these regions, after creating deep alignments some overlaps have shown up.

Similar to previous sections, the coordinates (target contig, start, end, query ID) are taken for each group.

```{bash get_ids_and_positions, eval=F, include=T}
##done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold

group='predicted'
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold
> ../${group}_contig_pos.txt
for file in *.stk;
do 

  ID=`echo $file | cut -d '.' -f1,2`
  echo $ID
  grep "/" $file | grep -v "//" | cut -d ' ' -f1 | sed 's/\// /g' | sed 's/-/ /g'| cut -d '|' -f2 | sort | uniq | sed -e "s/$/ $ID/" >> ../${group}_contig_pos.txt

done

```

##Overlaps between groups

The coordinates are used to check for overlaps and a file containing the query IDs of the negative control models that matched predicted or positive control models was made.

```{r compare_groups_for_overlap, eval=F}
library(GenomicRanges)
ncdat <- read.table("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_contig_pos.txt", sep = " ", fill = T, as.is = T)

pcdat <- read.table("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_contig_pos.txt", fill = T, as.is = T)

preddat <- read.table("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_contig_pos.txt", fill = T, as.is = T)


reformat_data <- function(dat){

colnames(dat) <- c("contig", "start", "stop", "srna")
dat <- dat  %>% select(contig, srna, start, stop) %>% mutate(strand = "+")

dat <- dat %>% mutate(start = as.numeric(start), stop = as.numeric(stop))

dat <- dat %>% mutate(tmpstart = ifelse(start < stop, start, stop),
                      tmpend = ifelse(start > stop, start, stop))
dat <- dat %>% filter(!is.na(tmpstart))
return(dat)
}

pcdat <- reformat_data(dat = pcdat)
ncdat <- reformat_data(dat = ncdat)
preddat <- reformat_data(dat = preddat)

getOverlapIDs <- function(queryDat, targetDat){
  queryDat <- queryDat %>% arrange(start)
  targetDat <- targetDat %>% arrange(start)
query <- GRanges(seqnames = queryDat$contig,
                 ranges = IRanges(start = queryDat$tmpstart, end = queryDat$tmpend),
                  strand = queryDat$strand, query_name = queryDat$srna)

target <- GRanges(seqnames = targetDat$contig,
                 ranges = IRanges(start = targetDat$tmpstart, end = targetDat$tmpend),
                  strand = targetDat$strand, query_name = targetDat$srna)


lookup1NC <- data.frame(id1 = queryDat$srna, queryHits = c(1:length(queryDat$srna)))
lookup2PC <- data.frame(id2 = targetDat$srna, subjectHits = c(1:length(targetDat$srna)))

tmp <- GenomicRanges::findOverlaps(query, target, type = 'any')

tmp <- as.data.frame(tmp)

tmp <- tmp %>% left_join(lookup1NC) %>% left_join(lookup2PC)
tmp <- tmp %>% mutate_all(as.character)
tmp <- tmp %>% filter(id1 != id2)

smallDat <- tmp %>% select(id1, id2) %>% unique()
return(smallDat)
}

nc.pc.Dat <- getOverlapIDs(queryDat =ncdat, targetDat = pcdat)
nc.pred.Dat <- getOverlapIDs(queryDat =ncdat, targetDat = preddat)
pc.pred.Dat <- getOverlapIDs(queryDat =preddat, targetDat = pcdat)

dat <- data.frame(ids = c(nc.pc.Dat$id1, nc.pred.Dat$id1))

write.table(dat, file = "~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/not_negative_control_ids.txt", row.names = F, col.names = F, quote = F)

dat2 <- data.frame(ids =  pc.pred.Dat$id1)

write.table(dat2, file = "~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_matches_positive_control_ids.txt", row.names = F, col.names = F, quote = F)

```

##Remove sRNAs that are not negative controls

This step was done later and meant that all results needed to be removed. The sRNAs listed in the *not_negative_control_ids.txt* file were moved to an *ignore/* folder.

```{bash remove_not_nc, eval=F, include=T}
##done in ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids


cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/

mkdir -p RNAAlifold/keep
mkdir -p alifold/keep
mkdir -p alignments_rnaalifold/keep
mkdir -p rscape_out/keep

mkdir -p RNAAlifold/ignore_2
mkdir -p alifold/ignore_2
mkdir -p alignments_rnaalifold/ignore_2
mkdir -p rscape_out/ignore_2




while read line;
do

mv ./RNAAlifold/$line* ./RNAAlifold/ignore_2
mv ./alifold/$line* ./alifold/ignore_2
mv ./alignments_rnaalifold/$line* ./alignments_rnaalifold/ignore_2
mv ./rscape_out/$line* ./rscape_out/ignore_2

done < not_negative_control_ids.txt

```

#Remove redundancy {#remove_redundancy}

***


Each of the predicted sRNAs have been used in a search of ~1500 genomes. As there are many sRNAs each comntributing to each model, it is important to enusre that each sequence only shows up in one model rather than several. This means combining the duplicated models to remove redundancy. This will be done by getting the coordinates of each match for each contig and checking for overlapping regions and the overlapping regions will be merged.

- done on the server (biochemcompute.uod.otago.ac.nz)
    



##Redundancy example

Test example dataframe if there is a test that is needed on a small dataset.

```{python redundacy_test_example, eval=F}
test_contigs = ['N1', 'N2', 'N3', 'N4']
test_data = {'query_id':['G1', 'G2', 'G3', 'G1', 'G2', 'G3', 'G1', 'G1', 'G3', 'G3', 'G2', 'G3'], 
             'target_contig':['N1', 'N1', 'N1', 'N2', 'N2', 'N2', 'N3', 'N3', 'N3', 'N3', 'N4', 'N4'],
            'target_start':[1, 1, 2, 100, 100, 100, 940, 855, 940, 855, 1010, 1015],
            'target_end':[100, 100, 95, 180, 180, 180, 860, 935, 860, 935, 1110, 1120]}

```


##Coordinates of matches{#contigs_and_cordinates_of_matches}

From the output (stoockholm format) for each RUF, a file containing coordinates (target contig, query ID, start, end) id generated for the predicted and negative control dataset (should be done for the positive control as well).

```{bash contigs_and_cordinates_of_matches, eval=F}
##done in ~/phd/RNASeq/srnas/predicted/large_alignments/alignments

group="predicted"

cd ~/phd/RNASeq/srnas/${group}/large_alignments/alignments
> ../../${group}_genomic_sequence_matches.txt
for file in *.stk;
do 

  ID=`echo $file | cut -d '.' -f1,2`
  grep ^"#=GS" $file | sort | uniq | cut -d "[" -f1 | cut -d ' ' -f2  | cut -d '|' -f2- |  sed -e "s/$/   $ID/" >> ../../${group}_genomic_sequence_matches.txt

done
 
```

##Identify redundancy (novel predicted)

This method uses GenomicRanges and IRanges to find overlaps and save the list of overlapping models in a file using the first model as the file name. This will continue to be the model name going forward.

- done on the server (biochemcompute.uod.otago.ac.nz)

- repeated for the positive control dataset on the MacBook

```{r redundancy_1_R, eval=F}

dat <- read.table("~/phd/RNASeq/srnas/predicted/predicted_genomic_sequence_matches.txt", sep = " ", fill = T, as.is = T)

dat <- dat %>% select(V1, V4)
dat <- dat %>% separate(col = V1, into = c("contig", "coordinates"), sep = "\\/", remove = F)
dat <- dat %>% separate(col = coordinates, into = c("start", "stop"), sep = "-", remove = F)
dat <- dat %>% dplyr::rename(srna = V4) %>% select(contig, srna, start, stop) %>% mutate(strand = "+")
colnames(dat) <- c("contig","srna", "start", "stop", "strand") 

dat <- dat %>% mutate(start = as.numeric(start), stop = as.numeric(stop))

dat <- dat %>% mutate(tmpstart = ifelse(start < stop, start, stop),
                      tmpend = ifelse(start > stop, start, stop))

query <- GRanges(seqnames = dat$contig,
                 ranges = IRanges(start = dat$tmpstart, end = dat$tmpend),
                  strand = dat$strand, query_name = dat$srna)


lookup1 <- data.frame(id1 = dat$srna, queryHits = c(1:length(dat$srna)))
lookup2 <- data.frame(id2 = dat$srna, subjectHits = c(1:length(dat$srna)))


tmp <- GenomicRanges::findOverlaps(query, query, type = 'any')

tmp <- as.data.frame(tmp)

tmp <- tmp %>% left_join(lookup1) %>% left_join(lookup2)

tmp <- tmp %>% filter(id1 != id2)

smallDat <- tmp %>% select(id1, id2) %>% unique()
smallDat <- smallDat %>% mutate_all(as.character)

s2 <- smallDat
s2$id1 <- smallDat$id2
s2$id2 <- smallDat$id1

smallDat <- smallDat %>% bind_rows(s2) %>% unique()

ids <- as.character(unique(dat$srna))
item <- ids[68]
item2 <- "alignments_GCA_000017765.1_689"

groupOverlapItems <- function(smallDat, item, current_ids){
  # print(length(current_ids))
  # print(item)
  if(length(current_ids) == 0){
    current_ids <- item
  }
  df <- smallDat %>% filter(id1 == item)

  if(nrow(df) == 0){
    return(current_ids)
  }
  df$seen <- df$id2 %in% current_ids
  df <- df %>% filter(seen == F)

  if(nrow(df) == 0){
    return(current_ids)
  }
  for(item2 in df$id2){
    current_ids <- unique(c(current_ids, item2))
    current_ids <- groupOverlapItems(smallDat, item2, current_ids)
  }
  return(current_ids)
}

item <- ids[ids == "alignments_GCA_000006945.2_2627"]
tmp <- groupOverlapItems(smallDat, item, current_ids = c())

checked_ids <- c()
for(item in ids){
  if(item %in% checked_ids){
    next
  }
  print(item)
  current_ids <- groupOverlapItems(smallDat, item, current_ids = c())
 
  checked_ids <- c(checked_ids, current_ids)
  
    write.table(x = current_ids, file = paste("~/phd/RNASeq/srnas/predicted/combined_alignment_ids/", current_ids[1], "_combined_list.txt", sep = ""), append = T, quote = F, row.names = F, col.names = F)

  # mat <- as.data.frame(t(as.matrix(current_ids)))
  # write.table(mat, file = "~/phd/RNASeq/tmp/nc_overlaps", append = T, quote = F, col.names = F, row.names = F, sep = "\t")
}

```

##Identify redundancy (known predicted)

There are too many sequences in the *known_predicted* dataset for the GenomicRanges version, however as there are already models built for known sRNAs these are used instead.

Get the list of all RUFs with a match to a known sRNA model:

`cd ~/phd/RNASeq/genera`

`cat */*/*_new_calls.txt | cut -f12- | grep "RF0" > ../new_calls/all_new_calls_v2.txt`

Loop over all the known sRNAs getting all the IDs that match to each of the known sRNAs. This file (*known_predicted_models_list.txt*) can be used to get values for the predicted dataset from the positive controls.

```{bash redundancy_known_predicted, eval=F}

cd ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/

> ./known_predicted_models_list.txt

for file in ~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/alignments/*;
do

ID=`basename $file .stk`

echo $ID

grep $ID ~/phd/RNASeq/new_calls/all_new_calls_v2.txt | cut -f2 | sort | uniq | sed -e "s/$/ $ID/"  >> ./known_predicted_models_list.txt

done

```



##Move negative control data

This quickly removes the overlapping negative controls leaving one of the models.


```{bash move_nc_quickly, eval=F, include=T}
##done in ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids


cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/

mkdir -p RNAAlifold/keep
mkdir -p alifold/keep
mkdir -p alignments_rnaalifold/keep
mkdir -p rscape_out/keep

mkdir -p RNAAlifold/ignore_2
mkdir -p alifold/ignore_2
mkdir -p alignments_rnaalifold/ignore_2
mkdir -p rscape_out/ignore_2


cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids

for file in *.txt;
do
idname=`basename $file _combined_list.txt`

mv ../RNAAlifold/$idname* ../RNAAlifold/keep
mv ../alifold/$idname* ../alifold/keep
mv ../alignments_rnaalifold/$idname* ../alignments_rnaalifold/keep
mv ../rscape_out/$idname* ../rscape_out/keep

while read line;
do

mv ../RNAAlifold/$line* ../RNAAlifold/ignore_2
mv ../alifold/$line* ../alifold/ignore_2
mv ../alignments_rnaalifold/$line* ../alignments_rnaalifold/ignore_2
mv ../rscape_out/$line* ../rscape_out/ignore_2


done < $file

done
```

Also used for the positive control

```{bash move_pc_quickly, eval=F, include=T}
##done in ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids


cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/

mkdir -p RNAAlifold/keep
mkdir -p alifold/keep
mkdir -p alignments_rnaalifold/keep
mkdir -p rscape_out/keep

mkdir -p RNAAlifold/ignore_2
mkdir -p alifold/ignore_2
mkdir -p alignments_rnaalifold/ignore_2
mkdir -p rscape_out/ignore_2


cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids

for file in *.txt;
do
idname=`basename $file _combined_list.txt | cut -d '.' -f1`

mv ../RNAAlifold/$idname* ../RNAAlifold/keep
mv ../alifold/alignments_${idname}* ../alifold/keep
mv ../alignments_rnaalifold/alignments_${idname}* ../alignments_rnaalifold/keep
mv ../rscape_out/alignments_${idname}* ../rscape_out/keep

while read line;
do

mv ../RNAAlifold/$line* ../RNAAlifold/ignore_2
mv ../alifold/alignments_${line}* ../alifold/ignore_2
mv ../alignments_rnaalifold/alignments_${line}* ../alignments_rnaalifold/ignore_2
mv ../rscape_out/alignments_${line}* ../rscape_out/ignore_2


done < $file

done
```


The files in the *keep* folders are moved back out to the main working folder with `mv ./keep/* ./`

##Combine sRNAs

For the predicted data, all sequences from overlapping models are extracted, and combined into a file and this file is used to build an alinment by using hmmalign against the largest alignment from the group of alignments that are being combined.

```{bash combine_sRNAs_bash, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids

cd ~/phd/RNASeq/srnas/predicted/combined_alignments_ids/
mkdir -p fasta
mkdir -p hmm
mkdir -p alignments

for file in *.txt;
do


max_num="0"
outname=`basename $file _combined_list.txt`
line_count=`wc -l $file | cut -d ' ' -f1`

if (( $line_count == 1 ));then

cp ../large_alignments/alignments/$outname.stk ./alignments

continue
fi

echo $outname

> fasta/$outname.fa
while read line; 
do 

esl-reformat fasta ../large_alignments/alignments/$line.stk >> fasta/$outname.fa

current_num=`esl-alistat ../large_alignments/alignments/$line.stk | grep "Number of sequences" | cut -d ' ' -f 4`

if(( $current_num > $max_num ));
then

max_seq="$line.stk"
max_num="$current_num"
fi

done < $file

hmmbuild hmm/$outname.hmm ../large_alignments/alignments/$max_seq

hmmalign --informat fasta hmm/$outname.hmm fasta/$outname.fa | esl-alimask -g --gapthresh 0.8 -p --pfract 0.5 --pthresh 0.5 - | esl-alimanip   --lnfract 0.6 --lxfract 1.4 --lmin 50 --lmax 500 --detrunc 50 - > alignments/$outname.stk

done


```

Download the alignment files from the server (biochemcompute.uod.otago.ac.nz) to  *~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments/* 

`scp bioc:./phd/RNASeq/srnas/predicted/combined_alignments_ids/alignments/* ./`

```{bash get_distribution_of_seqs_per_alignment, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments_rnaalifold

cd ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments_rnaalifold

> ../seqs_per_alignment.txt

for file in *.stk;
do

ID=`basename $file .stk | cut -d "_" -f2-`

echo $ID

seqcount=`grep "/" $file | cut -d '/' -f1  | rev | cut -d '|' -f1 | rev | sort | uniq| wc -l`

echo "$seqcount $ID" >> ../seqs_per_alignment.txt

done

```

#Score sRNAs {#score_rnas}

***

**Scripts involved for scoring the sRNAs**

-   [*run_RNAcode.sh*](#section-run_rnacode.sh)


-   [*run_RNAAlifold.sh*](#section-run_rnaalifold.sh)

    -   Produces the alignment file with predicted secondary structure included (useful for later steps) and a visualisation of the predicted secondary structure.
    
-   [*run_Alifold.sh*](#section-run_alifold.sh) 

    -   Compares the predicted secondary structure to a series of alignments from randomly shuffled sequence to give an idea of the how likley it is that the given secondary structure  could occur by chance (in the form of a z-score of the MFE).

-   [*run_R-scape.sh*](#section-run_r-scape.sh) 

    - Looks for coovaritation in the alignments.

-   [*run_rmfamscan.sh*](#section-run_rmfamscan.sh) *-e* *\<file extentsion\>* *-a*
    
    - Looks for motifs in the sRNAs

***

##RNACode {#check_negaitve_controls}

Done to check for coding potential. 

-   Run on server (*biochemcompute.uod.otago.ac.nz*)

###Summary (RNACode)

RNACode checks for protein coding sequence

`cd ~/phd/RNASeq/srnas/predicted/combined_alignments_ids`

`run_RNAcode.sh`

```{bash rnacode_summary, eval=F}
#done on server from ~/phd/RNASeq/srna_seqs/version_1/${group}/combined_alignments_ids/rnacode_out/

group="predicted"
> ../${group}.rnacode;
for file in *.rnacode;
do  
  ID=`basename $file .rnacode`; 
  cat $file | sed -e "s/$/\t$ID/"  >> ../${group}.rnacode;  
done

```

`cd ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments`

`scp bioc:./phd/RNASeq/srnas/predicted/combined_alignments_ids/predicted.rnacode ./`

-   formatting for R

    -   `cat negative_control.rnacode | sed 's/N/\tN/g' | grep -v "HSS" | grep -v "====" | grep -v "alignment(s) scored in" | grep -v "Delta" > tmp.rnacode`

    -   `cat predicted.rnacode | sed 's/N/\tN/g' | grep -v "HSS" | grep -v "====" | grep -v "alignment(s) scored in" | grep -v "Delta" > tmp.rnacode`

    -   `cat positive_control.rnacode | sed 's/N/\tN/g' | grep -v "HSS" | grep -v "====" | grep -v "alignment(s) scored in" | grep -v "Delta" > tmp.rnacode`

###protein_coding_filter



```{r protein_coding_filter, eval=F}
ncDat <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/tmp.rnacode",
                    col.names = c("hss.id", "frame", "length", "from", "to", "seq.name", "start", "end", "score", "p.value", "srna"), fill = T)
ncDat <- ncDat %>% mutate(p.value = as.numeric(as.character(p.value)),
                          length = as.numeric(as.character(length)))
ncDat <- ncDat %>% filter(grepl(pattern = "alignments", hss.id) == F) %>% 
  filter(p.value < 0.05, length > 16)
ncRNAcode <- ncDat
save(ncRNAcode, file = "~/bin/r_git/R/r_files/ncRNAcode.Rda")

write.table(x = ncRNAcode %>% select(srna) %>% unique(), file = "~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/remove_RNAcode.txt", quote = F, row.names = F, col.names = F)

predDat <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/tmp.rnacode",
                    col.names = c("hss.id", "frame", "length", "from", "to", "seq.name", "start", "end", "score", "p.value", "srna"), fill = T)
predDat <- predDat %>% mutate(p.value = as.numeric(as.character(p.value)),
                          length = as.numeric(as.character(length)))
predDat <- predDat %>% filter(grepl(pattern = "alignments", hss.id) == F) %>% 
  filter(p.value < 0.05, length > 16)
predRNAcode <- predDat
save(predRNAcode, file = "~/bin/r_git/R/r_files/predRNAcode_v2.Rda")



pcDat <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/tmp.rnacode",
                    col.names = c("hss.id", "frame", "length", "from", "to", "seq.name", "start", "end", "score", "p.value", "srna"), fill = T)
pcDat <- pcDat %>% mutate(p.value = as.numeric(as.character(p.value)),
                          length = as.numeric(as.character(length)))
pcDat <- pcDat %>% filter(grepl(pattern = "alignments", hss.id) == F) %>% 
  filter(p.value < 0.05, length > 16)
pcRNAcode <- pcDat


save(pcRNAcode, file = "~/bin/r_git/R/r_files/pcRNAcode.Rda")
```

-   manual made by adding accessions that I found to definity be matching to something.

-   cat remove_* >> foobar

-   cat foobar | sed 's/alignments_//g' | sort | uniq > remove_ALL.txt

###remove_negative_controls_matching_features

```{bash remove_negative_controls_matching_features, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/
mkdir -p rscape_out/ignore
mkdir -p alifold/ignore
mkdir -p RNAAlifold/ignore
mkdir -p alignments_rnaalifold/ignore

file="remove_MANUAL.txt"
while read line;
do
echo $line

mv rscape_out/*${line}*  rscape_out/ignore/
mv alifold/*${line}*  alifold/ignore/
mv RNAAlifold/*${line}*  RNAAlifold/ignore/
mv alignments_rnaalifold/*${line}*  alignments_rnaalifold/ignore/

grep -v $line query_target_pairs.txt > foobar
mv foobar query_target_pairs.txt

done < $file



file="remove_ALL.txt"
while read line;
do
echo $line

mv alifold/alignments_${line}.stk.alifold  alifold/ignore/


done < $file


```





##Phylogenetic distance 

###Lookup table (query and target)

A lookup table of  query genomes, target contigs and srna IDs was needed in later steps.

```{bash query_target_pairs, eval=F}
#done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments

group="positive_control"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments

> ../query_target_pairs.txt
for file in *.stk; 
do 
  
  echo $file; 
  ID=`echo $file | cut -d '.' -f1,2 | cut -d "_" -f1,2`; 
  ID_2=`echo $file | cut -d '.' -f1,2 `;  
  grep ^"#=GS" $file | sort | uniq | cut -d "/" -f1 | cut -d ' ' -f2 | rev | cut -d '|' -f1 | rev | sed -e "s/$/   $ID   $ID_2/" >> ../query_target_pairs.txt;  
  
done
```

The control groups have had some data combined (or removed) but not from the *query_target_pairs.txt* so a file with a list of IDs to keep is needed.

```{bash keep_list, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold

group="negative_control"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold

> ../${group}_keep_list.txt
for file in *.stk;
do

echo $file | cut -d '_' -f2- | rev | cut -d '.' -f2- | rev >> ../${group}_keep_list.txt

done

```


###Maximum phylogenetic distance 

The file containing the queries, targets and sRNA IDs (along with the same files for the *predicted* and *negative* *control* datasets) and the distance matrix were used to get the maximum phylogenetic distance between species for each sRNA.




```{r dna_dists_setup, eval=F, include=T}
run_all <- F
if(run_all){
dat <- read.table("~/phd/RNASeq/RF00177_rep_MATRIX_all.dists", sep = "", header = F, fill = T, stringsAsFactors = F, as.is = T)

dat <- dat %>% filter(!is.na(V2))


colnames(dat)[1] <- "phylip_id"

"NC_009791." %in% colnames(dat)

colnames(dat) <- c("names", dat$phylip_id)

# rownames(dat) <- colnames(dat)

for(i in 1:nrow(dat)){
  for(j in 2:ncol(dat)){
    # if(dat[i,1] == colnames(dat)[j]){
    #   if(dat[i,j] != 0){
    #     print(paste(i, j))
    #   }
    # }
    if(i + 1 == j){
      print(dat[i,j])
    }
  }
}

meltDat <- melt(dat)

colnames(meltDat) <- c("phylip_id", "query.name", "distance")

load(file = "~/bin/r_git/R/r_files/current_ids.Rda")
current_ids <- current_ids %>% unique()

current_ids <- current_ids %>% separate(col = id, into = c("t1", "t2"), sep = "\\|", remove = F, extra = 'warn') 

current_ids <- current_ids %>% mutate(id = ifelse(is.na(t2), t1, t2)) %>% 
  select(-t1, -t2)


contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("id", "target.genome")

contig_labels <- contig_labels %>% left_join(current_ids, by = "id") %>% select(-b)


colnames(contig_labels) <- c("target.id", "target.genome", "phylip_id")

meltDat <- meltDat %>% left_join(contig_labels, by = 'phylip_id')

colnames(meltDat)[1:2] <- c("target.name", "phylip_id")

colnames(contig_labels) <- c("query.id", "query.genome", "phylip_id")

meltDat <- meltDat %>% left_join(contig_labels, by = 'phylip_id')

ggplot() +
  geom_freqpoly(data = meltDat, aes(x = distance, y = ..count..), binwidth = 0.05)

tmp <- meltDat %>% filter(distance > 0)

ggplot() +
  geom_freqpoly(data = tmp, aes(x = distance, y = ..count..), binwidth = 0.05)

colnames(meltDat)[2] <- c("query.name")


meltDat <- meltDat %>% filter(!is.na(query.genome), !is.na(target.genome))%>% group_by(target.genome, query.genome) %>% arrange(-as.numeric(distance)) %>% mutate(row_num = row_number()) %>% filter(row_num == 1) %>% select(-row_num)

mat <- reshape2::acast(data = meltDat %>% select(target.genome, query.genome, distance), formula = target.genome ~ query.genome)

distanceMat <- as.data.frame(mat)

save(distanceMat, file = "~/phd/RNASeq/distanceMat.Rda")

load("~/phd/RNASeq/distanceMat.Rda")

pairs <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/query_target_pairs.txt")
colnames(pairs) <- c("target.name", "query.genome", "ID")
contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("target.name", "target.genome")
pairs <- pairs %>% left_join(contig_labels, by = 'target.name')

pairs <- pairs %>% select(target.genome, ID) %>% unique()

pairs <- pairs %>% mutate_all(as.character)

# pairs <- pairs %>% filter(target.genome != "GCA_000046845.1", grepl(pattern = "GCA_000046845.1", x = ID) == F,
                          # grepl(pattern = "GCA_000015425.1", x = ID) == F)

srnas <- unique(pairs$ID)
max_val <- 0
max_dists <- data.frame(id = srnas, distance = NA)
counter <- 0


max_dists <- max_dists %>% mutate(complete = ifelse(is.na(distance), F, T))
length(unique(pairs$target.genome))


item <- 132

for(item in 1:nrow(max_dists)){
  printRemaining(i = item, length = nrow(max_dists), increment = 1)
  # counter <- counter + 1
  # if(counter > 5){
  #   break
  # }
  if(max_dists$complete[item] == T){
    print(paste(max_dists$id[item], "already done."))
    next
  }
  max_val <- 0
  # print(as.character(max_dists$id[item]))
  df <- pairs %>% filter(ID == as.character(max_dists$id[item])) %>% unique()
  

  if(nrow(df) == 1){
    max_val <- 0
    max_dists$distance[item] <- max_val
    max_dists$complete[item] <- T
    next
  }
genomes <- df$target.genome
rows <- match(x = genomes, table = rownames(distanceMat))
cols <- match(x = genomes, table = colnames(distanceMat))
rows <- rows[!is.na(rows)]
cols <- cols[!is.na(cols)]

if(length(rows) == 0){
  max_val <- 0
  next
}

if(length(cols) == 0){
  max_val <- 0
  next
}

max_val <- max(c(max(distanceMat[rows, cols]),max_val))

  max_dists$distance[item] <- max_val
  max_dists$complete[item] <- T
}

max_dists_pred <- max_dists
save(max_dists_pred, file = "~/bin/r_git/R/r_files/max_dists_pred.Rda")



pairs <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/query_target_pairs.txt")

colnames(pairs) <- c("target.name", "ID", "ID2")

pairs <- pairs %>% left_join(contig_labels, by = "target.name")

pairs <- pairs %>% mutate_all(as.character)

srnas <- unique(pairs$ID)
max_val <- 0
max_dists <- data.frame(id = srnas, distance = NA)
counter <- 0


max_dists <- max_dists %>% mutate(complete = ifelse(is.na(distance), F, T))
length(unique(dat$target.genome))


item <- 1

for(item in 1:nrow(max_dists)){
  printRemaining(i = item, length = nrow(max_dists), increment = 1)
  # counter <- counter + 1
  # if(counter > 5){
  #   break
  # }
  if(max_dists$complete[item] == T){
    print(paste(max_dists$id[item], "already done."))
    next
  }
  max_val <- 0
  # print(as.character(max_dists$id[item]))
  df <- pairs %>% filter(ID == as.character(max_dists$id[item])) %>% unique()
  

  if(nrow(df) == 1){
    max_val <- 0
    max_dists$distance[item] <- max_val
    max_dists$complete[item] <- T
    next
  }
genomes <- df$target.genome
rows <- match(x = genomes, table = rownames(distanceMat))
cols <- match(x = genomes, table = colnames(distanceMat))
rows <- rows[!is.na(rows)]
cols <- cols[!is.na(cols)]

max_val <- max(c(max(distanceMat[rows, cols]),max_val))

  max_dists$distance[item] <- max_val
  max_dists$complete[item] <- T
}

max_dists_pc <- max_dists
save(max_dists_pc, file = "~/bin/r_git/R/r_files/max_dists_pc.Rda")




pairs <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/query_target_pairs.txt")
colnames(pairs) <- c("target.name", "query.genome", "ID")
contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("target.name", "target.genome")
pairs <- pairs %>% left_join(contig_labels, by = 'target.name')

pairs <- pairs %>% select(target.genome, ID) %>% unique()

pairs <- pairs %>% mutate_all(as.character)

srnas <- unique(pairs$ID)
max_val <- 0
max_dists <- data.frame(id = srnas, distance = NA)
counter <- 0


max_dists <- max_dists %>% mutate(complete = ifelse(is.na(distance), F, T))
length(unique(pairs$target.genome))


item <- 1

for(item in 1:nrow(max_dists)){
  printRemaining(i = item, length = nrow(max_dists), increment = 1)
  # counter <- counter + 1
  # if(counter > 5){
  #   break
  # }
  if(max_dists$complete[item] == T){
    print(paste(max_dists$id[item], "already done."))
    next
  }
  max_val <- 0
  # print(as.character(max_dists$id[item]))
  df <- pairs %>% filter(ID == as.character(max_dists$id[item])) %>% unique()
  

  if(nrow(df) == 1){
    max_val <- 0
    max_dists$distance[item] <- max_val
    max_dists$complete[item] <- T
    next
  }
genomes <- df$target.genome
rows <- match(x = genomes, table = rownames(distanceMat))
cols <- match(x = genomes, table = colnames(distanceMat))
rows <- rows[!is.na(rows)]
cols <- cols[!is.na(cols)]

max_val <- max(c(max(distanceMat[rows, cols]),max_val))

  max_dists$distance[item] <- max_val
  max_dists$complete[item] <- T
}

max_dists_nc <- max_dists
save(max_dists_nc, file = "~/bin/r_git/R/r_files/max_dists_nc.Rda")




pairs <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/old/query_target_pairs_nr.txt")
colnames(pairs) <- c("target.name", "query.genome", "ID")
contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("target.name", "target.genome")
pairs <- pairs %>% left_join(contig_labels, by = 'target.name')

pairs <- pairs %>% select(target.genome, ID) %>% unique()

pairs <- pairs %>% mutate_all(as.character)

srnas <- unique(pairs$ID)
max_val <- 0
max_dists <- data.frame(id = srnas, distance = NA)
counter <- 0


max_dists <- max_dists %>% mutate(complete = ifelse(is.na(distance), F, T))
length(unique(pairs$target.genome))


item <- 1

for(item in 1:nrow(max_dists)){
  printRemaining(i = item, length = nrow(max_dists), increment = 1)
  # counter <- counter + 1
  # if(counter > 5){
  #   break
  # }
  if(max_dists$complete[item] == T){
    print(paste(max_dists$id[item], "already done."))
    next
  }
  max_val <- 0
  # print(as.character(max_dists$id[item]))
  df <- pairs %>% filter(ID == as.character(max_dists$id[item])) %>% unique()
  

  if(nrow(df) == 1){
    max_val <- 0
    max_dists$distance[item] <- max_val
    max_dists$complete[item] <- T
    next
  }
genomes <- df$target.genome
rows <- match(x = genomes, table = rownames(distanceMat))
cols <- match(x = genomes, table = colnames(distanceMat))
rows <- rows[!is.na(rows)]
cols <- cols[!is.na(cols)]

max_val <- max(c(max(distanceMat[rows, cols]),max_val))

  max_dists$distance[item] <- max_val
  max_dists$complete[item] <- T
}

max_dists_pred_nr <- max_dists
save(max_dists_pred_nr, file = "~/bin/r_git/R/r_files/max_dists_pred_nr.Rda")

}
```

```{r dna_dists, eval=F, include=F}
run_all <- F
load("~/bin/r_git/R/r_files/max_dists_pred.Rda")
# load("~/bin/r_git/R/r_files/max_dists_pred_nr.Rda")
load("~/bin/r_git/R/r_files/max_dists_pc.Rda")
load("~/bin/r_git/R/r_files/max_dists_nc.Rda")



max_dists_pred <- max_dists_pred %>% mutate(group = "Predicted")
# max_dists_pred_nr <- max_dists_pred_nr %>% mutate(group = "Predicted NR")
max_dists_pc <- max_dists_pc %>% mutate(group = "Positive Control")
max_dists_nc <- max_dists_nc %>% mutate(group = "Negative Control")


dists <- max_dists_pred %>% bind_rows(max_dists_pc, max_dists_nc) %>% dplyr::rename(max_dist = distance) %>% filter(max_dist != 0)


distsCumulativeCount <- cumulativeCounts(dists = dists, smooth = F)

p <- ggplot() +
  geom_line(data = distsCumulativeCount, aes(x= max_dist, y = cumulative_prop, group = group, colour = group))
p
if(run_all){
ggsave(filename = "~/phd/RNASeq/figures/max_conservation_distance_4.svg", plot = p)
}
```

```{r large_tree, eval=F, include=F}
  # tree <- read.tree("~/bin/r_git/R/r_files/large_labelled_tree.tree")
  tree <- read.tree("~/bin/r_git/R/r_files/all_taxa.tree")
  p <-ggtree(tree) + 
  geom_tiplab() +
  xlim(0,0.8)
  p
  #ggsave(filename = "~/phd/RNASeq/figures/large_tree.svg", device = 'svg', width = 50, height = 50, limitsize = FALSE)
```





##RNAAlifold{#rnaalifold}

RNAAlifold calculates the best secondary structure, the MFE of that strucutre and gives a covariation score. The program is run using [*run_RNAAlifold.sh*](#section-run_rnaalifold.sh) in *~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/*

`cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/`

`run_RNAAlifold.sh`

This loops over all of the alignments (stockholm format) in the *./alignments/* folder and checks the size of the alignments (removing poor alignments and alignmnets > 500 nt). The file format is changed to clustal and runs RNAAlifold. The output alignment (alignment with secondary structure and scores) and a post-script format visual secondary structure are moved to folders. 


###Summary (RNAAlifold)

The alifold score is made up of the combination of the MFE of the structure and the covariation score. Each of these scores are written to files for each of the groups.

```{bash rnaalifold_summary, eval=F}
#done from ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/RNAALifold

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/RNAALifold
> ../${group}_alifold_score.txt;
> ../${group}_mfe.txt;
> ../${group}_alifold_covariation.txt; 

for file in *.rnaalifold;
do   
  
  if [ $file == *"\.stk\.stk\.rnaalifold" ]; then 
    ID=`basename $file .stk.stk.rnaalifold`; 
  else 
    ID=`basename $file .stk.rnaalifold`; 
  fi; 
  grep "=" $file | rev | cut -d "(" -f1 | cut -d '{' -f1 | rev | cut -d "=" -f1 | sed -e "s/$/   $ID/"  >> ../${group}_alifold_score.txt; 
  grep "=" $file | rev | cut -d "(" -f1 | grep -v '{'| rev | cut -d "=" -f2 | cut -d "+" -f1 | sed -e "s/$/   $ID/" >> ../${group}_mfe.txt; 

  grep "=" $file | rev | cut -d "(" -f1 | grep -v '{' | rev | cut -d "=" -f2 | cut -d "+" -f2 | tr -d ")" | sed -e "s/$/   $ID/" >> ../${group}_alifold_covariation.txt; 

done
```

-   Positive control set has different naming and needs the files moved with another step

####positive_control_alignments

```{bash move_positive_control_alignments, eval=F}
for file in alignments_R*;
do
  outname=`basename $file .stk.stk`
  mv $file alignments_rnaalifold/$outname.stk
done
```

-   Negative control set has different naming and needs the files moved with another step

####negative_control_alignments

```{bash move_negative_control_alignments, eval=F}
for file in alignments_a*;
do
tmpname=`echo $file | cut -d '_' -f2,3,4,5`
  outname=`basename $tmpname .stk.stk`
  mv $file alignments_rnaalifold/$outname.stk
done
```


##Rscape

Rscape idenitfies covariation, looking for paris of columns in an alignment that co-vary. The program is run using [*run_R-scape.sh*](#section-run_r-scape.sh) in *~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/*

`cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/`

`run_R-scape.sh`

Like the [RNAAlifold](#section-rnaalifold) loop, this checks each alignment and runs the R-scape program. The alignments used are the output alignments from [RNAAlifold](#section-rnaalifold).

###Summary (R-scape)

All of the covariation scores are written to files for each of the groups.

```{bash rscape_summary,eval=F}
#done from ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/rscape_out/

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/rscape_out/
> ../${group}.rscape.cov;
for file in *.sorted.cov;
do  
  tmpname=`echo $file | cut -d '_' -f2,3,4`; 
  ID=`basename $tmpname .stk.stk`; 
  cat $file | sed -e "s/$/	$ID/"  >> ../${group}.rscape.cov;  
done

```


##Alifoldz


Alifoldz takes the alifold score from RNAAlifold and shuffles the sequence and calculates the same alifold score ont he shuffled sequences. This allows a z-score of the alifold score to be calculated and used. The program is run using [*run_Alifold.sh*](#section-run_alifold.sh) in *~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/*

`cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/`

`run_Alifold.sh`

Like the [RNAAlifold](#section-rnaalifold) loop, this checks each alignment and runs the Alifoldz program. The alignments used are the output alignments from [RNAAlifold](#section-rnaalifold).


###Summary (Alifoldz)

All of the z-scores are written to files for each of the groups.

```{bash alifold_summary, eval=F}
#done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alifold 
group="negative_control"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alifold 
> ../${group}.alifold
for file in *.alifold;  
do 

  ID=`echo $file | cut -d '.' -f1,2`; 
  grep -v "#" $file | grep -v "From" | grep -v "\-\-\-" | tr -s ' '  | sed -e "s/$/   $ID/" >> ../${group}.alifold
  
done

```

##rmFam

Searches for RNA motifs in alignments.

`cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold`

`run_rmfamscan.sh`


###rmfamscan_summary

```{bash rmfamscan_summary, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/rmfam_gff_files

group='predicted'
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold/rmfam_gff_files
> ../../${group}.rmfam;  
for file in *.gff;    
do    
tmpname=`echo $file | sed 's/\.clustal//g'`;  
ID=`basename $tmpname .stk.stk.gff`;  
grep -v "#" $file | sed -e "s/$/   $ID/" >> ../../${group}.rmfam;  
done

```


##GC content

```{bash gc_content_simple, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/

> ./${group}_gc_all.txt

for file in ./alignments_rnaalifold/*;
do

ID=`basename $file | cut -d '.' -f1,2 | cut -d '_' -f2-`; 

echo $ID

esl-reformat fasta ${file}  | grep -v ^">" | grep -o . | sort | uniq -c | sed -e "s/$/ $ID/" >> ${group}_gc_all.txt


done


```


###Genome GC percentage

Run on server (*biochemcompute.uod.otago.ac.nz*):

```{bash gc_content_genome, eval=F}
##done in ~/phd/RNASeq/representative_genomes/


cd ~/phd/RNASeq/representative_genomes/

> ../gc_genomes.txt

for file in *.fna;
do

ID=`basename $file .fna | cut -d '_' -f1,2`; 

echo $ID

cat ${file}  | grep -v ^">" | grep -o . | sort | uniq -c | sed -e "s/$/ $ID/" >> ../gc_genomes.txt


done


```

`grep "GCA_" gc_genomes.txt > gc_genomes_analysed.txt`


Download to Macbook:

-  `cd ~/phd/RNASeq`

-   `scp bioc:./phd/RNASeq/gc_genomes_analysed.txt ./`


###Reference GC percentage


```{bash get_reference_fasta, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/

> ./${group}_gc_reference.txt

for file in ./alignments_rnaalifold/*;
do

ID=`basename $file | cut -d '.' -f1,2 | cut -d '_' -f2-`; 

echo $ID

cat $file | grep "#=GC RF" | cut -d ' ' -f3-  | tr -d ' ' |  grep -o . | sort | uniq -c | sed -e "s/$/ $ID/" >> ./${group}_gc_reference.txt

done
```

-   GC percentage is calculated from the _rf.fna file using:

    -   sRNAGCPercentage.py -i ${group}_rf.fna -o ${group}_rf.gc

##get RNA labels from Rfam {#get_rna_labels}

```{bash get_rna_labels, eval=F}
> rfam_descriptions.txt
for folder in *_files;
do
outname=`basename $folder _files`
echo $outname
description=`cmfetch  ~/phd/RNASeq/Rfam.cm $outname | grep ^"NAME" | head -n 1 | tr -s ' ' | cut -d ' ' -f2-`

echo "${outname} ${description}" >> rfam_descriptions.txt

done
```

###view_rfam_descriptions


```{r view_rfam_descriptions}
rfam <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/rfam_descriptions.txt", sep = " ")

```



##sRNA_read_depths


###sRNA_read_depths_script


```{bash sRNA_read_depths, eval=F, include=T}
##Done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold
group='predicted'
if [[ $group ==  'positive_control' ]];
then
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/analysed_genomes/alignments
> ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/${group}_read_depths_summary_ALL_reads.txt
else
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold
> ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/${group}_read_depths_summary.txt
fi

#file=alignments_GCA_000006765.1_12.stk
for file in *.stk;
  do
  genome_name=`echo $file | cut -d '_' -f2,3`
  ID=`echo $file | cut -d '_' -f2,3,4 | sed 's/\.stk//g'`
  
  cat $file | grep -v ^"#" | grep "/" | grep -v "//" | cut -d ' ' -f1 > ~/phd/RNASeq/tmp/tmp.txt
  while read line; 
    do
    contig=`echo $line | cut -d '/' -f1 | rev | cut -d '|' -f1 | rev`
    coord=`echo $line | cut -d '/' -f2`
    realstart=`echo $coord | cut -d '-' -f1`
    realstop=`echo $coord | cut -d '-' -f2`
    start=`echo $coord | cut -d '-' -f1`
    stop=`echo $coord | cut -d '-' -f2`    
    #echo $contig
    genome=`grep $contig ~/phd/RNASeq/sequences/contig_ids_accession.lookup | cut -f2`
    genus=`grep $contig ~/phd/RNASeq/contig_descriptions.txt | cut -f2 | cut -d '_' -f1`
#    if [[ $genome != $genome_name ]]; then
#      continue
#    fi
    stats=`esl-seqstat -a ~/phd/RNASeq/sequences/${genome}.fna`
    esl-seqstat -a ~/phd/RNASeq/sequences/${genome}.fna | grep "=" > ~/phd/RNASeq/tmp/tmp.stats
    current_count=0
    while read stat_line;
      do
      chromosome=`echo "$stat_line" | grep $contig | wc -l | cut -d ' ' -f8`
      if (( $chromosome > 0 ));
        then
        tmpstart=$(($start + $current_count))
        tmpstop=$(($stop + $current_count))
        if (( $tmpstart < $tmpstop  )); then
          start=$tmpstart
          stop=$tmpstop
        else
          stop=$tmpstart
          start=$tmpstop
        fi
        
        if [[ ! -d ~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files ]];
          then
          echo "Genome: ${genome} has no plot files"
          continue
        fi
        #echo "~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files $start $stop"
        > ~/phd/RNASeq/tmp/test.plot
        counter="1"
        for plotfile in ~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files/*.plot;
          do
          if [[ $plotfile == *"ncRNA"* ]]; then
            continue
          elif [[ $plotfile == *"rev"* ]]; then
            continue
          elif [[ $plotfile == *"fwd"* ]]; then
            continue            
          fi
          echo "$plotfile $genus $genome"
          sed -n "${start},${stop}{p;${stop}q;}"  $plotfile > ~/phd/RNASeq/tmp/tmp.plot
          if [[  $counter ==  "1" ]];
          then
            cat ~/phd/RNASeq/tmp/tmp.plot > ~/phd/RNASeq/tmp/test.plot
            counter="2"
          else
            cat ~/phd/RNASeq/tmp/test.plot > ~/phd/RNASeq/tmp/tmp2.plot 
            paste ~/phd/RNASeq/tmp/tmp2.plot ~/phd/RNASeq/tmp/tmp.plot > ~/phd/RNASeq/tmp/test.plot
          fi
        done
        #cp test.plot ~/phd/RNASeq/tmp
        summarise_sRNA_read_depths.R ~/phd/RNASeq/tmp/test.plot
        cat ~/phd/RNASeq/tmp/test.values | sed -e "s/$/ $ID $genus $genome_name $genome $contig $realstart $realstop $start $stop/" >> ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/${group}_read_depths_summary.txt
      else
        length=`echo $stat_line | cut -d ' ' -f3`
        current_count=$(($current_count + $length))
      fi
      
    done < ~/phd/RNASeq/tmp/tmp.stats
  done < ~/phd/RNASeq/tmp/tmp.txt
done
```

###sRNA_read_depths_predicted


-   Get read depths for the originally predicted sRNAs

```{bash sRNA_read_depths_predicted, eval=F, include=T}
##done in ~/phd/RNASeq/genera/
#${genera}/${accession}.data

#cd ~/phd/RNASeq/genera/
#> ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_read_depths_summary_reads_from_new_calls.txt
#for genera in *;
#do
genera="Lysobacter"
echo $genera

> ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_read_depths_summary_reads_${genera}.txt


cd ~/phd/RNASeq/genera/${genera}/

for folder in *.data;
do
  accession=`basename $folder .data`
  cd ~/phd/RNASeq/genera/${genera}/${accession}.data
  echo $accession
  
  while read line;
  do
    #echo $line
    contig=`echo $line | cut -d ' ' -f1`
    if [[ $contig == "sequence"  ]]; then
      continue
    fi
    #coord=`echo $line | cut -d '/' -f2`
    realstart=`echo $line | cut -d ' ' -f3`
    realstop=`echo $line | cut -d ' ' -f4`
    start=`echo $line | cut -d ' ' -f3`
    stop=`echo $line | cut -d ' ' -f4` 
    ID=`echo $line | cut -d ' ' -f13`
    genome=`echo $ID | cut -d "_" -f1,2`
    echo "${genome} ${contig} (${ID}): ${realstart}-${realstop}"
    stats=`esl-seqstat -a ~/phd/RNASeq/sequences/${genome}.fna`
    esl-seqstat -a ~/phd/RNASeq/sequences/${genome}.fna | grep "=" > ~/phd/RNASeq/tmp/${genera}_tmp.stats
    current_count=0
    while read stat_line;
      do
      chromosome=`echo "$stat_line" | grep $contig | wc -l | cut -d ' ' -f8`
      if (( $chromosome > 0 ));
        then
        tmpstart=$(($start + $current_count))
        tmpstop=$(($stop + $current_count))
        if (( $tmpstart < $tmpstop  )); then
          start=$tmpstart
          stop=$tmpstop
        else
          stop=$tmpstart
          start=$tmpstop
        fi
        
        if [[ ! -d ~/phd/RNASeq/genera/${genera}/${genome}.data/plot_files ]];
          then
          echo "Genome: ${genome} has no plot files"
          continue
        fi
        #echo "~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files $start $stop"
        > ~/phd/RNASeq/tmp/test.plot
        counter="1"
        for plotfile in ~/phd/RNASeq/genera/${genera}/${genome}.data/plot_files/*.plot;
          do
          if [[ $plotfile == *"ncRNA"* ]]; then
            continue
          elif [[ $plotfile == *"rev"* ]]; then
            continue
          elif [[ $plotfile == *"fwd"* ]]; then
            continue            
          fi
          echo "$plotfile $genera $genome"
          sed -n "${start},${stop}{p;${stop}q;}"  $plotfile > ~/phd/RNASeq/tmp/${genera}_tmp.plot
          if [[  $counter ==  "1" ]];
          then
            cat ~/phd/RNASeq/tmp/${genera}_tmp.plot > ~/phd/RNASeq/tmp/${genera}_test.plot
            counter="2"
          else
            cat ~/phd/RNASeq/tmp/${genera}_test.plot > ~/phd/RNASeq/tmp/${genera}_tmp2.plot 
            paste ~/phd/RNASeq/tmp/${genera}_tmp2.plot ~/phd/RNASeq/tmp/${genera}_tmp.plot > ~/phd/RNASeq/tmp/${genera}_test.plot
          fi
        done
        #cp test.plot ~/phd/RNASeq/tmp
        summarise_sRNA_read_depths.R ~/phd/RNASeq/tmp/${genera}_test.plot
        cat ~/phd/RNASeq/tmp/test.values | sed -e "s/$/ $ID $genera $genome_name $genome $contig $realstart $realstop $start $stop/" >> ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_read_depths_summary_reads_${genera}.txt
      else
        length=`echo $stat_line | cut -d ' ' -f3`
        current_count=$(($current_count + $length))
      fi
      
    done < ~/phd/RNASeq/tmp/${genera}_tmp.stats
  done < ${accession}_new_calls.txt
  
done

#done

```

###combine_predicted_read_depths


```{bash combine_predicted_read_depths, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments

cd ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments
> predicted_read_depths_summary_new_calls.txt
cat predicted_read_depths_summary_reads_* | cut -d ' ' -f1,2,3 >> predicted_read_depths_summary_new_calls.txt


```


###srna_read_depths_new_calls_pc


```{bash srna_read_depths_new_calls_pc, eval = F}

genera="Escherichia"
echo $genera



cd ~/phd/RNASeq/genera/${genera}/

for folder in *.data;
do
  accession=`basename $folder .data`
  cd ~/phd/RNASeq/genera/${genera}/${accession}.data
  echo $accession
  
  cp gff_files/${accession}.gff ./
  
  cmscanToGffWrapper.R -f ${accession}.tblout -g ${accession}
  
  mv *.gff gff_files
  
  combine_gff_files.R -f ./gff_files/ -o ${accession}
  
done

```

###match_pc_pred_ids


```{bash match_pc_pred_ids, eval=F}
##done in ~/phd/RNASeq/genera

cd ~/phd/RNASeq/genera
cat */*/*_new_calls.txt | cut -f12- | grep "RF0" > ../new_calls/all_new_calls.txt

##done in ~/phd/RNASeq/genera
cd ~/phd/RNASeq/new_calls

while read line;
do
#echo $line


pcids=`echo $line | rev | cut -d ' ' -f2- | rev`
predid=`echo $line | rev | cut -d ' ' -f1 | rev`

echo $pcids | tr , '\n' | sed -e "s/$/   $predid/" | grep -v "=" | grep "RF" | sort | uniq >> ~/phd/RNASeq/pc_pred_ids.txt

done < ../new_calls/all_new_calls.txt

```



###summarise_sRNA_read_depths.R




```{r summarise_sRNA_read_depths.R, eval=F, include=T}
#!/usr/bin/env Rscript
library(dplyr, quietly = T, warn.conflicts = F)
dat <- read.table("~/phd/RNASeq/tmp/test.plot")

valuesDat <- dat %>%
  summarise_all(list(max)) %>% as.matrix() %>% t()

values <- valuesDat[,1]
outDat <- data.frame(mean = mean(values), max  = max(values))

write.table(x = outDat, file = "~/phd/RNASeq/tmp/test.values", row.names = F, col.names = F, quote = F)
```

##sRNA counts

```{bash srna_counts, eval=F}
##done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold


> ../${group}_snra_counts.txt

for file in *.stk;
do
ID=`basename $file | cut -d '.' -f1,2 | cut -d '_' -f2-`; 

echo $ID

esl-alistat $file  | grep "Number of sequences" | rev | cut -d ' ' -f1 | rev | sed -e "s/$/ $ID/" >> ../${group}_snra_counts.txt

done

```


Done on server

```{bash redundant_counts, eval=F}
##done in ~/phd/RNASeq/srnas/${group}/combined_alignments_ids

group="predicted"
cd ~/phd/RNASeq/srnas/${group}/combined_alignments_ids

wc -l * | grep "GCA" | cut -d '_' -f1,2,3 > ${group}_counts.txt

```

`cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments`

`scp bioc:~/phd/RNASeq/srnas/negative_control/combined_alignments_ids/negative_control_counts.txt ./`


##Images


```{bash, eval=F}

cd -p ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments_rnaalifold/

mkdir -p post_script
mkdir -p RNAfold

for file in *.stk;
do
ID=`echo $file | cut -d '_' -f2- | sed 's/\.stk//g'`

echo $ID

esl-reformat fasta $file  | RNAfold  > ./RNAfold/${ID}.rnafold
move_file='T'
for figure in *.ps;
do

if [[ $move_file == 'T' ]]; then
mv $figure ./post_script/${ID}.ps
move_file='F'
else

continue

fi
done
done

```

#Process Scores
##summary_results 

```{r summary_setup, include=F}

```

```{bash number_of_sRNAs_predicted, eval=F}
##done in ~/phd/RNASeq/genera

cd ~/phd/RNASeq/genera

cat */*/*_new_calls.txt |  grep "_sra_calls.gff" | wc -l ##rnas
ls */*/*_new_calls.txt | wc -l ##genomes

ls | wc -l ##genera

ls */*/plot_files/*_ncRNA.plot | wc -l ##experiments


cd ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments_rnaalifold

> ../predicted_ids.txt
ls alignments_GCA_* | sed 's/alignments_//g' |  sed 's/.stk//g' >> ../predicted_ids.txt

wc -l ../predicted_ids.txt



cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/alignments_rnaalifold

> ../predicted_ids.txt
ls alignments_GCA_* | sed 's/alignments_//g' |  sed 's/.stk//g' >> ../negative_control_ids.txt

wc -l ../negative_control_ids.txt

```

```{r number_of_sRNAs_predicted_r, eval=F}
load("~/bin/r_git/R/r_files/predDat.Rda")

remaining_pred_srnas <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_ids.txt", sep = "\t", fill =  T)

remaining_pred_srnas <- remaining_pred_srnas %>% dplyr::rename(ID = V1) %>% mutate(keep =T)

new_calls <- read.table("~/phd/RNASeq/genera/new_calls_simple.txt", sep = "\t", fill =  T)
new_calls <- new_calls %>% filter(V5 != "", V5 != "id")
colnames(new_calls) <- c("contig", "start", "stop", "new_feature", "ID")
newCalls <- new_calls %>% select(ID, new_feature)

predDat <- predDat %>% left_join(newCalls, by = "ID") %>% full_join(remaining_pred_srnas, by = "ID")

predDat <- predDat %>% filter(!is.na(keep))

table(predDat$new_feature)

```

##conservation_distance 


-   Analysis of the evolutionary distance of all the sequences in a given sRNA

    -   the maximum distance between sequences in an sRNA was selected 


```{r conservation_distance_might_not_be_needed, eval=F}
load( file = "~/bin/r_git/R/r_files/max_dists_pred.Rda")
load(file = "~/bin/r_git/R/r_files/max_dists_pc.Rda")
load(file = "~/bin/r_git/R/r_files/max_dists_nc.Rda")

pc_keep <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_keep_list.txt")

pc_keep <- pc_keep %>% dplyr::rename(ID = V1) %>% mutate(keep = T)

max_dists_pc <- max_dists_pc %>% separate(col = id, into = c("ID", "t2"), sep = "\\.")  %>% select(-t2)  %>% left_join(pc_keep, by = "ID") %>% filter(!is.na(keep)) %>% select(-keep)

nc_keep <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_keep_list.txt")

nc_keep <- nc_keep %>% dplyr::rename(ID = V1) %>% mutate(keep = T)

max_dists_nc <- max_dists_nc %>% separate(col = id, into = c("t1", "ID"), sep = "_", extra = "merge")  %>% select(-t1)  %>% left_join(nc_keep, by = "ID") %>% filter(!is.na(keep)) %>% select(-keep)

known_predicted <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/known_predicted_models_list.txt")

known_predicted <- known_predicted %>% select(V2) %>% unique() %>% mutate(pred = T) %>% dplyr::rename(ID = V2)

predKnownDists <-  max_dists_pc  %>% left_join(known_predicted, by = "ID") %>% filter(!is.na(pred)) %>% select(-pred) %>% mutate(group = "Predicted Known") 

not_nc <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/not_negative_control_ids.txt")

not_nc <- not_nc %>% mutate(remove = T) %>% dplyr::rename(ID = V1)

max_dists_nc <- max_dists_nc %>% left_join(not_nc, by = "ID") %>%  filter(is.na(remove)) %>% select(-remove)

max_dists_pred <- max_dists_pred %>% mutate(group = "Predicted")
max_dists_pc <- max_dists_pc %>% dplyr::rename(id = ID) %>% mutate(group = "Positive Control")
max_dists_nc <- max_dists_nc %>% dplyr::rename(id = ID) %>% mutate(group = "Negative Control")
predKnownDists <- predKnownDists %>% dplyr::rename(id = ID)

dists <- max_dists_pred %>% bind_rows(max_dists_pc, max_dists_nc, predKnownDists) %>% dplyr::rename(max_dist = distance) %>% filter(max_dist > 0)




```

###distance_check


```{r distance_check, eval = F}
load( file = "~/bin/r_git/R/r_files/max_dists_pred.Rda")
load(file = "~/bin/r_git/R/r_files/max_dists_pc.Rda")
load(file = "~/bin/r_git/R/r_files/max_dists_nc.Rda")

pc_keep <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_keep_list.txt")

pc_keep <- pc_keep %>% dplyr::rename(ID = V1) %>% mutate(keep = T)

max_dists_pc <- max_dists_pc %>% separate(col = id, into = c("ID", "t2"), sep = "\\.")  %>% select(-t2)  %>% left_join(pc_keep, by = "ID") %>% filter(!is.na(keep)) %>% select(-keep)

nc_keep <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_keep_list.txt")

nc_keep <- nc_keep %>% dplyr::rename(ID = V1) %>% mutate(keep = T)

max_dists_nc <- max_dists_nc %>% separate(col = id, into = c("t1", "ID"), sep = "_", extra = "merge")  %>% select(-t1)  %>% left_join(nc_keep, by = "ID") %>% filter(!is.na(keep)) %>% select(-keep)

not_nc <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/not_negative_control_ids.txt")

not_nc <- not_nc %>% mutate(remove = T) %>% dplyr::rename(ID = V1)

max_dists_nc <- max_dists_nc %>% left_join(not_nc, by = "ID") %>%  filter(is.na(remove)) %>% select(-remove)

max_dists_pred <- max_dists_pred %>% mutate(group = "Predicted")
max_dists_pc <- max_dists_pc %>% dplyr::rename(id = ID) %>% mutate(group = "Positive Control")
max_dists_nc <- max_dists_nc %>% dplyr::rename(id = ID) %>% mutate(group = "Negative Control")


dists <- max_dists_pred %>% bind_rows(max_dists_pc, max_dists_nc) %>% dplyr::rename(max_dist = distance) %>% filter(max_dist > 0)

head(dists)

rocData <- dists %>% filter(group != "Predicted") %>% mutate(response = ifelse(group == "Positive Control", 1, 0))

library(ROCR)
data(ROCR.simple)
pred <- prediction( rocData$max_dist, rocData$response)
perf <- performance(pred,"tpr","fpr")
plot(perf)
str(perf)

cutoffs <- data.frame(cut=perf@alpha.values[[1]], fpr=perf@x.values[[1]], 
                      tpr=perf@y.values[[1]])

```

-   Tree generated by taking all_taxa_names.txt (made from an earlier section) and using the commontree section of Taxonomy on ncbi and downloading the phylip tree.

-   mv ~/Downloads/phyliptree.phy all_taxa_family.tree to rename and move out of the downloads folder.

-   subset_taxa.tree made by copy/pasting a subset (of the range of taxa I already have).

-   this is converted into genera_subset.txt with: 

    -   cat subset_taxa.tree | sed 's/(//g' | sed 's/)//g' | cut -d ':' -f1 > genera_subset.txt 
    
    -   further \n\n was removed in bbedit


###predicted_data_upsetr

```{r predicted_data_upsetr_setup, eval=F, include=F}

pairs <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/query_target_pairs.txt")
colnames(pairs) <- c("target.name", "query.genome", "ID")
contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("target.name", "target.genome")
pairs <- pairs %>% left_join(contig_labels, by = 'target.name')

genus_labels <- read.table("~/phd/RNASeq/contig_genus_lables.txt")

colnames(genus_labels) <- c("target.name", "genus")

pairs <- pairs %>% left_join(genus_labels)
repDat <- pairs %>% select(ID, genus) %>% mutate(count = 1)
mat <- reshape2::acast(repDat, formula = ID ~ genus)

upsetDat <- as.data.frame(mat)

upsetDat$names <- row.names(upsetDat)
upsetDat[upsetDat != 0] <- 1

genus_selection <- read.table("~/bin/python_git/python_files/genera_list.txt")

colVals<- match(x = genus_selection$V1, table = colnames(upsetDat))

colVals <- colVals[!is.na(colVals)]

upsetSubsetPredicted <- upsetDat[,colVals]

save(upsetSubsetPredicted, file='~/bin/r_git/R/r_files/upsetSubsetPredicted.Rda')

```


```{r predicted_data_upsetr, eval=T}
load('~/bin/r_git/R/r_files/upsetSubsetPredicted.Rda')

sumsUpset <- colSums(upsetSubsetPredicted)

sumsDat <- data.frame(ID = colnames(upsetSubsetPredicted), sums = sumsUpset)


analysed_genomes <- c("Escherichia", "Shigella", "Salmonella", "Enterobacter", "Klebsiella","Serratia", "Edwardsiella", "Erwinia", "Photorhabdus", "Yersinia", "Alteromonas", "Acinetobacter", "Pseudomonas", "Methylomicrobium", "Stenotrophomonas", "Xanthomonas", "Xylella", "Lysobacter")

cols_order <- match(analysed_genomes, sumsDat$ID)

sumsDat <- sumsDat[cols_order,]

sumsDat$genome_count <- c(6, 3, 5, 4, 3, 3, 1, 1, 2, 5, 4, 4,6, 1, 2, 3, 1, 1)
sumsDat$rnaseq_count <- c(53, 22, 44, 21, 15, 33, 5, 5, 4, 2, 23, 36, 64, 5, 10, 20, 5, 6)

sumsDat <- sumsDat %>% mutate(srnas_genome_adj  = sums/genome_count, 
                              srnas_rnaseq_adj  = sums/rnaseq_count)

ggplot() +
  geom_histogram(data = sumsDat, aes(x = sums), binwidth = 100)

ggplot() +
  geom_point(data  = sumsDat, aes(x = genome_count, y = sums), color = "blue") +
  geom_point(data  = sumsDat, aes(x = rnaseq_count, y = sums), color = "red")

tree_order <- c("Escherichia", "Shigella", "Salmonella", "Enterobacter", "Klebsiella", "Plautia", "Citrobacter","Serratia", "Wigglesworthia", "Buchnera", "Sodalis", "Lonsdalea", "Brenneria", "Dickeya", "Edwardsiella", "Pantoea", "Erwinia", "Proteus", "Providencia", "Xenorhabdus", "Photorhabdus", "Mannheimia", "Aggregatibacter", "Alishewanella", "Actinobacillus", "Yersinia", "Vibrio", "Alteromonas", "Agarivorans", "Pseudoalteromonas", "Moritella", "Shewanella", "Psychrobacter", "Moraxella", "Acinetobacter", "Azotobacter", "Pseudomonas", "Marinobacter", "Methylomicrobium", "Methylomonas", "Cycloclasticus", "Methylococcus", "Francisella", "Pseudoxanthomonas", "Stenotrophomonas", "Xanthomonas", "Xylella", "Lysobacter", "Candidatus")

cols_order <- match(tree_order, colnames(upsetSubsetPredicted))

tmp <- data.frame(tree_order, cols_order)

upsetSubsetPredicted <- upsetSubsetPredicted[,cols_order]


sumsUpset <- rowSums(upsetSubsetPredicted)

sumsDat <- data.frame(ID = row.names(upsetSubsetPredicted), sums = sumsUpset)
upsetSubsetPC <- upsetSubsetPredicted



UpSetR::upset(upsetSubsetPredicted, sets = colnames(upsetSubsetPredicted), mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/upsetr_plot_pred_3.svg",
     width=15,
     height=10,
     pointsize=12)
UpSetR::upset(upsetSubsetPredicted, sets = colnames(upsetSubsetPredicted), mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)

dev.off()
}

```



```{r predicted_data_upsetr_by_category, eval=F}
load('~/bin/r_git/R/r_files/upsetSubsetPredicted.Rda')

load('~/bin/r_git/R/r_files/novel_rufs.Rda')
load('~/bin/r_git/R/r_files/known_rufs.Rda')
load('~/bin/r_git/R/r_files/noise_rufs.Rda')


tree_order <- c("Escherichia", "Shigella", "Salmonella", "Enterobacter", "Klebsiella", "Plautia", "Citrobacter","Serratia", "Wigglesworthia", "Buchnera", "Sodalis", "Lonsdalea", "Brenneria", "Dickeya", "Edwardsiella", "Pantoea", "Erwinia", "Proteus", "Providencia", "Xenorhabdus", "Photorhabdus", "Mannheimia", "Aggregatibacter", "Alishewanella", "Actinobacillus", "Yersinia", "Vibrio", "Alteromonas", "Agarivorans", "Pseudoalteromonas", "Moritella", "Shewanella", "Psychrobacter", "Moraxella", "Acinetobacter", "Azotobacter", "Pseudomonas", "Marinobacter", "Methylomicrobium", "Methylomonas", "Cycloclasticus", "Methylococcus", "Francisella", "Pseudoxanthomonas", "Stenotrophomonas", "Xanthomonas", "Xylella", "Lysobacter", "Candidatus")

cols_order <- match(tree_order, colnames(upsetSubsetPredicted))

tmp <- data.frame(tree_order, cols_order)

upsetSubsetPredicted <- upsetSubsetPredicted[,cols_order]


sumsUpset <- rowSums(upsetSubsetPredicted)

sumsDat <- data.frame(ID = row.names(upsetSubsetPredicted), sums = sumsUpset)


novel_rufs <- novel_rufs %>% select(ID, probability)
known_rufs <- known_rufs %>% select(ID, probability)
noise_rufs <- noise_rufs %>% select(ID, probability)

upsetSubsetPredicted$ID <- rownames(upsetSubsetPredicted)

novel_rufs <- novel_rufs %>% left_join(upsetSubsetPredicted)

ignoreCols <- match(c('ID', 'probability'), colnames(novel_rufs))


# svg(filename="~/phd/RNASeq/figures/upsetr_plot_pred_novel.svg",
#      width=15,
#      height=10,
#      pointsize=12)
UpSetR::upset(novel_rufs[,-ignoreCols], sets = colnames(novel_rufs)[-ignoreCols], mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)
# dev.off()


known_rufs <- known_rufs %>% left_join(upsetSubsetPredicted)
ignoreCols <- match(c('ID', 'probability'), colnames(known_rufs))

sumsUpset <- rowSums(known_rufs[,-ignoreCols])

sumsDat <- data.frame(ID = known_rufs$ID, sums = sumsUpset)



# svg(filename="~/phd/RNASeq/figures/upsetr_plot_pred_known.svg",
#      width=15,
#      height=10,
#      pointsize=12)
UpSetR::upset(known_rufs[,-ignoreCols], sets = colnames(known_rufs)[-ignoreCols], mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)
# dev.off()

noise_rufs <- noise_rufs %>% left_join(upsetSubsetPredicted)

ignoreCols <- match(c('ID', 'probability'), colnames(noise_rufs))


# svg(filename="~/phd/RNASeq/figures/upsetr_plot_pred_noise.svg",
     # width=15,
     # height=10,
     # pointsize=12)
UpSetR::upset(noise_rufs[,-ignoreCols], sets = colnames(noise_rufs)[-ignoreCols], mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)
# dev.off()


```

###pc_data_upsetr


```{r pc_data_upsetr}

pairs <- read.table("~/phd/RNASeq/query_target_pairs_pc.txt")
colnames(pairs) <- c("target.name", "ID")
contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("target.name", "target.genome")
pairs <- pairs %>% left_join(contig_labels, by = 'target.name')

genus_labels <- read.table("~/phd/RNASeq/contig_genus_lables.txt")

colnames(genus_labels) <- c("target.name", "genus")

pairs <- pairs %>% left_join(genus_labels)

pc_keep <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_keep_list.txt")

pc_keep <- pc_keep %>% dplyr::rename(ID = V1) %>% mutate(keep = T)

pairs <- pairs %>% left_join(pc_keep, by = "ID") %>% filter(!is.na(keep)) %>% select(-keep)

repDat <- pairs %>% select(ID, genus) %>% mutate(count = 1)
mat <- reshape2::acast(repDat, formula = ID ~ genus)


upsetDat <- as.data.frame(mat)

upsetDat$names <- row.names(upsetDat)
upsetDat[upsetDat != 0] <- 1

genus_selection <- read.table("~/bin/python_git/python_files/genera_list.txt")

tmp <- genus_selection %>% dplyr::rename(genus = V1) %>% mutate(keep = T)

conitgs_selected <- genus_labels %>% left_join(tmp) %>% 
  filter(!is.na(keep)) %>% select(-keep) %>% left_join(contig_labels) %>% 
  group_by(genus) %>% top_n(n = 1) %>% ungroup() %>% select(target.genome) %>% unique() 

write_file <- F
if(write_file){
write.table(x = conitgs_selected, file = "~/phd/RNASeq/upsetr_genomes_list.txt", row.names = F, col.names = F, quote = F)
}

colVals<- match(x = genus_selection$V1, table = colnames(upsetDat))

colVals <- colVals[!is.na(colVals)]

upsetSubset <- upsetDat[,colVals]

sumsUpset <- rowSums(upsetSubset)

sumsDat <- data.frame(ID = row.names(upsetSubset), sums = sumsUpset)
upsetSubsetPC <- upsetSubset


tree_order <- c("Escherichia", "Shigella", "Salmonella", "Enterobacter", "Klebsiella", "Plautia", "Citrobacter","Serratia", "Wigglesworthia", "Buchnera", "Sodalis", "Lonsdalea", "Brenneria", "Dickeya", "Edwardsiella", "Pantoea", "Erwinia", "Proteus", "Providencia", "Xenorhabdus", "Photorhabdus", "Mannheimia", "Aggregatibacter", "Alishewanella", "Actinobacillus", "Yersinia", "Vibrio", "Alteromonas", "Agarivorans", "Pseudoalteromonas", "Moritella", "Shewanella", "Psychrobacter", "Moraxella", "Acinetobacter", "Azotobacter", "Pseudomonas", "Marinobacter", "Methylomicrobium", "Methylomonas", "Cycloclasticus", "Methylococcus", "Francisella", "Pseudoxanthomonas", "Stenotrophomonas", "Xanthomonas", "Xylella", "Lysobacter", "Candidatus")

cols_order <- match(tree_order, colnames(upsetSubsetPC))

tmp <- data.frame(tree_order, cols_order)

upsetSubsetPC <- upsetSubsetPC[,cols_order]

save(upsetSubsetPC, file= "~/bin/r_git/R/r_files/upsetSubsetPC.Rda")
load("~/bin/r_git/R/r_files/upsetSubsetPC.Rda")



UpSetR::upset(upsetSubsetPC, sets = colnames(upsetSubsetPC), mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/upsetr_plot_pc_3.svg",
     width=15,
     height=10,
     pointsize=12)
UpSetR::upset(upsetSubsetPC, sets = colnames(upsetSubsetPC), mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)

dev.off()
}

```

`cd ~/phd/RNASeq`

`scp upsetr_genomes_list.txt bioc:./phd/RNASeq/`

On server


```{bash, eval=F}
##done in ~/phd/RNASeq
cd ~/phd/RNASeq

> upsetr_genomes.fna

while read line;
do
echo $line

cat ./representative_genomes/${line}*.fna >> upsetr_genomes.fna

done < upsetr_genomes_list.txt

```

On Macbook

`cd ~/phd/RNASeq`

`scp bioc:./phd/RNASeq/upsetr_genomes.fna .`


`cmsearch --cut_ga -o RF00177_upsetr_genomes.out -A RF00177_upster_genomes.stk --rfam -g RF00177.cm upsetr_genomes.fna`

`esl-reformat phylip RF00177_upster_genomes.stk > RF00177_upsetr_genomes.phylip`



##Read Depths

***

###read_depths_setup


```{r read_depths_setup, eval=F, include=T}
ncRDepth <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_read_depths_summary_reads.txt", as.is = T, stringsAsFactors = F)
pcRDepth <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_read_depths_summary.txt", as.is = T, stringsAsFactors = F)
predRDepth <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_read_depths_summary.txt", as.is = T, stringsAsFactors = F)

predRDepthnewcalls <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_read_depths_summary_new_calls.txt", fill = T, as.is = T, stringsAsFactors = F)


predRDepthnewcalls$V2 <- as.numeric(as.character(predRDepthnewcalls$V2))

colnames(predRDepthnewcalls) <- c("mean.val", "max.val", "counts.above.threshold", "srna", "genus")

# predRDepthnewcalls <- predRDepthnewcalls %>% mutate(V4 = as.numeric(as.character(V1))) %>% mutate(V4 = ifelse(V2 > V4, V4, 0.5*V2)) %>% select(V4, V2, V3)

predRDepthnewcalls <- predRDepthnewcalls %>% filter(srna != "") %>% mutate(mean.val = as.numeric(mean.val),
                                                                         max.val = as.numeric(max.val),
                                                                         counts.above.threshold = as.numeric(counts.above.threshold)) %>% 
  select(mean.val, max.val, counts.above.threshold, srna, genus)

pcpredids <- read.table("~/phd/RNASeq/pc_pred_ids.txt", fill = T)



colnames(ncRDepth) <- c("mean.val", "max.val", "srna", "genus", "srna.genome.accession", "target.genome.accession",
                        "target.contig", "target.start", "target.end", "adj.target.start", "adj.target.end")
colnames(pcRDepth) <- c("mean.val", "max.val", "srna", "genus", "srna.genome.accession", "target.genome.accession",
                        "target.contig", "target.start", "target.end", "adj.target.start", "adj.target.end")
colnames(predRDepth) <- c("mean.val", "max.val",  "counts.above.threshold", "srna", "genus", "srna.genome.accession", "target.genome.accession",
                        "target.contig", "target.start", "target.end", "adj.target.start", "adj.target.end")


colnames(pcpredids) <- c("pc.id", "srna")

predRDepth <- predRDepth %>% bind_rows(predRDepthnewcalls) %>% 
  select(-counts.above.threshold)

predRDepthnewcalls <- predRDepthnewcalls %>% left_join(pcpredids, by = "srna")

pcRDepthnewcallsMax <- predRDepthnewcalls %>% filter(!is.na(pc.id)) %>% group_by(pc.id) %>% summarise(max.va.newl = max(max.val))
pcRDepthnewcallsMean <- predRDepthnewcalls %>% filter(!is.na(pc.id)) %>% group_by(pc.id) %>% summarise(mean.val.new = max(mean.val))


pcRDepthnewcalls <- predRDepthnewcalls %>% filter(!is.na(pc.id)) %>% select(-srna)%>% dplyr::rename(srna = pc.id)

pcRDepthnewcalls <- pcRDepthnewcalls %>% select(mean.val, max.val, srna)

pcRDepth <- pcRDepth %>% bind_rows(pcRDepthnewcalls)

not_nc <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/not_negative_control_ids.txt")

not_nc <- not_nc %>% separate(V1, into = c("t1", "id"), extra = 'merge', sep = "_") %>% select(-t1)

ncRDepth <- ncRDepth %>% select(-genus)
pcRDepth <- pcRDepth %>% select(-genus)

save(ncRDepth, file = "~/bin/r_git/R/r_files/ncRDepth.Rda")
save(pcRDepth, file = "~/bin/r_git/R/r_files/pcRDepth.Rda")
save(predRDepth, file = "~/bin/r_git/R/r_files/predRDepth.Rda")


```


```{r read_depths, eval=F, echo =F}
load("~/bin/r_git/R/r_files/ncRDepth.Rda")
load("~/bin/r_git/R/r_files/pcRDepth.Rda")
load("~/bin/r_git/R/r_files/predRDepth.Rda")


# ggplot() +
#   geom_freqpoly(data = pcRDepth, aes(x = mean.val, y = log(..density..)), binwidth = 50) +
#   geom_freqpoly(data = ncRDepth, aes(x = mean.val, y = log(..density..)), binwidth = 50, colour = "blue") +
#   geom_freqpoly(data = predRDepth, aes(x = mean.val, y = log(..density..)), binwidth = 50, colour = "red")

pcRDepth <- pcRDepth %>% mutate(response = 1) %>% filter(max.val > 0)
ncRDepth <- ncRDepth %>% mutate(response = 0)
rocData <- pcRDepth %>% bind_rows(ncRDepth) 

rocDataMaxMax <- rocData %>% group_by(srna, response) %>% summarise(max.max.val = max(max.val))
rocDataMeanSum <- rocData %>% group_by(srna, response) %>% summarise(max.max.val = sum(mean.val))
rocDataMaxSum <- rocData %>% group_by(srna, response) %>% summarise(max.max.val = sum(max.val))



roc.curve(response = rocDataMaxSum$response, predicted = rocDataMaxSum$max.max.val, 
          main="ROC curve for Read Depths")



pcRDepth <- pcRDepth %>% mutate(group = "Positive Control") %>% filter(max.val > 0)
predRDepth <- predRDepth %>% mutate(group = "Predicted") 
ncRDepth <- ncRDepth %>% mutate(group = "Negative Control")

known_predicted <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/known_predicted_models_list.txt")

known_predicted <- known_predicted %>% select(V2) %>% unique() %>% mutate(pred = T) %>% dplyr::rename(srna = V2)

predKnownReadDepth <-  pcRDepth  %>% left_join(known_predicted, by = "srna") %>% filter(!is.na(pred)) %>% select(-pred) %>% mutate(group = "Predicted Known") 


dists <- pcRDepth %>% bind_rows(ncRDepth, predRDepth, predKnownReadDepth) %>% group_by(srna, group) %>% summarise(max_dist = max(max.val))#%>% dplyr::rename(max_dist = distance) %>% filter(max_dist != 0)


distsCumulativeCount <- cumulativeCounts(dists = dists, smooth = F)



predCumulativeCount <- distsCumulativeCount %>% filter(grepl(pattern = "Predicted", x = group)) %>% arrange(-max_dist) %>%
    mutate(cumulativeCount = cumsum(cumulative_prop))

maxVal <- max(predCumulativeCount$cumulativeCount)

predCumulativeCount <- predCumulativeCount %>% mutate(cumulative_prop = cumulativeCount/maxVal) %>% 
  mutate(group = "Predicted") %>% select(group, max_dist, cumulative_prop)

distsCumulativeCount <- distsCumulativeCount %>% filter(grepl(pattern = "Predicted", x = group) == F) %>% bind_rows(predCumulativeCount)



distsCumulativeCount <- distsCumulativeCount %>% dplyr::rename(max_read_counts = max_dist)

p <- ggplot() +
  geom_line(data = distsCumulativeCount, aes(x= max_read_counts, y = cumulative_prop, group = group, colour = group))
p


write_data <- F
if(write_data){
  
  ggsave(filename = "~/phd/RNASeq/figures/max_read_depths.svg", plot = p)

  
svg(filename="~/phd/RNASeq/figures/reads_max.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocDataMaxSum$response, predicted = rocDataMaxSum$max.max.val, 
          main="ROC curve for Read Depths")

dev.off()

svg(filename="~/phd/RNASeq/figures/reads_mean.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocDataMeanSum$response, predicted = rocDataMeanSum$max.max.val, 
          main="ROC curve for Read Depths")

dev.off()

}
```

###read_depths_check


```{r read_depths_check, eval=F}
load("~/bin/r_git/R/r_files/ncRDepth.Rda")
load("~/bin/r_git/R/r_files/pcRDepth.Rda")
load("~/bin/r_git/R/r_files/predRDepth.Rda")

pcRDepth <- pcRDepth %>% mutate(response = 1) %>% filter(max.val > 0)
ncRDepth <- ncRDepth %>% mutate(response = 0)
rocData <- pcRDepth %>% bind_rows(ncRDepth) 

rocData <- rocData %>% group_by(srna, response) %>% summarise(max.max.val = sum(max.val))

pred <- prediction( rocData$max.max.val, rocData$response)
perf <- performance(pred,"tpr","fpr")
plot(perf)
str(perf)

cutoffs <- data.frame(cut=perf@alpha.values[[1]], fpr=perf@x.values[[1]], 
                      tpr=perf@y.values[[1]])

```

##Covariation

-   The files need the ID column to be separated out so these lines need running.

    -   `cat predicted.rscape.cov | sed 's/GC/\tGC/g' > tmp.cov`

    -   `cat negative_control.rscape.cov | sed 's/GC/\tGC/g' > tmp.cov`

    -   `cat positive_control.rscape.cov | sed 's/RF/\tRF/g' > tmp.cov`


###rscape_setup

```{r rscape_setup, eval = F, include=T}
pcCov <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/tmp.cov", sep = "\t", comment.char = "#", as.is = T, header = F, fill = T, col.names = c("V1", "left_pos", "right_pos", "score", "e.value", "substitutions", "V2", "power", "ID"))
ncCov <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/tmp.cov", sep = "\t", comment.char = "#", as.is = T, header = F, fill = T, col.names = c("V1", "left_pos", "right_pos", "score", "e.value", "substitutions", "V2", "power", "ID"))

predCov <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/tmp.cov", sep = "\t", comment.char = "#", as.is = T, header = F, fill = T, col.names = c("V1", "left_pos", "right_pos", "score", "e.value", "substitutions", "V2", "power", "ID"))

#colnames(pcCov) <- c("V1", "left_pos", "right_pos", "score", "e.value", "substitutions", "power")
#colnames(ncCov) <- c("V1", "left_pos", "right_pos", "score", "e.value", "substitutions", "power")

pcCov <- pcCov %>% mutate(ID = ifelse(V1 == "no significant pairs", left_pos, ID))


pcCov$score[pcCov$V1 == "no significant pairs"] <- 0
pcCov$e.value[pcCov$V1 == "no significant pairs"] <- 10
pcCov$power[pcCov$V1 == "no significant pairs"] <- 0
pcCov$substitutions[pcCov$V1 == "no significant pairs"] <- 0

pcCov$left_pos[pcCov$V1 == "no significant pairs"] <- "-"
pcCov$right_pos[pcCov$V1 == "no significant pairs"] <- "-"
pcCov$V1[pcCov$V1 == "no significant pairs"] <- "-"

ncCov <- ncCov %>% mutate(ID = ifelse(V1 == "no significant pairs  ", left_pos, ID))

ncCov$score[ncCov$V1 == "no significant pairs  "] <- 0
ncCov$e.value[ncCov$V1 == "no significant pairs  "] <- 10
ncCov$power[ncCov$V1 == "no significant pairs  "] <- 0
ncCov$substitutions[ncCov$V1 == "no significant pairs  "] <- 0

ncCov$left_pos[ncCov$V1 == "no significant pairs  "] <- "-"
ncCov$right_pos[ncCov$V1 == "no significant pairs  "] <- "-"
ncCov$V1[ncCov$V1 == "no significant pairs  "] <- "-"

predCov <- predCov %>% mutate(ID = ifelse(V1 == "no significant pairs  ", left_pos, ID))


predCov$score[predCov$V1 == "no significant pairs  "] <- 0
predCov$e.value[predCov$V1 == "no significant pairs  "] <- 10
predCov$power[predCov$V1 == "no significant pairs  "] <- 0
predCov$substitutions[predCov$V1 == "no significant pairs  "] <- 0

predCov$left_pos[predCov$V1 == "no significant pairs  "] <- "-"
predCov$right_pos[predCov$V1 == "no significant pairs  "] <- "-"
predCov$V1[predCov$V1 == "no significant pairs  "] <- "-"

# 
# load("~/bin/r_git/R/r_files/ncRNAcode.Rda")
# load("~/bin/r_git/R/r_files/pcRNAcode.Rda")
# load("~/bin/r_git/R/r_files/predRNAcode.Rda")
# 
# ncRNAcode <- ncRNAcode %>% separate(col = srna, into = c("t1", "t2", "t3"), sep = "_", remove = F, extra = 'merge') %>% mutate(ID = paste(t2, t3, sep = "_")) %>% select(-t1, -t2, -t3) %>%  group_by(ID) %>% mutate(counter = row_number()) %>% filter(counter == 1) %>% select(-counter) %>% ungroup()
# 
# pcRNAcode <- pcRNAcode %>% mutate(ID = srna) %>%  group_by(ID) %>% mutate(counter = row_number()) %>% filter(counter == 1) %>% select(-counter) %>% ungroup()
# pcCov <- pcCov %>% separate(col = ID, into = c("t1"), sep = "_", remove = F, extra = 'drop') %>% mutate(ID = t1) %>% select(-t1)
# 
# 
# predRNAcode <- predRNAcode %>% mutate(ID = srna) %>%  group_by(ID) %>% mutate(counter = row_number()) %>% filter(counter == 1) %>% select(-counter) %>% ungroup()
# 
# ncCov <- ncCov %>% left_join(ncRNAcode, by = "ID") 
# pcCov <- pcCov %>% left_join(pcRNAcode, by = "ID") 
# predCov <- predCov %>% left_join(predRNAcode, by = "ID") 
# 
# ncCovRNA <- ncCov %>% filter(is.na(p.value))
# ncCovProtein <- ncCov %>% filter(!is.na(p.value))
# 
# predCovRNA <- predCov %>% filter(is.na(p.value))
# predCovProtein <- predCov %>% filter(!is.na(p.value))
# 
# pcCovRNA <- pcCov %>% filter(is.na(p.value))
# pcCovProtein <- pcCov %>% filter(!is.na(p.value))

pcIDLen <- length(unique(pcCov$ID))
predIDLen <- length(unique(predCov$ID))
ncIDLen <- length(unique(ncCov$ID))

pcCovMean <- pcCov %>% group_by(ID) %>% summarise(mean_score = mean(score))
pcCovCount <- pcCov %>% group_by(ID) %>% summarise(count = n())
pcCovMax <- pcCov %>% group_by(ID) %>% summarise(min_eval = min(e.value))
pcCov <- pcCovMean %>% full_join(pcCovMax, by = "ID") %>% 
  full_join(pcCovCount, by = "ID")

ncCovMean <- ncCov %>% group_by(ID) %>% summarise(mean_score = mean(score))
ncCovCount <- ncCov %>% group_by(ID) %>% summarise(count = n())
ncCovMax <- ncCov %>% group_by(ID) %>% summarise(min_eval = min(e.value))
ncCovRNA <- ncCovMean %>% full_join(ncCovMax, by = "ID") %>% 
  full_join(ncCovCount, by = "ID") %>% filter(!is.na(mean_score))

predCovMean <- predCov %>% group_by(ID) %>% summarise(mean_score = mean(score))
predCovCount <- predCov %>% group_by(ID) %>% summarise(count = n())
predCovMax <- predCov %>% group_by(ID) %>% summarise(min_eval = min(e.value))
predCovRNA <- predCovMean %>% full_join(predCovMax, by = "ID") %>% 
  full_join(predCovCount, by = "ID")


nc_ids <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_alignment_ids.txt")
colnames(nc_ids) <- "ID"

ncCovRNA <- ncCovRNA %>% full_join(nc_ids, by = "ID")
ncCovRNA$mean_score[is.na(ncCovRNA$mean_score)] <- 0
ncCovRNA$min_eval[is.na(ncCovRNA$min_eval)] <- 10
ncCovRNA$count[is.na(ncCovRNA$count)] <- 1

# pc_ids <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_alignment_ids.txt")
# colnames(pc_ids) <- "ID"
# 
# pcCov <- pcCov %>% full_join(pc_ids, by = "ID")
# pcCov$mean_score[is.na(pcCov$mean_score)] <- 0
# pcCov$min_eval[is.na(pcCov$min_eval)] <- 10
# pcCov$count[is.na(pcCov$count)] <- 0

save(pcCov, file = "~/bin/r_git/R/r_files/pcCovariation.Rda")
save(ncCovRNA, file = "~/bin/r_git/R/r_files/ncCovariation.Rda")
save(predCovRNA, file = "~/bin/r_git/R/r_files/predCovariation.Rda")


```

###rscape_check

```{r rscape_check, eval=F, include=T}
load("~/bin/r_git/R/r_files/pcCovariation.Rda")
load("~/bin/r_git/R/r_files/ncCovariation.Rda")


pcCov <- pcCov %>% mutate(response = 1) #%>% filter(mean_score > 0)
ncCovRNA <- ncCovRNA %>% mutate(response = 0) #%>% filter(mean_score > 0)
rocData <- pcCov %>% bind_rows(ncCovRNA) %>% mutate(combined_score = count * mean_score) %>% filter(!is.na(combined_score)) 


pred <- prediction( (rocData$mean_score * rocData$count), rocData$response)
perf <- performance(pred,"tpr","fpr")

dat <- data.frame(fpr = perf@x.values[[1]], tpr = perf@y.values[[1]], cutoff = perf@alpha.values[[1]])

plot(perf)

cutoffs <- data.frame(cut=perf@alpha.values[[1]], fpr=perf@x.values[[1]], 
                      tpr=perf@y.values[[1]])

```

###rscape

```{r rscape, eval = F, echo=F}
load("~/bin/r_git/R/r_files/pcCovariation.Rda")
load("~/bin/r_git/R/r_files/ncCovariation.Rda")
load("~/bin/r_git/R/r_files/predCovariation.Rda")

pcCov <- pcCov %>% mutate(response = 1) 
ncCovRNA <- ncCovRNA %>% mutate(response = 0)
rocData <- pcCov %>% bind_rows(ncCovRNA) %>% mutate(combined_score = count * mean_score) %>% filter(!is.na(combined_score))  #%>%  filter(mean_score > 0)
roc.curve(response = rocData$response, predicted = rocData$min_eval, 
          main="ROC curve for Covariation Scores")
# roc.curve(response = rocData$response, predicted = rocData$mean_score, 
#           main="ROC curve for Covariation Scores", add.roc = F)
# roc.curve(response = rocData$response, predicted = rocData$count, 
#           main="ROC curve for Covariation Scores", add.roc = F)
# roc.curve(response = rocData$response, predicted = rocData$combined_score, 
#           main="ROC curve for Covariation Scores", add.roc = F)

pcCov <- pcCov %>% mutate(group = "Positive Control")
predCovRNA <- predCovRNA %>% mutate(group = "Predicted") 
ncCovRNA <- ncCovRNA %>% mutate(group = "Negative Control")


dists <- pcCov %>% bind_rows(predCovRNA, ncCovRNA) %>% mutate(max_dist = -log(min_eval)) %>% select(ID, max_dist, group) %>% mutate(max_dist = ifelse(max_dist < 0, 0, max_dist))
distsCumulativeCount <- cumulativeCounts(dists = dists, smooth = F)
distsCumulativeCount <- distsCumulativeCount %>% dplyr::rename(rscape_cov_min_eval = max_dist)

p <- ggplot() +
  geom_line(data = distsCumulativeCount, aes(x= rscape_cov_min_eval, y = cumulative_prop, group = group, colour = group)) + 
  xlim(min = 0, max = 150)
p




write_data <- F
if(write_data){
  
    ggsave(filename = "~/phd/RNASeq/figures/covariation_rscape.svg", plot = p)

  
svg(filename="~/phd/RNASeq/figures/cov_combined.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$combined_score, 
          main="ROC curve for Covariation combined", add.roc = F)


dev.off()



svg(filename="~/phd/RNASeq/figures/cov_count.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$count, 
          main="ROC curve for Covariation count", add.roc = F)


dev.off()

svg(filename="~/phd/RNASeq/figures/cov_mean.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$mean_score, 
          main="ROC curve for Covariation mean", add.roc = F)


dev.off()


svg(filename="~/phd/RNASeq/figures/cov_min_eval.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$min_eval, 
          main="ROC curve for Covariation min eval", add.roc = F)


dev.off()
}

```

   made using sRNAGCPercentage.py

    - input is the fasta file


###alifold_cov

```{r alifold_cov, eval = T, include=T}
pcCovAli <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/old/positive_control_alifold_covariation.txt", sep = "", comment.char = "#", as.is = T, header = F, fill = T, col.names = c("ID", "alifold_cov_score"))
ncCovAli <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/old/negative_control_alifold_covariation.txt", sep = "", comment.char = "#", as.is = T, header = F, fill = T, col.names = c("ID", "alifold_cov_score"))
predCovAli <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/old/predicted_alifold_covariation.txt", sep = "", comment.char = "#", as.is = T, header = F, fill = T, col.names = c("ID", "alifold_cov_score"))




save(pcCovAli, file = "~/bin/r_git/R/r_files/pcCovAli.Rda")
save(ncCovAli, file = "~/bin/r_git/R/r_files/ncCovAli.Rda")
save(predCovAli, file = "~/bin/r_git/R/r_files/predCovAli.Rda")



load("~/bin/r_git/R/r_files/pcCovAli.Rda")
load("~/bin/r_git/R/r_files/ncCovAli.Rda")
load("~/bin/r_git/R/r_files/predCovAli.Rda")





pcCovRoc <- pcCovAli %>% mutate(response = 1) 
ncCovRoc <- ncCovAli %>% mutate(response = 0)
rocData <- pcCovRoc %>% bind_rows(ncCovRoc) %>% filter(!is.na(alifold_cov_score))
roc.curve(response = rocData$response, predicted = rocData$alifold_cov_score, 
          main="ROC curve for Alifold Covariation Scores")

pcCovAli <- pcCovAli %>% mutate(group = "Positive Control")
predCovAli <- predCovAli %>% mutate(group = "Predicted") 
ncCovAli <- ncCovAli %>% mutate(group = "Negative Control")



known_predicted <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/known_predicted_models_list.txt")

known_predicted <- known_predicted %>% select(V2) %>% unique() %>% mutate(pred = T) %>% dplyr::rename(ID = V2)

predKnownCovAli <-  pcCovAli %>% left_join(known_predicted, by = "ID") %>% filter(!is.na(pred)) %>% select(-pred) %>% mutate(group = "Predicted")
# 
# 
# dists <- pcCovAli %>% bind_rows(predCovAli, ncCovAli, predKnownCovAli) %>% dplyr::rename(max_dist = alifold_cov_score) 
# distsCumulativeCount <- cumulativeCounts(dists = dists, smooth = F)
# distsCumulativeCount <- distsCumulativeCount %>% dplyr::rename(alifold_cov_score = max_dist)
# 
# p <- ggplot() +
#   geom_line(data = distsCumulativeCount, aes(x= alifold_cov_score, y = cumulative_prop, group = group, colour = group))
# p
# 
# 
# write_data <- F
# if(write_data){
#   
#   ggsave(filename = "~/phd/RNASeq/figures/covariation_alifold.svg", plot = p)
# }


```



##GC Content {#gc_content_results}

###All sequences per alignment

```{r gc_content_per_alignment_setup, eval=T}
predGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_gc_all.txt")
pcGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_gc_all.txt")
ncGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_gc_all.txt")

colnames(predGC) <- c("counts", "letter", "ID")
colnames(pcGC) <- c("counts", "letter", "ID")
colnames(ncGC) <- c("counts", "letter", "ID")

predGCTotals <- predGC %>% group_by(ID) %>% summarise(total = sum(counts)/2)
pcGCTotals <- pcGC %>% group_by(ID) %>% summarise(total = sum(counts)/2)
ncGCTotals <- ncGC %>% group_by(ID) %>% summarise(total = sum(counts)/2)

predGC <- predGC %>% left_join(predGCTotals, by = "ID") %>% 
  filter(letter == "C") %>% mutate(gc.percent = (counts/total)*100,
                                   group = "Predicted")
pcGC <- pcGC %>% left_join(pcGCTotals, by = "ID") %>% 
  filter(letter == "C") %>% mutate(gc.percent = (counts/total)*100,
                                   group = "Positive Control")
ncGC <- ncGC %>% left_join(ncGCTotals, by = "ID") %>% 
  filter(letter == "C") %>% mutate(gc.percent = (counts/total)*100,
                                   group = "Negative Control")
gc <- predGC %>% bind_rows(pcGC, ncGC)

p <- ggplot() + 
  geom_freqpoly(data = gc, aes(x = gc.percent, y = ..density.., group = group, color = group), binwidth = 5)
   
p 

# ggsave(filename = "~/phd/RNASeq/figures/gc_content_all.svg", plot = p)


```


```{r gc_content_per_alignment, eval = T}
predGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_gc_all.txt")
pcGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_gc_all.txt")
ncGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_gc_all.txt")

colnames(predGC) <- c("counts", "letter", "ID")
colnames(pcGC) <- c("counts", "letter", "ID")
colnames(ncGC) <- c("counts", "letter", "ID")

predGCTotals <- predGC %>% group_by(ID) %>% summarise(total = sum(counts)/2)
pcGCTotals <- pcGC %>% group_by(ID) %>% summarise(total = sum(counts)/2)
ncGCTotals <- ncGC %>% group_by(ID) %>% summarise(total = sum(counts)/2)

predGC <- predGC %>% left_join(predGCTotals, by = "ID") %>% 
  filter(letter == "C") %>% mutate(gc.percent = (counts/total)*100,
                                   group = "Predicted")
pcGC <- pcGC %>% left_join(pcGCTotals, by = "ID") %>% 
  filter(letter == "C") %>% mutate(gc.percent = (counts/total)*100,
                                   group = "Positive Control")
ncGC <- ncGC %>% left_join(ncGCTotals, by = "ID") %>% 
  filter(letter == "C") %>% mutate(gc.percent = (counts/total)*100,
                                   group = "Negative Control")

pcGC <- pcGC %>% mutate(response = 1)
ncGC <- ncGC %>% mutate(response = 0)

rocData <- pcGC %>% bind_rows(ncGC)

roc.curve(response = rocData$response, predicted = rocData$gc.percent,
          main="ROC curve for GC%")


write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/gc.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$V2,
          main="ROC curve for GC%")

dev.off()
}


save(pcGC, file= "~/bin/r_git/R/r_files/pcGC.Rda")
save(ncGC, file= "~/bin/r_git/R/r_files/ncGC.Rda")
save(predGC, file= "~/bin/r_git/R/r_files/predGC.Rda")

```

###Reference sequences only

```{r gc_content_rf_setup, eval=T}
predGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_gc_reference.txt")
pcGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_gc_reference.txt")
ncGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_gc_reference.txt")

colnames(predGC) <- c("counts", "letter", "ID")
colnames(pcGC) <- c("counts", "letter", "ID")
colnames(ncGC) <- c("counts", "letter", "ID")

predGCTotals <- predGC %>% group_by(ID) %>% summarise(total = sum(counts))
pcGCTotals <- pcGC %>% group_by(ID) %>% summarise(total = sum(counts))
ncGCTotals <- ncGC %>% group_by(ID) %>% summarise(total = sum(counts))

predGC <- predGC %>% filter(letter %in% c("C", "G")) %>% group_by(ID) %>% summarise(gc.count = sum(counts)) %>% left_join(predGCTotals, by = "ID") %>% 
   mutate(gc.percent = (gc.count/total)*100,
                                   group = "Predicted")
pcGC <- pcGC %>% filter(letter %in% c("C", "G")) %>% group_by(ID) %>% summarise(gc.count = sum(counts)) %>% left_join(pcGCTotals, by = "ID") %>% 
   mutate(gc.percent = (gc.count/total)*100,
                                   group = "Positive Control")
ncGC <- ncGC %>% filter(letter %in% c("C", "G")) %>% group_by(ID) %>% summarise(gc.count = sum(counts)) %>% left_join(ncGCTotals, by = "ID") %>% 
   mutate(gc.percent = (gc.count/total)*100,
                                   group = "Negative Control")
gc <- predGC %>% bind_rows(pcGC, ncGC)

p <- ggplot() + 
  geom_freqpoly(data = gc, aes(x = gc.percent, y = ..density.., group = group, color = group), binwidth = 8)
   
p 

predGCrf <- predGC
pcGCrf <- pcGC
ncGCrf <- ncGC
save(predGCrf, file = "~/bin/r_git/R/r_files/predGCrf.Rda")
save(pcGCrf, file = "~/bin/r_git/R/r_files/pcGCrf.Rda")
save(ncGCrf, file = "~/bin/r_git/R/r_files/ncGCrf.Rda")

# ggsave(filename = "~/phd/RNASeq/figures/gc_content_rf.svg", plot = p)


```


```{r gc_content_rf, eval = T}
load("~/bin/r_git/R/r_files/predGCrf.Rda")
load("~/bin/r_git/R/r_files/pcGCrf.Rda")
load("~/bin/r_git/R/r_files/ncGCrf.Rda")

pcGC <- pcGCrf 
ncGC <- ncGCrf 
predGC <- predGCrf 

save(pcGC, file= "~/bin/r_git/R/r_files/pcGC.Rda")
save(ncGC, file= "~/bin/r_git/R/r_files/ncGC.Rda")
save(predGC, file= "~/bin/r_git/R/r_files/predGC.Rda")
```


###Reference sequences relative to genome

`cd ~/phd/RNASeq/new_calls`

`wc -l * | cut -d '_' -f1,2 > ../genome_calls_count.txt`


Run on server (*biochemcompute.uod.otago.ac.nz*):

```{bash genome_lengths, eval=F}
cd ~/phd/RNASeq/analysed_genomes/done 

for file in *.fna;
do
esl-seqstat $file | grep "Total" > ../$file.stats
done
```

```{bash genome_lengths_summary, eval=F}
cd ~/phd/RNASeq/analysed_genomes/

for file in *.stats;
do

ID=`basename $file .fna.stats`

echo $ID

cat $file | sed -e "s/$/  $ID/"  >> genome_lengths.txt

done

```

Download to MacBook:

`cd ~/phd/RNASeq/`

`scp bioc:~/phd/RNASeq/analysed_genomes/genome_lengths.txt ./`


```{r genomes_gc, eval=F}
genomesGC <- read.table("~/phd/RNASeq/gc_genomes_analysed.txt", as.is = T, stringsAsFactors = F)


colnames(genomesGC) <- c("counts", "letter", "ID")

genomesGCTotals <- genomesGC %>% group_by(ID) %>% summarise(total = sum(counts)/2)


genomesGC <- genomesGC %>% left_join(genomesGCTotals, by = "ID") %>% 
  filter(letter == "C") %>% mutate(gc.percent = (counts/total)*100,
                                   group = "genome")

save(genomesGC, file = "~/bin/r_git/R/r_files/genomesGC.Rda")
```

```{r gc_content_rf_relative_setup, eval=F}
load("~/bin/r_git/R/r_files/genomesGC.Rda")

counts <- read.table("~/phd/RNASeq/genome_calls_count.txt")
lengths <- read.table("~/phd/RNASeq/genome_lengths.txt", comment.char = "")

lengths <- lengths %>% select(V4, V5) %>% dplyr::rename(ID = V5, genome.length = V4)

colnames(counts) <- c("number.of.srnas", "ID")

genomesGC <- genomesGC %>% left_join(counts, by = "ID") %>% left_join(lengths, by = "ID")

genomesGC <- genomesGC %>% mutate(srna.per.mb = (number.of.srnas/genome.length)*1000000) %>% filter(!is.na(srna.per.mb))


ggplot() +
  geom_point(data = genomesGC, aes(x = 100 - gc.percent, y = srna.per.mb))

```


```{r gc_content_rf_relative, eval = F}
predGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_gc_reference.txt")
pcGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_gc_reference.txt")
ncGC <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_gc_reference.txt")

colnames(predGC) <- c("counts", "letter", "ID")
colnames(pcGC) <- c("counts", "letter", "ID")
colnames(ncGC) <- c("counts", "letter", "ID")

predGCTotals <- predGC %>% group_by(ID) %>% summarise(total = sum(counts)/2)
pcGCTotals <- pcGC %>% group_by(ID) %>% summarise(total = sum(counts)/2)
ncGCTotals <- ncGC %>% group_by(ID) %>% summarise(total = sum(counts)/2)

predGC <- predGC %>% left_join(predGCTotals, by = "ID") %>% 
  filter(letter == "C") %>% mutate(gc.percent = (counts/total)*100,
                                   group = "Predicted")
pcGC <- pcGC %>% left_join(pcGCTotals, by = "ID") %>% 
  filter(letter == "C") %>% mutate(gc.percent = (counts/total)*100,
                                   group = "Positive Control")
ncGC <- ncGC %>% left_join(ncGCTotals, by = "ID") %>% 
  filter(letter == "C") %>% mutate(gc.percent = (counts/total)*100,
                                   group = "Negative Control")

pcGC <- pcGC %>% mutate(response = 1)
ncGC <- ncGC %>% mutate(response = 0)

rocData <- pcGC %>% bind_rows(ncGC)

roc.curve(response = rocData$response, predicted = rocData$gc.percent,
          main="ROC curve for GC%")

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/gc.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$V2,
          main="ROC curve for GC%")

dev.off()
}


save(pcGC, file= "~/bin/r_git/R/r_files/pcGC.Rda")
save(ncGC, file= "~/bin/r_git/R/r_files/ncGC.Rda")
save(predGC, file= "~/bin/r_git/R/r_files/predGC.Rda")

```




##Secondary Structure {#secondary_structure_results}

###alifold_setup

-  Need to run

    - cd ~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments

    - grep "-" positive_control.alifold > positive_control_fixed.alifold
    
- It appears fine for the other groups 

```{r alifold_setup, eval = F}
pcAlifold<- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control.alifold", header = F, comment.char = "#", quote = "", sep = "", fill = T, as.is = T, col.names = c( "From",      "To",    "Strand",    "Native.MFE",    "Mean.MFE",     "STDV",      "Z", "ID"))
ncAlifold<- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control.alifold", header = F, comment.char = "#", quote = "", sep = "", fill = T, as.is = T)

predAlifold<- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted.alifold", header = F, comment.char = "#", quote = "", sep = "", fill = T, as.is = T)

colnames(pcAlifold) <- c( "From",      "To",    "Strand",    "Native.MFE",    "Mean.MFE",     "STDV",      "Z", "ID")
colnames(ncAlifold) <- c( "From",      "To",    "Strand",    "Native.MFE",    "Mean.MFE",     "STDV",      "Z", "ID")
colnames(predAlifold) <- c( "From",      "To",    "Strand",    "Native.MFE",    "Mean.MFE",     "STDV",      "Z", "ID")

ncAlifold <- ncAlifold %>% filter(grepl(pattern = "GCA_", ID), STDV > 0) 
pcAlifold <- pcAlifold %>% filter(grepl(pattern = "RF", ID))
predAlifold <- predAlifold %>% filter(grepl(pattern = "GCA_", ID)) 


pcAlifoldsd <- pcAlifold %>% select(ID, STDV)
predAlifoldsd <- predAlifold %>% select(ID, STDV)

pcAlifoldMean <- pcAlifold %>% group_by(ID) %>% summarise(z_mean = mean(as.numeric(Z), na.rm = T))
pcAlifoldMax <- pcAlifold %>% group_by(ID) %>% summarise(z_max = max(as.numeric(Z), na.rm = T))

ncAlifoldMean <- ncAlifold %>% group_by(ID) %>% summarise(z_mean = mean(as.numeric(Z), na.rm = T))
ncAlifoldMax <- ncAlifold %>% group_by(ID) %>% summarise(z_max = max(as.numeric(Z), na.rm = T))

predAlifoldMean <- predAlifold %>% group_by(ID) %>% summarise(z_mean = mean(as.numeric(Z), na.rm = T))
predAlifoldMax <- predAlifold %>% group_by(ID) %>% summarise(z_max = max(as.numeric(Z), na.rm = T))

pcAlifold <- pcAlifoldMean %>% full_join(pcAlifoldMax, by = "ID") %>% full_join(pcAlifoldsd, by = "ID") %>% 
  filter(STDV != -Inf) 
ncAlifold <- ncAlifoldMean %>% full_join(ncAlifoldMax, by = "ID")
predAlifold <- predAlifoldMean %>% full_join(predAlifoldMax, by = "ID") %>% full_join(predAlifoldsd, by = "ID")%>% 
  filter(STDV != -Inf) 


save(pcAlifold, file = "~/bin/r_git/R/r_files/pcAlifold.Rda")
save(ncAlifold, file = "~/bin/r_git/R/r_files/ncAlifold.Rda")
save(predAlifold, file = "~/bin/r_git/R/r_files/predAlifold_v2.Rda")
```

###alifold_check

-   The original ROC plot was showing a flat spot near the start. 

    -   The code below was used to check what this was. 
    -   When the standard deviation is zero then Z scores are meaningless and need removing.
    -   This was added to the above code and fixed the problem.

```{r alifold_check, eval=F}
load("~/bin/r_git/R/r_files/pcAlifold.Rda")
load("~/bin/r_git/R/r_files/ncAlifold.Rda")
pcAlifold <- pcAlifold %>% mutate(response = 1)
ncAlifold <- ncAlifold %>% mutate(response = 0)

rocData <- pcAlifold %>% bind_rows(ncAlifold)
rocData <- rocData[!is.na(rocData$z_mean),] 
rocData <- rocData[!is.na(rocData$z_max),] 

pred <- prediction( rocData$z_mean, rocData$response)
perf <- performance(pred,"tpr","fpr")
plot(perf)
str(perf)

cutoffs <- data.frame(cut=perf@alpha.values[[1]], fpr=perf@x.values[[1]], 
                      tpr=perf@y.values[[1]])

tmp <- rocData %>% filter(z_mean > -0.35, z_mean < 0.06)

```


###alifold_results

```{r alifold, eval = T}
load("~/bin/r_git/R/r_files/pcAlifold.Rda")
load("~/bin/r_git/R/r_files/ncAlifold.Rda")
load("~/bin/r_git/R/r_files/predAlifold_v2.Rda")

pcAlifold <- pcAlifold %>% mutate(response = 1) %>% filter(STDV > 0) %>% unique()
ncAlifold <- ncAlifold %>% mutate(response = 0)



rocData <- pcAlifold %>% bind_rows(ncAlifold)
rocData <- rocData[!is.na(rocData$z_mean),] 
rocData <- rocData[!is.na(rocData$z_max),] 


ggplot() +
  geom_freqpoly(data = rocData, aes(x = z_mean, y = ..count.., group = as.character(response), color = as.character(response)), binwidth = 1)

roc.curve(response = rocData$response, predicted = rocData$z_max,
          main="ROC curve for Z-score Alifoldz")


write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/alifold_mean.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$z_mean,
          main="ROC curve for Z-score Alifoldz mean")

dev.off()

svg(filename="~/phd/RNASeq/figures/alifold_max.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$z_max,
          main="ROC curve for Z-score Alifoldz max")

dev.off()
}


rocData %>% group_by(response) %>% summarise(count = n())
rocData %>% group_by(response) %>% filter(z_mean <= -1) %>% summarise(count = n())

load("~/bin/r_git/R/r_files/pcAlifold.Rda")
load("~/bin/r_git/R/r_files/ncAlifold.Rda")
load("~/bin/r_git/R/r_files/predAlifold_v2.Rda")
# 
# known_predicted <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/known_predicted_models_list.txt")
# 
# known_predicted <- known_predicted %>% select(V2) %>% unique() %>% mutate(pred = T) %>% dplyr::rename(ID = V2)
# 
# predKnownAlifold <-  pcAlifold %>% separate(col = ID, into = c("t1", "t2"), sep = "_") %>% separate(t2, into = "ID", sep = "\\.", extra = "drop") %>% select(-t1) %>% left_join(known_predicted, by = "ID") %>% filter(!is.na(pred)) %>% select(-pred) %>% mutate(group = "Predicted") %>% filter(STDV > 0)

pcAlifold <- pcAlifold %>% mutate(group = "Positive Control")%>% filter(STDV > 0)
predAlifold <- predAlifold %>% mutate(group = "Predicted") %>% filter(STDV > 0)
ncAlifold <- ncAlifold %>% mutate(group = "Negative Control")

dists <- pcAlifold %>% bind_rows(predAlifold, ncAlifold) %>% dplyr::rename(max_dist = z_max) 


distsCumulativeCount <- cumulativeCounts(dists = dists, smooth = F)

distsCumulativeCount <- distsCumulativeCount %>% dplyr::rename(alifold_z_score = max_dist)



p <- ggplot() +
  geom_line(data = distsCumulativeCount, aes(x= alifold_z_score, y = cumulative_prop, group = group, colour = group))
p


write_data <- F
if(write_data){
  
  ggsave(filename = "~/phd/RNASeq/figures/z_score_alifold.svg", plot = p)
}




```

###MFE

```{r MFE, eval = T, echo=T}
pcMFE <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/old/positive_control_mfe.txt", sep = "", comment.char = "#", as.is = T, header = F, fill = T)
ncMFE <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/old/negative_control_mfe.txt", sep = "", comment.char = "#", as.is = T, header = F, fill = T)
predMFE <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/old/predicted_mfe.txt", sep = "", comment.char = "#", as.is = T, header = F, fill = T)

# predMFEOld <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/old/predicted_mfe.txt", sep = "", comment.char = "#", as.is = T, header = F, fill = T)

# both <- predMFE %>% full_join(predMFEOld, by = 'V1') %>% mutate(diff = V2.x - V2.y)


pcMFE <- pcMFE %>% filter(V1 != "From", grepl(pattern = "-", x = V1) ==F, V1 != "ERROR")
ncMFE <- ncMFE %>% filter(V1 != "From", grepl(pattern = "-", x = V1) ==F, V1 != "ERROR")
predMFE <- predMFE %>% filter(V1 != "From", grepl(pattern = "-", x = V1) ==F, V1 != "ERROR")

pcMFE <- pcMFE %>% mutate(group = "Positive Control")
ncMFE <- ncMFE %>% mutate(group = "Negative Control")
predMFE <- predMFE %>% mutate(group = "Predicted")

mfe <- pcMFE %>% bind_rows(ncMFE, predMFE)


pcMFE <- pcMFE %>% mutate(response = 1) %>%  filter(!is.na(V2))
ncMFE <- ncMFE %>% mutate(response = 0) %>%  filter(!is.na(V2))



save(pcMFE, file= "~/bin/r_git/R/r_files/pcMFE.Rda")
save(ncMFE, file= "~/bin/r_git/R/r_files/ncMFE.Rda")
save(predMFE, file= "~/bin/r_git/R/r_files/predMFE.Rda")



```

```{r alifold_score, eval=F, echo=T}
pcAlifoldScore <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/old/positive_control_alifold_score.txt",sep = "", fill = T)

ncAlifoldScore <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/old/negative_control_alifold_score.txt",sep = "", fill = T)

predAlifoldScore <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/old/predicted_alifold_score.txt",sep = "", fill = T)


pcAlifoldScore[is.na(pcAlifoldScore)] <- 0
ncAlifoldScore[is.na(ncAlifoldScore)] <- 0
predAlifoldScore[is.na(predAlifoldScore)] <- 0

colnames(pcAlifoldScore) <- c("ID", "alifold.score")
colnames(ncAlifoldScore) <- c("ID", "alifold.score")
colnames(predAlifoldScore) <- c("ID", "alifold.score")


save(pcAlifoldScore, file= "~/bin/r_git/R/r_files/pcAlifoldScore.Rda")
save(ncAlifoldScore, file= "~/bin/r_git/R/r_files/ncAlifoldScore.Rda")
save(predAlifoldScore, file= "~/bin/r_git/R/r_files/predAlifoldScore.Rda")

```

##ncRNA motifs {#ncrna_motifs}

###motifs_setup

Go to:

-   [*Top*](#top)

-   [*Results*](#section-results)

***


```{r motifs_setup, eval=F}
pcMotif <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control.rmfam", sep = "", comment.char = "#", as.is = T, header = F, fill = T)
ncMotif <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control.rmfam", sep = "", comment.char = "#", as.is = T, header = F, fill = T)

predMotif <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted.rmfam", sep = "", comment.char = "#", as.is = T, header = F, fill = T)

colnames(pcMotif) <- c("seqname", "source", "feature", "start", "end", "score", "strand", "frame", "attribute", "ID")
colnames(ncMotif) <- c("seqname", "source", "feature", "start", "end", "score", "strand", "frame", "attribute", "ID")
colnames(predMotif) <- c("seqname", "source", "feature", "start", "end", "score", "strand", "frame", "attribute", "ID")

pcMotifMean <- pcMotif %>% group_by(ID) %>% summarise(mean_score = mean(score))
pcMotifMax <- pcMotif %>% group_by(ID) %>% summarise(max_score = max(score))

pcMotif <- pcMotifMean %>% full_join(pcMotifMax, by = "ID")


ncMotifMean <- ncMotif %>% group_by(ID) %>% summarise(mean_score = mean(score))
ncMotifMax <- ncMotif %>% group_by(ID) %>% summarise(max_score = max(score))
ncMotif <- ncMotifMean %>% full_join(ncMotifMax, by = "ID")

predMotifMean <- predMotif %>% group_by(ID) %>% summarise(mean_score = mean(score))
predMotiffMax <- predMotif %>% group_by(ID) %>% summarise(max_score = max(score))

predMotif <- predMotifMean %>% full_join(predMotiffMax, by = "ID")


save(pcMotif, file = "~/bin/r_git/R/r_files/pcMotif.Rda")
save(ncMotif, file = "~/bin/r_git/R/r_files/ncMotif.Rda")
save(predMotif, file = "~/bin/r_git/R/r_files/predMotif.Rda")

```

##RandomForest

***

###random_forest_data_setup

```{r random_forest_data_setup, eval=F}
load("~/bin/r_git/R/r_files/max_dists_pc.Rda")
load("~/bin/r_git/R/r_files/max_dists_nc.Rda")

max_dists_pc <- max_dists_pc  %>% separate(id, into = "ID", sep = "\\.", extra = "drop") %>% select(ID, distance)
max_dists_nc <- max_dists_nc  %>% separate(col = id, into = c("t1", "ID"), sep = "_", extra = "merge")  %>% select(-t1)  %>% select(ID, distance)


load("~/bin/r_git/R/r_files/ncRDepth.Rda")
load("~/bin/r_git/R/r_files/pcRDepth.Rda")

pcRDepthMaxs <- pcRDepth %>% dplyr::rename(ID = srna) %>% group_by(ID) %>% summarise(read.max.score  = sum(max.val))
pcRDepthMeans <- pcRDepth %>% dplyr::rename(ID = srna) %>% group_by(ID) %>% summarise(reads.mean.score  = sum(mean.val))
pcRDepth <- pcRDepthMaxs %>% full_join(pcRDepthMeans, by = "ID")

ncRDepthMaxs <- ncRDepth %>% dplyr::rename(ID = srna) %>% group_by(ID) %>% summarise(read.max.score  = sum(max.val))
ncRDepthMeans <- ncRDepth %>% dplyr::rename(ID = srna) %>% group_by(ID) %>% summarise(reads.mean.score  = sum(mean.val))
ncRDepth <- ncRDepthMaxs %>% full_join(ncRDepthMeans, by = "ID")


load("~/bin/r_git/R/r_files/pcCovariation.Rda") ##pcCov
load("~/bin/r_git/R/r_files/ncCovariation.Rda") ##ncCovRNA

ncCovRNA <- ncCovRNA %>% filter(!is.na(mean_score)) %>% mutate(combined_score = count * mean_score) %>% 
  dplyr::rename(cov.mean.score = mean_score, cov.min.eval = min_eval, cov.count = count, cov.combined.score = combined_score)
pcCov <- pcCov %>% separate(ID, into = c("t1", "t2"), sep = "_") %>% dplyr::rename(ID = t1) %>% select(-t2) %>% filter(!is.na(mean_score)) %>% mutate(combined_score = count * mean_score) %>% 
  dplyr::rename(cov.mean.score = mean_score, cov.min.eval = min_eval, cov.count = count, cov.combined.score = combined_score)



load("~/bin/r_git/R/r_files/pcGC.Rda")
load("~/bin/r_git/R/r_files/ncGC.Rda")

pcGC <- pcGC %>% separate(ID, into = "t1", sep = "\\.", extra = "drop") %>% dplyr::rename(gc.score = gc.percent, ID = t1) %>% select(ID, gc.score)
ncGC <- ncGC %>% dplyr::rename(gc.score = gc.percent) %>% select(ID, gc.score)

load("~/bin/r_git/R/r_files/pcAlifold.Rda")
load("~/bin/r_git/R/r_files/ncAlifold.Rda")

pcAlifold <- pcAlifold %>% separate(col = ID, into = c("t1", "t2"), sep = "_") %>% separate(t2, into = "ID", sep = "\\.", extra = "drop") %>% select(-t1, -STDV) 

ncAlifold <- ncAlifold %>% separate(col = ID, into = c("t1", "id"), sep = "_", extra = "merge")  %>% select(-t1) %>% dplyr::rename(ID = id)


load("~/bin/r_git/R/r_files/pcMFE.Rda")
load("~/bin/r_git/R/r_files/ncMFE.Rda")

pcMFE <- pcMFE %>% dplyr::rename(ID = V1, mfe.score = V2) %>% select(ID, mfe.score)

ncMFE <- ncMFE %>% separate(col = V1, into = c("t1", "ID"), sep = "_", extra = "merge")  %>% select(-t1) %>% dplyr::rename(mfe.score = V2) %>% select(ID, mfe.score)




load("~/bin/r_git/R/r_files/pcMotif.Rda")
load("~/bin/r_git/R/r_files/ncMotif.Rda")

pcMotif <- pcMotif %>% separate(col = ID, into = c("t1", "t2"), sep = "_") %>% separate(t2, into = "ID", sep = "\\.", extra = "drop") %>% select(-t1) %>% 
  dplyr::rename(motif.mean.score = mean_score, motif.max.score = max_score)

ncMotif <- ncMotif %>% separate(col = ID, into = c("t1", "t2"), sep = "_", extra = "merge") %>% separate(t2, into = c("t3", "t4"), sep = "\\.", extra = "drop") %>% mutate(ID = paste(t3, t4, sep=".")) %>% select(ID, mean_score, max_score) %>% 
  dplyr::rename(motif.mean.score = mean_score, motif.max.score = max_score)

remaining_nc_srnas <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_ids.txt", sep = "\t", fill =  T)
remaining_nc_srnas <- remaining_nc_srnas %>% dplyr::rename(ID = V1) %>% mutate(keep =T)



load("~/bin/r_git/R/r_files/pcCovAli.Rda")
load("~/bin/r_git/R/r_files/ncCovAli.Rda")

pcCovAli <- pcCovAli %>% select(ID, alifold_cov_score)
ncCovAli <- ncCovAli %>% separate(col = ID, into = c("t1", "t2"), sep = "_", extra = "merge")  %>% select(-t1) %>% mutate(ID = t2)  %>% select(ID, alifold_cov_score)

load("~/bin/r_git/R/r_files/pcAlifoldScore.Rda")
load("~/bin/r_git/R/r_files/ncAlifoldScore.Rda")

ncAlifoldScore <- ncAlifoldScore %>% separate(col = ID, into = c("t1", "t2"), sep = "_", extra = "merge")  %>% select(-t1) %>% mutate(ID = t2)  %>% select(ID, alifold.score)


pcSRNACounts <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_snra_counts.txt")

ncSRNACounts <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_snra_counts.txt")

colnames(pcSRNACounts) <- c("srna.counts", "ID")
colnames(ncSRNACounts) <- c("srna.counts", "ID")

pcDat <- pcMFE %>% 
  full_join(pcGC, by = "ID") %>% 
  full_join(max_dists_pc, by = "ID") %>% 
  full_join(pcRDepth, by = "ID") %>% 
  full_join(pcCov, by = "ID") %>% 
  full_join(pcMotif, by = "ID")%>% 
  full_join(pcAlifold, by = "ID") %>% 
  full_join(pcCovAli, by = "ID") %>% 
  full_join(pcAlifoldScore, by = "ID") %>%
  full_join(pcSRNACounts, by = "ID") %>%
  filter(!is.na(mfe.score)) %>% 
  mutate(group = "Positive Control") %>% 
  unique() 


pcDatAll <- pcDat
pcDat <- pcDat %>%  filter(!is.na(read.max.score))


ncDat <- ncMFE %>% 
  full_join(ncGC, by = "ID") %>% 
  full_join(max_dists_nc, by = "ID") %>% 
  full_join(ncRDepth, by = "ID") %>% 
  full_join(ncCovRNA, by = "ID") %>% 
  full_join(ncMotif, by = "ID")%>% 
  full_join(ncAlifold, by = "ID") %>% 
  full_join(ncCovAli, by = "ID") %>% 
  full_join(ncAlifoldScore, by = "ID") %>% 
  full_join(ncSRNACounts, by = "ID") %>% 
  mutate(group = "Negative Control") 


ncDat <- ncDat %>%  left_join(remaining_nc_srnas, by = "ID") %>% filter(!is.na(keep)) %>% select(-keep) %>%  unique()

ncDat <- ncDat %>% filter(reads.mean.score < 15, srna.counts < 50)

dat <- pcDat %>% bind_rows(ncDat) %>% select(-cov.combined.score)
datAll <- pcDatAll %>% bind_rows(ncDat) %>% select(-cov.combined.score)


save(dat, file = "~/bin/r_git/R/r_files/randomForestDatwithNAs.Rda")
save(datAll, file = "~/bin/r_git/R/r_files/randomForestDatwithNAsAll.Rda")

# dat <- dat %>% filter(!is.na(mfe.score))
replaceNAs <- function(dat){
  
dat$mfe.score[is.na(dat$mfe.score)] <- 0
dat$gc.score[is.na(dat$gc.score)] <- 50
dat$distance[is.na(dat$distance)] <- 0
dat$reads.mean.score[is.na(dat$reads.mean.score)] <- 0
dat$read.max.score[is.na(dat$read.max.score)] <- 0
dat$cov.mean.score[is.na(dat$cov.mean.score)] <- 0
dat$cov.min.eval[is.na(dat$cov.min.eval)] <- 10
# dat$cov.combined.score[is.na(dat$cov.combined.score)] <- 0
dat$cov.count[is.na(dat$cov.count)] <- 1
dat$motif.mean.score[is.na(dat$motif.mean.score)] <- 0
dat$motif.max.score[is.na(dat$motif.max.score)] <- 0
dat$z_mean[is.na(dat$z_mean)] <- 10
dat$z_max[is.na(dat$z_max)] <- 10
dat$alifold.score[is.na(dat$alifold.score)] <- 0
dat$alifold_cov_score[is.na(dat$alifold_cov_score)] <- 0
# dat$alifold_cov_score[dat$alifold_cov_score > 0] <- 0
return(dat)
}

dat <- replaceNAs(dat = dat)
datAll <- replaceNAs(dat = datAll)

randomForestDat <- dat
randomForestDatAll <- datAll

save(randomForestDat, file = "~/bin/r_git/R/r_files/randomForestDat.Rda")
save(randomForestDatAll, file = "~/bin/r_git/R/r_files/randomForestDatAll.Rda")
```

###correlation_heat_map

```{r correlation_heat_map, eval=T}
load("~/bin/r_git/R/r_files/randomForestDat.Rda")
load("~/bin/r_git/R/r_files/randomForestDatwithNAs.Rda") ##dat

pcAliScore2 <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_alifold_score.txt")
ncAliScore2 <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_alifold_score.txt")
pcAliCov2 <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_alifold_covariation.txt")
ncAliCov2 <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_alifold_covariation.txt")
pcMFE2 <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_mfe.txt")
ncMFE2 <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_mfe.txt")

colnames(pcAliScore2) <- c("alifold_score.2", "ID")
colnames(ncAliScore2) <- c("alifold_score.2", "t1")
colnames(pcAliCov2) <- c("alifold_cov_score.2", "ID")
colnames(ncAliCov2) <- c("alifold_cov_score.2", "t1")
colnames(pcMFE2) <- c("mfe.score.2", "ID")
colnames(ncMFE2) <- c("mfe.score.2", "t1")

pcAliScore3 <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/old/positive_control_alifold_score_2.txt")
pcAliCov3 <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/old/positive_control_alifold_covariation_2.txt")
pcMFE3 <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/old/positive_control_mfe_2.txt")

colnames(pcAliScore3) <- c("alifold_score.3", "ID")
colnames(pcAliCov3) <- c("alifold_cov_score.3", "ID")
colnames(pcMFE3) <- c("mfe.score.3", "ID")

ncAliScore2 <- ncAliScore2 %>% separate(col = t1, into = c("t2", "ID"), sep = "_", extra = "merge", remove = T) %>% 
  select(-t2)

ncAliCov2 <- ncAliCov2 %>% separate(col = t1, into = c("t2", "ID"), sep = "_", extra = "merge", remove = T) %>% 
  select(-t2)

ncMFE2 <- ncMFE2 %>% separate(col = t1, into = c("t2", "ID"), sep = "_", extra = "merge", remove = T) %>% 
  select(-t2)

mfe2 <- pcMFE2 %>% bind_rows(ncMFE2)
aliScore2 <- pcAliScore2 %>% bind_rows(ncAliScore2) %>% group_by(ID) %>% summarise(alifold_score.2 = max(alifold_score.2))
aliCov2 <- pcAliCov2 %>% bind_rows(ncAliCov2)

ncAliScore3 <- ncAliScore2
ncAliCov3 <- ncAliCov2
ncMFE3 <- ncMFE2

colnames(ncAliScore3) <- c("alifold_score.3", "ID")
colnames(ncAliCov3) <- c("alifold_cov_score.3", "ID")
colnames(ncMFE3) <- c("mfe.score.3", "ID")

mfe3 <- pcMFE3 %>% bind_rows(ncMFE3)
aliScore3 <- pcAliScore3 %>% bind_rows(ncAliScore3) %>% group_by(ID) %>% summarise(alifold_score.3 = max(alifold_score.3))
aliCov3 <- pcAliCov3 %>% bind_rows(ncAliCov3)


dat <- dat %>% 
  left_join(mfe2, by = "ID")%>% 
  left_join(aliScore2, by = "ID")%>% 
  left_join(aliCov2, by = "ID") %>% 
  left_join(mfe3, by = "ID") %>% 
  left_join(aliScore3, by = "ID") %>% 
  left_join(aliCov3, by = "ID") %>% 
  unique()


# ggplot()+
#   geom_freqpoly(data = dat %>% filter(group == "Positive Control"), aes(x = mfe.score.3, y = ..density..), color = 'blue', binwidth = 5)+
#   geom_freqpoly(data = dat %>% filter(group == "Positive Control"), aes(x = mfe.score.2, y = ..density..), binwidth = 5)


dat <- dat %>% select(-mfe.score, -mfe.score.3, -alifold_cov_score, -alifold_cov_score.2, -alifold.score, -alifold_score.3)

randomForestTestDat <- dat %>% dplyr::rename(alifold_cov_score = alifold_cov_score.3, mfe.score = mfe.score.2)


save(randomForestTestDat, file = "~/bin/r_git/R/r_files/randomForestTestDat.Rda")


dat <- dat %>% select(-ID) %>% unique() %>% mutate(cov.min.eval = -log(cov.min.eval),
                                                               z_mean = -z_mean,
                                                               z_max = -z_max, 
                                                               alifold_score.2  =-alifold_score.2,
                                                               mfe.score.2 = -mfe.score.2,
                                                               alifold_cov_score.3 = -alifold_cov_score.3)





set.seed(101)
randomNum <- runif(n = nrow(dat), min = 0, max = 1)
dat$random <- randomNum
dat3 <- dat %>% mutate(group.2 = ifelse(group == "Positive Control", 1, 0)) %>% select(-group)



dNames <- colnames(dat3)
pNames <- colnames(dat3)
pvalMatrix<-matrix(1, length(dNames), length(dNames))
rhoMatrix <-matrix(0, length(dNames), length(dNames))
rhoMatrixRounded <-matrix(0, length(dNames), length(dNames))
sigMatrix <-matrix("",length(dNames), length(dNames))

colnames(pvalMatrix)    <-pNames
rownames(pvalMatrix)    <-pNames
colnames(rhoMatrix)     <-pNames
rownames(rhoMatrix)     <-pNames
colnames(sigMatrix)     <-pNames
rownames(sigMatrix)     <-pNames
sigCount     <- 0
sigCount2015 <- 0
for(i in 1:length(dNames)){
      for(j in 1:length(dNames)){
   spear<-cor.test(dat3[,dNames[i] == colnames(dat3)], dat3[,dNames[j] == colnames(dat3)], method = "spearman", exact = T)
   pvalMatrix[i,j] <- spear$p.value
   rhoMatrix[i,j]  <- spear$estimate
   rhoMatrixRounded[i,j]  <- round(spear$estimate, 3)
   if(spear$p.value < 0.01/length(dNames)**2){
sigMatrix[i,j]  <- "X"
                sigCount <- sigCount + 1
   }

      }
}

save(rhoMatrix, file="~/bin/r_git/R/r_files/rhoMatrix.Rda")
save(sigMatrix, file="~/bin/r_git/R/r_files/sigMatrix.Rda")

heatmap.2(rhoMatrix, cellnote=rhoMatrixRounded,notecex=1.5,notecol="black", col=rev(redblue(40)), density.info="none", trace="none", dendrogram=c("column"), symm=F,symkey=T,symbreaks=T, scale="none", key.title = "", srtRow=45, adjRow=c(0, 1), srtCol=45, adjCol=c(1,1), breaks=(-20:20)/20,
margins = c(8, 8), cexRow=1.5, cexCol=1.5,font=1)

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/heatmap.svg",
     width=20,
     height=20,
     pointsize=12)
heatmap.2(rhoMatrix, cellnote=sigMatrix,notecex=1.5,notecol="black", col=rev(redblue(40)), density.info="none", trace="none", dendrogram=c("column"), symm=F,symkey=T,symbreaks=T, scale="none", key.title = "", srtRow=45, adjRow=c(0, 1), srtCol=45, adjCol=c(1,1), breaks=(-20:20)/20,
margins = c(8, 8), cexRow=1.5, cexCol=1.5,font=2)

dev.off()
}

```

###random_forest_setup

```{r random_forest_setup, eval = F}

load("~/bin/r_git/R/r_files/randomForestDatAll.Rda")
load("~/bin/r_git/R/r_files/randomForestTestDat.Rda")

replaceNAs <- function(dat){
  
dat$mfe.score[is.na(dat$mfe.score)] <- 0
dat$gc.score[is.na(dat$gc.score)] <- 50
dat$distance[is.na(dat$distance)] <- 0
# dat$reads.mean.score[is.na(dat$reads.mean.score)] <- 0
dat$read.max.score[is.na(dat$read.max.score)] <- 0
# dat$cov.mean.score[is.na(dat$cov.mean.score)] <- 0
dat$cov.min.eval[is.na(dat$cov.min.eval)] <- 10
# dat$cov.combined.score[is.na(dat$cov.combined.score)] <- 0
# dat$cov.count[is.na(dat$cov.count)] <- 1
# dat$motif.mean.score[is.na(dat$motif.mean.score)] <- 0
dat$motif.max.score[is.na(dat$motif.max.score)] <- 0
# dat$z_mean[is.na(dat$z_mean)] <- 10
dat$z_max[is.na(dat$z_max)] <- 10
# dat$alifold.score[is.na(dat$alifold.score)] <- 0
dat$alifold_cov_score[is.na(dat$alifold_cov_score)] <- 0
# dat$alifold_cov_score[dat$alifold_cov_score > 0] <- 0
return(dat)
}

randomForestTestDat <- replaceNAs(dat = randomForestTestDat)

dat <- randomForestTestDat %>% select(-ID) %>% unique() %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, group)
set.seed(101)
randomNum <- runif(n = nrow(dat), min = 0, max = 1)

dat$random <- randomNum
dat2 <- dat %>% mutate(group = ifelse(group == "Positive Control", 1, 0)) #%>% select(-na_count)

dat2$group <- as.factor(dat2$group) 

dat2[is.na(dat2)] <- 0

# dat2 <- dat2 %>% select(-cov.count, -cov.combined.score)

colGroupNum <- match(x = "group", table = colnames(dat2))

data_set_size <- floor(nrow(dat2)/2)
indexes <- sample(1:nrow(dat2), size = data_set_size)


training <- dat2[indexes,]
validation1 <- dat2[-indexes,]
save(indexes, file = "~/bin/r_git/R/r_files/indexes.Rda")

save(training, file = "~/bin/r_git/R/r_files/training.Rda")
save(validation1, file = "~/bin/r_git/R/r_files/validation1.Rda")

rf_classifier = randomForest(group ~ ., data=training, ntree=100, importance=TRUE)
rf_classifier
save(rf_classifier, file = "~/bin/r_git/R/r_files/rf_classifier.Rda")
```

###random_forest

```{r random_forest, eval = T}
load("~/bin/r_git/R/r_files/rf_classifier.Rda")
load("~/bin/r_git/R/r_files/training.Rda")
load("~/bin/r_git/R/r_files/validation1.Rda")
load("~/bin/r_git/R/r_files/randomForestDatAll.Rda")

dat <- randomForestTestDat %>% select(-ID) %>% unique() %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, group)

set.seed(101)
randomNum <- runif(n = nrow(dat), min = 0, max = 1)

dat$random <- randomNum
varImpPlot(rf_classifier)
colGroupNum <- match(x = "group", table = colnames(validation1))
# Make predictions
prediction_for_table <- predict(rf_classifier,validation1[,-colGroupNum])
table(observed=validation1[,colGroupNum],predicted=prediction_for_table)


write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/random_forest_3.svg",
     width=20,
     height=20,
     pointsize=12)
varImpPlot(rf_classifier)


dev.off()
}

```

###random_forest_roc

```{r random_forest_roc, eval=F, echo=F}
load("~/bin/r_git/R/r_files/rf_classifier.Rda")
load("~/bin/r_git/R/r_files/training.Rda")
load("~/bin/r_git/R/r_files/validation1.Rda")
colGroupNum <- match(x = "group", table = colnames(validation1))

prediction_for_roc_curve <- predict(rf_classifier,validation1[,-colGroupNum],type="prob")



validation1$prob <- prediction_for_roc_curve[,2]
validation_roc <- validation1 %>% select(group, prob) %>% mutate(pred = ifelse(prob > 0.06, 1, 0))
table(observed=validation_roc$group,predicted=validation_roc$pred)
roc.curve(response = validation_roc$group, predicted = validation_roc$prob,
          main="ROC curve for MFE")
library(ROCR)
pred <- prediction( validation_roc$prob, validation_roc$group)
perf <- performance(pred,"tpr","fpr")
plot(perf)
str(perf)

cutoffs <- data.frame(cut=perf@alpha.values[[1]], fpr=perf@x.values[[1]], 
                      tpr=perf@y.values[[1]])

```

###random_forest_predicted_data

```{r random_forsest_predicted_data, eval=T}
replaceNAs <- function(dat){
  
dat$mfe.score[is.na(dat$mfe.score)] <- 0
dat$gc.score[is.na(dat$gc.score)] <- 50
dat$distance[is.na(dat$distance)] <- 0
dat$reads.mean.score[is.na(dat$reads.mean.score)] <- 0
dat$read.max.score[is.na(dat$read.max.score)] <- 0
dat$cov.mean.score[is.na(dat$cov.mean.score)] <- 0
dat$cov.min.eval[is.na(dat$cov.min.eval)] <- 10
# dat$cov.combined.score[is.na(dat$cov.combined.score)] <- 0
dat$cov.count[is.na(dat$cov.count)] <- 1
dat$motif.mean.score[is.na(dat$motif.mean.score)] <- 0
dat$motif.max.score[is.na(dat$motif.max.score)] <- 0
dat$z_mean[is.na(dat$z_mean)] <- 10
dat$z_max[is.na(dat$z_max)] <- 10
# dat$alifold.score[is.na(dat$alifold.score)] <- 0
dat$alifold_cov_score[is.na(dat$alifold_cov_score)] <- 0
# dat$alifold_cov_score[dat$alifold_cov_score > 0] <- 0
return(dat)
}

load("~/bin/r_git/R/r_files/rf_classifier.Rda")
load("~/bin/r_git/R/r_files/randomForestDat.Rda")
load("~/bin/r_git/R/r_files/randomForestDatAll.Rda")
load("~/bin/r_git/R/r_files/randomForestTestDat.Rda")
load("~/bin/r_git/R/r_files/validation1.Rda")
load("~/bin/r_git/R/r_files/indexes.Rda")



validation1 <- randomForestTestDat[-indexes,]
validation1 <- replaceNAs(dat = validation1)

validation1 <- validation1 %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, group, ID)

set.seed(101)
randomNum <- runif(n = nrow(validation1), min = 0, max = 1)

validation1$random <- randomNum

colGroupNum <- match(x = "group", table = colnames(validation1))
colIDNum <- match(x = "ID", table = colnames(validation1))



prediction_for_roc_curve <- predict(rf_classifier,validation1[,-c(colIDNum, colGroupNum)],type="prob")
validation1$probability <- prediction_for_roc_curve[,2]


known_predicted <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/known_predicted_models_list.txt")

known_predicted <- known_predicted %>% group_by(V2) %>% summarise(srna.counts.2 = n()) %>% mutate(pred = T) %>% dplyr::rename(ID = V2)

validation1 <- validation1 %>% left_join(known_predicted, by = "ID")
validation1 <- validation1 %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, srna.counts.2, group, ID, random, probability)


# known_predictedOri <- known_predicted
known_predicted <- known_predicted 
known_predicted <-  randomForestDat  %>% left_join(known_predicted, by = "ID") %>% filter(!is.na(pred)) %>% select(-pred) %>% mutate(group = "Predicted Known") 

dat <- randomForestDatAll %>% select(-ID) %>% unique() %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, group)
datAll <- randomForestDatAll %>% select(-ID) %>% unique() %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, group)
set.seed(101)
randomNum <- runif(n = nrow(dat), min = 0, max = 1)
randomNumAll <- runif(n = nrow(datAll), min = 0, max = 1)

dat$random <- randomNum
datAll$random <- randomNumAll

colGroupNum <- match(x = "group", table = colnames(dat))
colGroupNumAll <- match(x = "group", table = colnames(datAll))
# colCountNum <- match(x = "srna.counts.2", table = colnames(dat))

prediction_randomForestDat <- predict(rf_classifier,dat[,-c(colGroupNum)],type="prob")
prediction_randomForestDatAll <- predict(rf_classifier,datAll[,-c(colGroupNum)],type="prob")
dat$probability <- prediction_randomForestDat[,2]
datAll$probability <- prediction_randomForestDatAll[,2]

load("~/bin/r_git/R/r_files/max_dists_pred.Rda")

max_dists_pred <- max_dists_pred %>% dplyr::rename(ID = id) %>% select(ID, distance)



load("~/bin/r_git/R/r_files/predRDepth.Rda")

predRDepthMaxs <- predRDepth %>% dplyr::rename(ID = srna) %>% group_by(ID) %>% summarise(read.max.score  = sum(max.val))
predDepthMeans <- predRDepth %>% dplyr::rename(ID = srna) %>% group_by(ID) %>% summarise(reads.mean.score  = sum(mean.val))
predRDepth <- predRDepthMaxs %>% full_join(predDepthMeans, by = "ID") %>%  filter(read.max.score > 0)

load("~/bin/r_git/R/r_files/predCovariation.Rda") ##pcCovRNA

predCovRNA <- predCovRNA %>% filter(!is.na(mean_score)) %>% mutate(combined_score = count * mean_score) %>% 
  dplyr::rename(cov.mean.score = mean_score, cov.min.eval = min_eval, cov.count = count, cov.combined.score = combined_score)




load("~/bin/r_git/R/r_files/predGC.Rda")

predGC <- predGC %>% dplyr::rename(gc.score = gc.percent) %>% select(ID, gc.score)

load("~/bin/r_git/R/r_files/predAlifold_v2.Rda")

predAlifold <- predAlifold %>% separate(col = ID, into = c("t1", "id"), sep = "_", extra = "merge")  %>% select(-t1, -STDV) %>% dplyr::rename(ID = id) %>% filter(!is.na(ID))


load("~/bin/r_git/R/r_files/predMFE.Rda")

predMFE <- predMFE %>% dplyr::rename(ID = V1, mfe.score = V2) %>% select(ID, mfe.score)





load("~/bin/r_git/R/r_files/predMotif.Rda")

predMotif <- predMotif %>% separate(col = ID, into = c("t1", "id"), sep = "_", extra = "merge") %>% select(-t1) %>% separate(col = id, into = c("t1", "t2"), sep = "\\.", extra = "drop")  %>% mutate(ID = paste(t1, t2, sep = ".")) %>% 
  dplyr::rename(motif.mean.score = mean_score, motif.max.score = max_score) %>% select(-t1, -t2)

load("~/bin/r_git/R/r_files/predAlifoldScore.Rda")

load("~/bin/r_git/R/r_files/predCovAli.Rda")

predCovAli <- predCovAli %>% select(ID, alifold_cov_score)


predSRNACounts <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_snra_counts.txt")

colnames(predSRNACounts) <- c("srna.counts", "ID")

# predMFE <- predMFE %>% left_join(predRDepth, by = "ID")

predDat <- predMFE %>% 
  full_join(predGC, by = "ID") %>% 
  full_join(max_dists_pred, by = "ID") %>% 
  full_join(predRDepth, by = "ID") %>%
  full_join(predCovRNA, by = "ID") %>% 
  full_join(predMotif, by = "ID")%>% 
  full_join(predAlifold, by = "ID") %>% 
  full_join(predCovAli, by = "ID") %>% 
  full_join(predAlifoldScore, by = "ID") %>% 
  full_join(predSRNACounts, by = "ID") %>% 
  select(-cov.combined.score)  %>% unique() %>% 
  filter(!is.na(read.max.score), !is.na(mfe.score)) %>%
  mutate(group = "Predicted")


redundacy_counts_pred <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_counts.txt")
redundacy_counts_nc <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_counts.txt")

colnames(redundacy_counts_pred) <- c("srna.counts.2", "ID")
colnames(redundacy_counts_nc) <- c("srna.counts.3", "ID")

predDat <- predDat %>% left_join(redundacy_counts_pred, by = "ID")

validation1 <- validation1 %>% left_join(redundacy_counts_nc, by = "ID")
validation1 <- validation1 %>% mutate(srna.counts.2 = ifelse(is.na(srna.counts.2), srna.counts.3, srna.counts.2))


predDat <- predDat %>% mutate(alifold_cov_score = as.numeric(alifold_cov_score)) %>% bind_rows(known_predicted) %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, srna.counts.2, group, ID)


set.seed(101)
randomNum <- runif(n = nrow(predDat), min = 0, max = 1)

predDat$random <- randomNum



predDat$mfe.score[is.na(predDat$mfe.score)] <- 0
predDat$gc.score[is.na(predDat$gc.score)] <- 50
predDat$distance[is.na(predDat$distance)] <- 0
# predDat$reads.mean.score[is.na(predDat$reads.mean.score)] <- 0
predDat$read.max.score[is.na(predDat$read.max.score)] <- 0
# predDat$cov.mean.score[is.na(predDat$cov.mean.score)] <- 0
predDat$cov.min.eval[is.na(predDat$cov.min.eval)] <- 10
# predDat$cov.combined.score[is.na(predDat$cov.combined.score)] <- 0
# predDat$cov.count[is.na(predDat$cov.count)] <- 0
# predDat$motif.mean.score[is.na(predDat$motif.mean.score)] <- 0
predDat$motif.max.score[is.na(predDat$motif.max.score)] <- 0
# predDat$z_mean[is.na(predDat$z_mean)] <- 10
predDat$z_max[is.na(predDat$z_max)] <- 10
# predDat$alifold.score[is.na(predDat$alifold.score)] <- 10
predDat$alifold_cov_score[is.na(predDat$alifold_cov_score)] <- 0
predDat$srna.counts[is.na(predDat$srna.counts)] <- 1

colGroupNum <- match(x = "group", table = colnames(predDat))
colIDNum <- match(x = "ID", table = colnames(predDat))
colCountNum <- match(x = "srna.counts.2", table = colnames(predDat))


prediction_for_predcited_data <- predict(rf_classifier,predDat[,-c(colIDNum, colGroupNum, colCountNum)], type = 'response')
prob_for_predcited_data <- predict(rf_classifier,predDat[,-c(colIDNum, colGroupNum, colCountNum)], type = 'prob')

predDat$probability <- prob_for_predcited_data[,2]

load("~/bin/r_git/R/r_files/predRNAcode_v2.Rda")
predRNAcode <- predRNAcode %>% select(srna, score, p.value) %>% dplyr::rename(ID = srna) %>% group_by(ID) %>%
  summarise(p.value = min(p.value))

predDat <- predDat %>% full_join(predRNAcode, by = "ID")

predDat$p.value[is.na(predDat$p.value)] <- 1


save(predDat, file="~/bin/r_git/R/r_files/predDat.Rda")
load("~/bin/r_git/R/r_files/predDat.Rda")

randomForestDatAll <- randomForestDatAll %>% mutate(p.value = 1)

featuresSelected <- randomForestDatAll %>% unique() %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, group, p.value)

featuresSelected <- predDat %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, group, p.value) %>% bind_rows(featuresSelected) %>% 
  filter(!is.na(group))

save(featuresSelected, file="~/bin/r_git/R/r_files/featuresSelected.Rda")
load("~/bin/r_git/R/r_files/featuresSelected.Rda")

# redundacy_counts_pc <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/alignments_rnaalifold/positive_control_counts.txt")

# colnames(redundacy_counts_pc) <- c("srna.counts", "ID")

# validation1 <- validation1 %>% left_join(redundacy_counts_pc, by = "ID")

validatation2 <- validation1
save(validatation2, file="~/bin/r_git/R/r_files/validatation2.Rda")
load("~/bin/r_git/R/r_files/validatation2.Rda")

load("~/bin/r_git/R/r_files/randomForestClassified.Rda")




predCounts <- predDat %>% filter(group == "Predicted") %>% group_by(probability) %>% summarise(count = sum(srna.counts.2, na.rm = T)) %>% arrange(probability) %>% ungroup()  %>% mutate(num = as.integer(probability*100)) %>% tidyr::complete(num = seq(from = 0, to = 100, by = 1), fill = list(count = 0)) %>% mutate(probability = num/100) %>% select(-num)


pcAllCounts <- datAll %>% filter(group == "Positive Control")  %>% group_by(probability) %>% summarise(count = n()) %>% arrange(probability) %>% ungroup()  %>% mutate(num = as.integer(probability*100)) %>% tidyr::complete(num = seq(from = 0, to = 100, by = 1), fill = list(count = 0)) %>% mutate(probability = num/100) %>% select(-num)


pcCounts <- validatation2 %>% filter(group == "Positive Control")  %>% group_by(probability) %>% summarise(count = n()) %>% arrange(probability) %>% ungroup()  %>% mutate(num = as.integer(probability*100)) %>% tidyr::complete(num = seq(from = 0, to = 100, by = 1), fill = list(count = 0)) %>% mutate(probability = num/100) %>% select(-num) %>% filter(!is.na(probability))

ncCounts <- validatation2 %>% filter(group == "Negative Control")  %>% group_by(probability) %>% summarise(count = sum(srna.counts.2, na.rm = T)) %>% arrange(probability) %>% ungroup()  %>% mutate(num = as.integer(probability*100)) %>% tidyr::complete(num = seq(from = 0, to = 100, by = 1), fill = list(count = 0)) %>% mutate(probability = num/100) %>% select(-num)%>% filter(!is.na(probability))

ncTotal <- validatation2 %>% filter(group == "Negative Control") %>% nrow()
pcTotal <- randomForestClassified %>% filter(group == "Positive Control") %>% nrow()
predTotal <- predDat %>% nrow()

ncSig <- validatation2 %>% filter(group == "Negative Control", probability > 0.15)   %>% nrow()
pcSig <- randomForestClassified %>% filter(group == "Positive Control", probability > 0.15)   %>% nrow()
predSig <- predDat %>% filter(group == "Predicted", probability > 0.15)   %>% nrow()

ncSigHalf <- validatation2 %>% filter(group == 0, probability > 0.5)   %>% nrow()
pcSigHalf <- randomForestClassified %>% filter(group == "Positive Control", probability > 0.5)   %>% nrow()
predSigHalf <- predDat %>% filter(group == "Predicted", probability > 0.5) %>% nrow()


ncSig/ncTotal
pcSig/pcTotal
predSig/predTotal

ncSigHalf/ncTotal
pcSigHalf/pcTotal
predSigHalf/predTotal

TSPred <- zoo::zoo(predCounts$count)
TSPC <- zoo::zoo(pcCounts$count)
TSPCall <- zoo::zoo(pcAllCounts$count)
TSNC <- zoo::zoo(ncCounts$count)



smoothPred <- zoo::rollapply(TSPred, width = 10, by = 1, FUN = mean, align = "center", partial = T) ##these values might need to be changed
smoothPC <- zoo::rollapply(TSPC, width = 10, by = 1, FUN = mean, align = "center", partial = T) ##these values might need to be changed
smoothPCall <- zoo::rollapply(TSPCall, width = 10, by = 1, FUN = mean, align = "center", partial = T) ##these values might need to be changed

smoothNC <- zoo::rollapply(TSNC, width = 10, by = 1, FUN = mean, align = "center", partial = T) ##these values might need to be changed

predTotal <- sum(predDat$srna.counts.2[predDat$group == "Predicted"], na.rm = T)
# pcTotal <- sum(validation1$srna.counts.2[validation1$group == "Positive Control"], na.rm = T)
# ncTotal <- sum(validation1$srna.counts.2[validation1$group == "Negative Control"], na.rm = T)

pcTotal <- validatation2 %>% filter(group == "Positive Control") %>% nrow()
ncTotal <- validatation2 %>% filter(group == "Negative Control") %>% nrow()
pcAllTotal <- datAll %>% filter(group == "Positive Control") %>% nrow()
# predTotal <- validation1 %>% filter(group == "Positive Control") %>% nrow()

smoothPred <- as.data.frame(smoothPred)
smoothPC <- as.data.frame(smoothPC)
smoothPCall <- as.data.frame(smoothPCall)
smoothNC <- as.data.frame(smoothNC)

smoothPred <- smoothPred %>% mutate(x = row_number() -1) %>% mutate(group = "Predicted") %>% dplyr::rename(y = smoothPred) %>% mutate(y = y/predTotal)
smoothPC <- smoothPC %>% mutate(x = row_number() -1) %>% mutate(group = "Positive Control") %>% dplyr::rename(y = smoothPC) %>% mutate(y = y/pcTotal)
smoothPCall <- smoothPCall %>% mutate(x = row_number() -1) %>% mutate(group = "Positive Control (Rfam)") %>% dplyr::rename(y = smoothPCall) %>% mutate(y = y/pcAllTotal)

smoothNC <- smoothNC %>% mutate(x = row_number() -1) %>% mutate(group = "Negative Control") %>% dplyr::rename(y = smoothNC) %>% mutate(y = y/ncTotal)

smoothDat <- smoothPred %>% bind_rows(smoothPC, smoothNC)

smoothDat$y[smoothDat$y == 0] <- min(smoothDat$y[smoothDat$y != 0])

smoothDat$y[smoothDat$y < 0.0010893246] <- 0.0010893246


randomForestDistribution <- smoothDat

save(randomForestDistribution, file = "~/bin/r_git/R/r_files/randomForestDistribution.Rda")

load("~/bin/r_git/R/r_files/randomForestDistribution.Rda")




p <- ggplot() +
  geom_path(data = randomForestDistribution, aes(x = x, y = y, group = group, color = group))  +
  scale_y_continuous(trans = 'log10')

p

p <- ggplot() +
  geom_path(data = smoothDat, aes(x = x, y = y, group = group, color = group)) +
  scale_y_continuous(trans = 'log10')

p

# p <- ggplot() +
#   geom_freqpoly(data = allDat, aes(x = probability, y = ..count.., group = group, color = group), binwidth = 0.01) +
#   xlim(min = 0, max = 1) 
# p

write_data <- F
if(write_data){
ggsave(filename = "~/phd/RNASeq/figures/probabilites_rf_log.svg", plot = p)
}
# 
# predDat2 <- predMFE %>% 
#   full_join(predGC, by = "ID") %>% 
#   full_join(max_dists_pred, by = "ID") %>% 
#   full_join(predRDepth, by = "ID") %>% 
#   full_join(predCovRNA, by = "ID") %>% 
#   full_join(predMotif, by = "ID")%>% 
#   full_join(predAlifold, by = "ID") %>% 
#   full_join(predCovAli, by = "ID") %>% 
#   full_join(predAlifoldScore, by = "ID") %>% 
#   mutate(group = "Predicted")
# 
# 
# 
# predDat2 <- predDat2  %>% select(-cov.combined.score)  %>% unique() 
# 
# 
# allData <- randomForestDat %>%  bind_rows(predDat2)
# 


```


#Results 


***

##Distributions

```{r cumulative_distributions, eval=T}
load("~/bin/r_git/R/r_files/featuresSelected.Rda")

load("~/bin/r_git/R/r_files/ncRDepth.Rda")
ncRDepthMaxs <- ncRDepth %>% dplyr::rename(ID = srna) %>% group_by(ID) %>% summarise(read.max.score  = sum(max.val))
ncRDepthMeans <- ncRDepth %>% dplyr::rename(ID = srna) %>% group_by(ID) %>% summarise(reads.mean.score  = sum(mean.val))
ncRDepth <- ncRDepthMaxs %>% full_join(ncRDepthMeans, by = "ID") %>% mutate(group = "Negative Control") %>% select(group, read.max.score)

ncSRNACounts <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_snra_counts.txt")
colnames(ncSRNACounts) <- c("srna.counts", "ID")

ncSRNACounts <- ncSRNACounts %>% mutate(group = "Negative Control") %>% select(group, srna.counts)

cumulativeDistribution <- function(dat, run.ks.test = T, alternative_pred, alternative_pc, alternative = 'two.sided', show.legend = F){
  
  if(missing('alternative_pred')){alternative_pred <- alternative}
  if(missing('alternative_pc')){alternative_pc <- alternative}

distsCumulativeCount <- cumulativeCounts(dists = dat, smooth = F)

distsCumulativeCount <- distsCumulativeCount %>% filter(group != "Predicted Known")


# dists_cum_count <- distsCumulativeCount
# save(dists_cum_count, file = "~/bin/r_git/R/r_files/dists_cum_count.Rda")

p <- ggplot() +
  geom_line(data = distsCumulativeCount, aes(x= max_dist, y = cumulative_prop, group = group, colour = group), size = 2, show.legend = show.legend) + theme_classic() 

pos <- dat %>% filter(group == "Positive Control")
neg <- dat %>% filter(group == "Negative Control")
pred <- dat %>% filter(group == "Predicted")


if(run.ks.test == T){
res <- ks.test(x = pred$max_dist, y = neg$max_dist, alternative = alternative_pred)

print(res)


res <- ks.test(x = pos$max_dist, y = neg$max_dist, alternative = alternative_pc)

print(res)

}
return(p)
}

colnames(featuresSelected)

dat <- featuresSelected %>% dplyr::rename(max_dist = distance)
distance.p <- cumulativeDistribution(dat, alternative = "two.sided")
distance.p <- distance.p +
   labs(y = "Cumulative Proportion", x = "Evolutionary distance")
    # distance.p

dat <- featuresSelected %>% select(group, read.max.score) %>% filter(group != "Negative Control") %>% bind_rows(ncRDepth) %>% dplyr::rename(max_dist = read.max.score) %>% filter(max_dist < 100000)
reads.p <- cumulativeDistribution(dat, alternative = 'two.sided') 
reads.p <- reads.p +
   labs(y = "Cumulative Proportion", x = "Total reads")

dat <- featuresSelected %>% mutate(max_dist = -log(cov.min.eval)) %>% mutate(max_dist = ifelse(max_dist < 0, 0, max_dist))
rscape.p <- cumulativeDistribution(dat)
rscape.p <- rscape.p +
   labs(y = "Cumulative Proportion", x = "Rscape covariance score")
# rscape.p

dat <- featuresSelected %>% mutate(max_dist = ifelse(z_max == 10, -3, -z_max))
z.p <- cumulativeDistribution(dat)
z.p <- z.p +
   labs(y = "Cumulative Proportion", x = "Alifold z-score (negative energy)")
# z.p

dat <- featuresSelected %>% dplyr::rename(max_dist = motif.max.score)
motif.p <- cumulativeDistribution(dat)
motif.p <- motif.p +
   labs(y = "Cumulative Proportion", x = "Motif score")

dat <- featuresSelected %>% mutate(max_dist = -alifold_cov_score)
alifold.cov.p <- cumulativeDistribution(dat)
alifold.cov.p <- alifold.cov.p +
   labs(y = "Cumulative Proportion", x = "Alifold covariance score")

dat <- featuresSelected %>% mutate(max_dist = -mfe.score)
mfe.p <- cumulativeDistribution(dat, alternative = 'two.sided')
mfe.p <- mfe.p +
   labs(y = "Cumulative Proportion", x = "MFE score (negative energy)")



dat <- featuresSelected %>% select(group, srna.counts) %>%  dplyr::rename(max_dist = srna.counts) %>% filter(max_dist < 500)
counts.p <- cumulativeDistribution(dat, alternative = 'two.sided')
counts.p <- counts.p +
   labs(y = "Cumulative Proportion", x = "Number of sequences in alignments")




dat <- featuresSelected %>% filter(group != "Predicted Known") %>% arrange(gc.score) %>% mutate(gc.score = round(gc.score))

predCounts <- dat %>% filter(group == "Predicted") %>% group_by(gc.score) %>% summarise(count = n()) %>% arrange(gc.score) %>% ungroup() %>% tidyr::complete(gc.score = seq(from = 0, to = 100, by = 1), fill = list(count = 0)) 
pcCounts <- dat %>% filter(group == "Positive Control") %>% group_by(gc.score) %>% summarise(count = n()) %>% arrange(gc.score) %>% ungroup() %>% tidyr::complete(gc.score = seq(from = 0, to = 100, by = 1), fill = list(count = 0)) 
ncCounts <- dat %>% filter(group == "Negative Control") %>% group_by(gc.score) %>% summarise(count = n()) %>% arrange(gc.score) %>% ungroup() %>% tidyr::complete(gc.score = seq(from = 0, to = 100, by = 1), fill = list(count = 0)) 

pcTotal <- dat %>% filter(group == "Positive Control") %>% nrow()
ncTotal <- dat %>% filter(group == "Negative Control") %>% nrow()
predTotal <- dat %>% filter(group == "Predicted") %>% nrow()

pcGC <- zoo::zoo(pcCounts$count)
ncGC <- zoo::zoo(ncCounts$count)
predGC <- zoo::zoo(predCounts$count)

smoothPC <- zoo::rollapply(pcGC, width = 10, by = 1, FUN = mean, align = "center", partial = T) ##these values might need to be changed
smoothNC <- zoo::rollapply(ncGC, width = 10, by = 1, FUN = mean, align = "center", partial = T) ##these values might need to be changed
smoothPred <- zoo::rollapply(predGC, width = 10, by = 1, FUN = mean, align = "center", partial = T) ##these values might need to be changed

smoothPC <- as.data.frame(smoothPC) %>% mutate(x = row_number() -1) %>% mutate(group = "Positive Control") %>% dplyr::rename(y = smoothPC) %>% mutate(y = y/pcTotal)

smoothNC <- as.data.frame(smoothNC) %>% mutate(x = row_number() -1) %>% mutate(group = "Negative Control") %>% dplyr::rename(y = smoothNC) %>% mutate(y = y/ncTotal)

smoothPred <- as.data.frame(smoothPred) %>% mutate(x = row_number() -1) %>% mutate(group = "Predicted") %>% dplyr::rename(y = smoothPred) %>% mutate(y = y/predTotal)

smoothGC <- smoothPC %>%  bind_rows(smoothNC, smoothPred)

gc.p <- ggplot() +
  geom_path(data = smoothGC, aes(x = x, y = y, group = group, color = group), size = 2, show.legend = FALSE)  + labs(y = "Proportion", x = "GC percentage")  + theme_classic() 


gc.p


pos <- dat %>% filter(group == "Positive Control")
neg <- dat %>% filter(group == "Negative Control")
pred <- dat %>% filter(group == "Predicted")

res <- ks.test(x = pred$gc.score, y = neg$gc.score, alternative = 'less')

print(res)

res <- ks.test(x = pos$gc.score, y = neg$gc.score, alternative = 'two.sided')

print(res)

all.p <- ggarrange(distance.p, reads.p, mfe.p, z.p, rscape.p, alifold.cov.p, counts.p,  motif.p, gc.p + rremove("x.text"),  
          labels = LETTERS[1:9],
          ncol = 3, nrow = 3)



run_all <- F
if(run_all){
ggsave(filename = "~/phd/RNASeq/figures/all_distributions.svg", plot = all.p, width = 450, height = 307, units = "mm")

  
  # ggsave(filename = "~/phd/RNASeq/figures/distance.svg", plot = distance.p)
# ggsave(filename = "~/phd/RNASeq/figures/reads.svg", plot = reads.p)
# ggsave(filename = "~/phd/RNASeq/figures/mfe.svg", plot = mfe.p)
# ggsave(filename = "~/phd/RNASeq/figures/z_score.svg", plot = z.p)
# ggsave(filename = "~/phd/RNASeq/figures/rscape.svg", plot = rscape.p)
# ggsave(filename = "~/phd/RNASeq/figures/gc.svg", plot = gc.p)
# ggsave(filename = "~/phd/RNASeq/figures/counts.svg", plot = counts.p)
# ggsave(filename = "~/phd/RNASeq/figures/motif.svg", plot = motif.p)
# ggsave(filename = "~/phd/RNASeq/figures/alifold_cov.svg", plot = alifold.cov.p)
}

```

```{r precision_and_sensitivity, eval=F}
load("~/bin/r_git/R/r_files/featuresSelected.Rda")

load("~/bin/r_git/R/r_files/ncRDepth.Rda")
ncRDepthMaxs <- ncRDepth %>% dplyr::rename(ID = srna) %>% group_by(ID) %>% summarise(read.max.score  = sum(max.val))
ncRDepthMeans <- ncRDepth %>% dplyr::rename(ID = srna) %>% group_by(ID) %>% summarise(reads.mean.score  = sum(mean.val))
ncRDepth <- ncRDepthMaxs %>% full_join(ncRDepthMeans, by = "ID") %>% mutate(group = "Negative Control") %>% select(group, read.max.score)

ncSRNACounts <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_snra_counts.txt")
colnames(ncSRNACounts) <- c("srna.counts", "ID")

ncSRNACounts <- ncSRNACounts %>% mutate(group = "Negative Control") %>% select(group, srna.counts)

load("~/bin/r_git/R/r_files/rf_classifier.Rda")
load("~/bin/r_git/R/r_files/randomForestDat.Rda")
load("~/bin/r_git/R/r_files/randomForestDatAll.Rda")
load("~/bin/r_git/R/r_files/validatation2.Rda")
load("~/bin/r_git/R/r_files/indexes.Rda")

validatation1 <- validatation2


known_predicted <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/known_predicted_models_list.txt")

known_predicted <- known_predicted %>% group_by(V2) %>% summarise(srna.counts.2 = n()) %>% mutate(pred = T) %>% dplyr::rename(ID = V2)

validation1 <- validatation1 %>% left_join(known_predicted, by = "ID")
validation1 <- validation1 %>% mutate(p.value = 1) %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, group, ID, random, probability, p.value)


load("~/bin/r_git/R/r_files/predDat.Rda")

predDat <- predDat %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, srna.counts.2, group, ID, random, probability, p.value)

probDat <- validation1 %>% bind_rows(predDat)

ggplot() + 
  geom_freqpoly(data = probDat, aes(x = probability, y = ..density.., group = group, color = group), binwidth = 0.01)

load("~/bin/r_git/R/r_files/featuresSelected.Rda")

set.seed(101)
randomNum <- runif(n = nrow(featuresSelected), min = 0, max = 1)

featuresSelected$random <- randomNum

colGroupNum <- match(x = "group", table = colnames(featuresSelected))
# colIDNum <- match(x = "ID", table = colnames(featuresSelected))


prediction_for_roc_curve <- predict(rf_classifier,featuresSelected[,-c(colGroupNum)],type="prob")
featuresSelected$probability <- prediction_for_roc_curve[,2]

colnames(featuresSelected)
colnames(randomForestDatAll)

set.seed(101)
randomNum <- runif(n = nrow(randomForestDatAll), min = 0, max = 1)

randomForestDatAll$random <- randomNum

randomForestDatAll <- randomForestDatAll %>% select(read.max.score, distance, cov.min.eval, z_max, motif.max.score, alifold_cov_score, mfe.score, gc.score, srna.counts, group, ID, random)

colGroupNum <- match(x = "group", table = colnames(randomForestDatAll))
colIDNum <- match(x = "ID", table = colnames(randomForestDatAll))


prediction_for_roc_curve <- predict(rf_classifier,randomForestDatAll[,-c(colGroupNum, colIDNum)],type="prob")
randomForestDatAll$probability <- prediction_for_roc_curve[,2]

randomForestClassified <- randomForestDatAll
save(randomForestClassified, file = "~/bin/r_git/R/r_files/randomForestClassified.Rda")


score_summary <- function(dat = featuresSelected, cuttoff, column){
  colVal <- match(column, colnames(dat))
  tmpPos <- dat[dat[,colVal] > cuttoff,]
  tmpNeg <- dat[dat[,colVal] <= cuttoff,]
  tmpPos <- tmpPos %>% filter(!is.na(group))
  tmpNeg <- tmpNeg %>% filter(!is.na(group))

pos_distance <- tmpPos %>% group_by(group) %>% summarise(pos.count = n())
neg_distance <- tmpNeg %>% group_by(group) %>% summarise(pos.count = n())

pos_distance
neg_distance

TP <- pos_distance$pos.count[pos_distance$group == "Positive Control"]
FP <- pos_distance$pos.count[pos_distance$group == "Negative Control"]

FN <- neg_distance$pos.count[neg_distance$group == "Positive Control"]
TN <- neg_distance$pos.count[neg_distance$group == "Negative Control"]
  
predPos <- pos_distance$pos.count[pos_distance$group == "Predicted"]
predNeg <- neg_distance$pos.count[neg_distance$group == "Predicted"]


print(paste("Precision:", round(TP/(TP+FP), 3))) #pres

print(paste("Sensitivity:", round(TP/(TP + FN), 3))) #sens TPR

print(paste("Predicted (as positive):", round(predPos/(predPos + predNeg), 3), predPos, predNeg)) #pred

print(paste("FPR:", round(FP/(FP + TN), 3))) #FPR

}
colnames(featuresSelected)

featuresSelected <- featuresSelected %>% filter(p.value > 0.05)

score_summary(cuttoff = 0.186786, column = "distance")
score_summary(cuttoff = 100, column = "read.max.score")
score_summary(cuttoff = 10, column = "srna.counts")
score_summary(cuttoff = 3.5, column = "z_max", dat = featuresSelected %>% mutate(z_max  =-z_max))

score_summary(cuttoff = 0.2, column = "probability", dat = randomForestDatAll)
score_summary(cuttoff = 0.2, column = "probability", dat = featuresSelected)
score_summary(cuttoff = 0.2, column = "probability", dat = validatation2)
score_summary(cuttoff = 0.5, column = "probability")
score_summary(cuttoff = 0.8, column = "probability")

novel_rufs <- probDat %>% filter(group == "Predicted", probability >= 0.2, probability <= 0.8)
known_rufs <- probDat %>% filter(group == "Predicted", probability > 0.8)
noise_rufs <- probDat %>% filter(group == "Predicted", probability < 0.2)

novelCount <- nrow(novel_rufs)
knownCount <- nrow(known_rufs)
noiseCount <- nrow(noise_rufs)
allCount <- probDat %>% filter(group == "Predicted") %>% nrow()


novelCount/allCount
knownCount/allCount
noiseCount/allCount

save(novel_rufs, file = "~/bin/r_git/R/r_files/novel_rufs.Rda")
save(known_rufs, file = "~/bin/r_git/R/r_files/known_rufs.Rda")
save(noise_rufs, file = "~/bin/r_git/R/r_files/noise_rufs.Rda")

pos_distance <- probDat %>% filter(probability > 0.5) %>% group_by(group) %>% summarise(pos.count = n())
neg_distance <- probDat %>% filter(probability <= 0.5) %>% group_by(group) %>% summarise(pos.count = n())

pos_distance
neg_distance
354/(354+24) #pres

354/(354 + 10) #sens TPR

1447/(1447 + 2602) #pred

24/(24 + 625)


pos_distance <- probDat %>% filter(probability > 0.8) %>% group_by(group) %>% summarise(pos.count = n())
neg_distance <- probDat %>% filter(probability <= 0.8) %>% group_by(group) %>% summarise(pos.count = n())

pos_distance
neg_distance
300/(300+5) #pres

300/(300 + 64) #sens TPR

287/(287 + 3762) #pred

5/(5 + 645)






featuresSelected %>% filter(probability > 0.8, group == "Predicted") %>% nrow()

featuresSelected %>% filter(probability > 0.8, group == "Predicted", p.value > 0.05) %>% nrow()


```




##ROC


###Distance ROC

```{r conservation_distance_roc_curve, eval = T}
load( file = "~/bin/r_git/R/r_files/max_dists_pred.Rda")
load(file = "~/bin/r_git/R/r_files/max_dists_pc.Rda")
load(file = "~/bin/r_git/R/r_files/max_dists_nc.Rda")

pc_keep <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_keep_list.txt")

pc_keep <- pc_keep %>% dplyr::rename(ID = V1) %>% mutate(keep = T)

max_dists_pc <- max_dists_pc %>% separate(col = id, into = c("ID", "t2"), sep = "\\.")  %>% select(-t2)  %>% left_join(pc_keep, by = "ID") %>% filter(!is.na(keep)) %>% select(-keep)

nc_keep <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_keep_list.txt")

nc_keep <- nc_keep %>% dplyr::rename(ID = V1) %>% mutate(keep = T)

max_dists_nc <- max_dists_nc %>% separate(col = id, into = c("t1", "ID"), sep = "_", extra = "merge")  %>% select(-t1)  %>% left_join(nc_keep, by = "ID") %>% filter(!is.na(keep)) %>% select(-keep)

not_nc <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/not_negative_control_ids.txt")

not_nc <- not_nc %>% mutate(remove = T) %>% dplyr::rename(ID = V1)

max_dists_nc <- max_dists_nc %>% left_join(not_nc, by = "ID") %>%  filter(is.na(remove)) %>% select(-remove)

max_dists_pred <- max_dists_pred %>% mutate(group = "Predicted")
max_dists_pc <- max_dists_pc %>% dplyr::rename(id = ID) %>% mutate(group = "Positive Control")
max_dists_nc <- max_dists_nc %>% dplyr::rename(id = ID) %>% mutate(group = "Negative Control")


dists <- max_dists_pred %>% bind_rows(max_dists_pc, max_dists_nc) %>% dplyr::rename(max_dist = distance) %>% filter(max_dist > 0)

head(dists)

rocData <- dists %>% filter(group != "Predicted") %>% mutate(response = ifelse(group == "Positive Control", 1, 0))
roc.curve(response = rocData$response, predicted = rocData$max_dist,
          main="ROC curve for Maximum Phylogenetic Distance")


pred <- prediction( (rocData$max_dist), rocData$response)
perf <- performance(pred,"tpr","fpr")

dat <- data.frame(fpr = perf@x.values[[1]], tpr = perf@y.values[[1]], cutoff = perf@alpha.values[[1]])

plot(perf)

cutoffs <- data.frame(cut=perf@alpha.values[[1]], fpr=perf@x.values[[1]], 
                      tpr=perf@y.values[[1]])

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/distance_roc.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$max_dist,
          main="ROC curve for Maximum Phylogenetic Distance")


dev.off()
}

```

###Read depths ROC

```{r read_depths_roc}
load("~/bin/r_git/R/r_files/ncRDepth.Rda")
load("~/bin/r_git/R/r_files/pcRDepth.Rda")
load("~/bin/r_git/R/r_files/predRDepth.Rda")

pcRDepth <- pcRDepth %>% mutate(response = 1) %>% filter(max.val > 0)
ncRDepth <- ncRDepth %>% mutate(response = 0)
rocData <- pcRDepth %>% bind_rows(ncRDepth) 

rocDataMaxMax <- rocData %>% group_by(srna, response) %>% summarise(max.max.val = max(max.val))
rocDataMeanSum <- rocData %>% group_by(srna, response) %>% summarise(max.max.val = sum(mean.val))
rocDataMaxSum <- rocData %>% group_by(srna, response) %>% summarise(max.max.val = sum(max.val))



roc.curve(response = rocDataMaxSum$response, predicted = rocDataMaxSum$max.max.val, 
          main="ROC curve for Read Depths")




pred <- prediction( (rocDataMaxSum$max.max.val), rocDataMaxSum$response)
perf <- performance(pred,"tpr","fpr")

dat <- data.frame(fpr = perf@x.values[[1]], tpr = perf@y.values[[1]], cutoff = perf@alpha.values[[1]])

plot(perf)

cutoffs <- data.frame(cut=perf@alpha.values[[1]], fpr=perf@x.values[[1]], 
                      tpr=perf@y.values[[1]])

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/reads_max.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocDataMaxSum$response, predicted = rocDataMaxSum$max.max.val, 
          main="ROC curve for Read Depths")

dev.off()
}
```

###Alifold z-score ROC

```{r alifold_z_score_roc}
load("~/bin/r_git/R/r_files/pcAlifold.Rda")
load("~/bin/r_git/R/r_files/ncAlifold.Rda")
load("~/bin/r_git/R/r_files/predAlifold_v2.Rda")

pcAlifold <- pcAlifold %>% mutate(response = 1) %>% filter(STDV > 0) %>% unique()
ncAlifold <- ncAlifold %>% mutate(response = 0)



rocData <- pcAlifold %>% bind_rows(ncAlifold)
rocData <- rocData[!is.na(rocData$z_mean),] 
rocData <- rocData[!is.na(rocData$z_max),] 

roc.curve(response = rocData$response, predicted = rocData$z_max,
          main="ROC curve for Z-score Alifoldz")


write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/alifold_z_score.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$z_mean,
          main="ROC curve for Z-score Alifoldz")

dev.off()
}
```

###Rscape ROC

```{r rscape_roc, eval = T}
load("~/bin/r_git/R/r_files/pcCovariation.Rda")
load("~/bin/r_git/R/r_files/ncCovariation.Rda")
load("~/bin/r_git/R/r_files/predCovariation.Rda")
load("~/bin/r_git/R/r_files/featuresSelected.Rda")


 
pcCov <- pcCov %>% mutate(response = 1) 
ncCovRNA <- ncCovRNA %>% mutate(response = 0)
rocData <- pcCov %>% bind_rows(ncCovRNA) %>% mutate(combined_score = count * mean_score) %>% filter(!is.na(combined_score))
roc.curve(response = rocData$response, predicted = rocData$min_eval, 
          main="ROC curve for Covariation Scores")

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/cov_min_eval.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$min_eval, 
          main="ROC curve for Covariation min eval", add.roc = F)


dev.off()
}

pcCov <- featuresSelected %>% filter(group == "Positive Control") %>% mutate(response = 1) 
ncCov <- featuresSelected %>% filter(group == "Negative Control") %>% mutate(response = 0)
rocData <- pcCov %>% bind_rows(ncCov)

roc.curve(response = rocData$response, predicted = rocData$cov.min.eval, 
          main="ROC curve for Covariation Scores")


```

###Alifold Covariation ROC

```{r alifold_cov_roc, eval = T, include=T}
load("~/bin/r_git/R/r_files/featuresSelected.Rda")


pcCovRoc <- featuresSelected %>% filter(group == "Positive Control") %>% mutate(response = 1) 
ncCovRoc <- featuresSelected %>% filter(group == "Negative Control") %>% mutate(response = 0) 
rocData <- pcCovRoc %>% bind_rows(ncCovRoc) %>% filter(!is.na(alifold_cov_score)) 
roc.curve(response = rocData$response, predicted = rocData$alifold_cov_score, 
          main="ROC curve for Alifold Covariation Scores")


ggplot()+
  geom_freqpoly(data = rocData, aes(x = alifold_cov_score, y = ..density..,group = response, color = response), binwidth = 1)

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/alifold_cov_roc.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$alifold_cov_score, 
          main="ROC curve for Alifold Covariation Scores")


dev.off()
}


```

###GC ROC

```{r gc_content_rf_roc, eval = T}
load("~/bin/r_git/R/r_files/predGCrf.Rda")
load("~/bin/r_git/R/r_files/pcGCrf.Rda")
load("~/bin/r_git/R/r_files/ncGCrf.Rda")

pcGC <- pcGCrf 
ncGC <- ncGCrf 
predGC <- predGCrf 

pcGC <- pcGCrf %>% mutate(response = 1)
ncGC <- ncGCrf %>% mutate(response = 0)

rocData <- pcGC %>% bind_rows(ncGC)

roc.curve(response = rocData$response, predicted = rocData$gc.percent,
          main="ROC curve for GC%")

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/gc.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$gc.percent,
          main="ROC curve for GC%")

dev.off()
}
```

###MFE ROC

```{r MFE_roc, eval = T, echo=T}
load("~/bin/r_git/R/r_files/featuresSelected.Rda")


pcCovRoc <- featuresSelected %>% filter(group == "Positive Control") %>% mutate(response = 1) 
ncCovRoc <- featuresSelected %>% filter(group == "Negative Control") %>% mutate(response = 0) 
rocData <- pcCovRoc %>% bind_rows(ncCovRoc) %>% filter(!is.na(mfe.score)) 

roc.curve(response = rocData$response, predicted = rocData$mfe.score,
          main="ROC curve for MFE")



write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/mfe.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$mfe.score,
          main="ROC curve for MFE")

dev.off()

}
```

###Motifs ROC

```{r motifs_roc, eval = T}

load("~/bin/r_git/R/r_files/pcMotif.Rda")
load("~/bin/r_git/R/r_files/ncMotif.Rda")
load("~/bin/r_git/R/r_files/predMotif.Rda")

ncMotif <- ncMotif %>% mutate(response = 0)
pcMotif <- pcMotif %>% mutate(response = 1)

rocData <- pcMotif %>% bind_rows(ncMotif)

roc.curve(response = rocData$response, predicted = rocData$max_score,
          main="ROC curve for motifs")

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/motifs_max.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$max_score,
          main="ROC curve for motifs max")

dev.off()

}


```

###sRNA counts ROC

```{r srna_counts_roc, eval=T}
load("~/bin/r_git/R/r_files/featuresSelected.Rda")


pcSRNACounts <- featuresSelected %>% filter(group == "Positive Control") %>% mutate(response = 0)
ncSRNACounts <- featuresSelected %>% filter(group == "Negative Control") %>% mutate(response = 1)

rocData <- pcSRNACounts %>% bind_rows(ncSRNACounts) %>% filter(!is.na(srna.counts))

roc.curve(response = rocData$response, predicted = rocData$srna.counts,
          main="ROC curve for sRNA counts")

write_data <- F
if(write_data){
svg(filename="~/phd/RNASeq/figures/srna_counts_roc.svg",
     width=20,
     height=20,
     pointsize=12)
roc.curve(response = rocData$response, predicted = rocData$srna.counts,
          main="ROC curve for sRNA counts")

dev.off()

}
```

##Examples

-   GCA_000835925.1_174 RF01675

-    GCA_900243355.1_275  RF00018

-   GCA_000438825.1_206 Looks good but only one sequence with reads data

-   GCA_000747565.1_420 always before ribD (uniprot) X

-   GCA_000046845.1_118 CRISPR repeat element

-   GCA_000835925.1_85 before GIsB stress response membrane protein X

-   GCA_000007565.2_196

-   GCA_002220715.1_463

-   GCA_001750725.1_305 GlmZ

-   GCA_000007565.2_249


-   GCA_000017745.1_570 matching a hypothetical protein (WP_032178845.1) but rnacode thinks its not a protein

-   X GCA_000015425.1_38  surrounded by 50S ribosomal proteins 

-   GCA_000213655.1_134 dUTP diphosphatase before and exodeoxyribonuclease VV subunit gamma

-   GCA_000017745.1_532 with replicon RepA

-   GCA_000210855.2_455 found near single stranded dna binding protein and DUF4942

-   GCA_005931095.1_786


###Get genomes 
```{r get_genome_info_examples, eval=F}
contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("query.name", "genome")

id <- "GCA_000438825.1_260"

dat <- read.table(paste("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments_rnaalifold/alignments_", id, ".stk", sep = ""), comment.char = "#", fill = T)

dat <- dat %>% separate(V1, into = c("query.name", "location"), sep = "/", remove = T, extra = 'drop') %>%  select(query.name, location) %>% 
  mutate(found = T) %>% mutate(rev.query.name = stri_reverse(query.name)) %>%  separate(rev.query.name, into = c("t1"), sep = "\\|", remove = F) %>% mutate(query.name = stri_reverse(t1))

dat <- dat %>% left_join(contig_labels, by = "query.name")

genus_labels <- read.table("~/phd/RNASeq/contig_genus_lables.txt")

colnames(genus_labels) <- c("query.name", "genus")

genus_labels$genus[genus_labels$genus == "Methylococcaceae"] <- "Moraxella"

dat <- dat %>% left_join(genus_labels, by = "query.name") %>%  unique() %>%  separate(location, into = c("start", "end"), sep = "-", remove = F) %>% filter(!is.na(genome)) %>% mutate(srna = id)

summaryDat <- dat %>% select(genome, genus) %>% unique() %>% filter(!is.na(genome))

subsetDat <- dat %>% filter(grepl(pattern = "GCA", x = genome) == T)
write.csv(x = subsetDat, file = "~/phd/RNASeq/tmp/srna_regions.csv", row.names = F, quote = F)

plot_region <- function(i, adj.range = 5000, counter, dat = dat, write_data = F){

  genome <- as.character(dat$genome[i])
  print(genome)
  genus <- dat$genus[i]
 gff  <- tryCatch({
          gff <- read.gff(paste("~/phd/RNASeq/genera/", genus, "/", genome, ".data/gff_files/", genome,".gff", sep = ""))

        gff
      }, error =  function(e) {
        print("error")
        return(F)
      })
if(gff == F){
return(counter)
}
  
start_val <- as.numeric(dat$start[i])
end_val <- as.numeric(dat$end[i])
contig <- dat$query.name[i]
strand_val <- ifelse(start_val < end_val, '+', '-')

subgff <- gff %>% filter(start > (start_val - adj.range), start < (end_val + adj.range), type == 'CDS', seqid == contig) %>% 
  separate(attributes, into = c(NA, "t1"), extra = 'merge', remove = F, sep = "product=") %>% separate(t1, into = "Name", sep = ";")


names1 <- c("start", "end", subgff$Name, "rna_1")
starts1 <- c((start_val - 1000), (start_val + 1000 - 1), subgff$start, min(start_val, end_val))
ends1 <- c((start_val - 1000 + 1), (start_val + 1000),subgff$end, max(start_val, end_val))
strands1 <- c("+", "-", as.character(subgff$strand), strand_val)

# names1 <- subgff$t2
# starts1 <- subgff$start
# ends1 <- subgff$end
# strands1 <- as.character(subgff$strand)

df1 <- data.frame(name=names1, start=starts1, end=ends1,
strand=strands1, col="Blue")
df1 <- df1 %>% mutate(col = ifelse(name == "rna_1", "Red", "Blue"))


dna_seg1 <- dna_seg(df1)
is.dna_seg(dna_seg1)

dna_segs <- list(dna_seg1)

mid_pos <- middle(dna_seg1)

#annot1 <- genoPlotR::annotation(x1=mid_pos, text=dna_seg1$name, rot=c(30, 0))
# plot_gene_map(dna_segs=list(dna_seg1), comparisons=comparisons, annotations=annot1)


annot2 <- genoPlotR::annotation(x1=c(mid_pos),
x2=c(dna_segs[[1]]$end),
text=c(dna_segs[[1]]$name),
rot=c(60), col=c("grey"))


if(write_data){
  svg(filename=paste("~/phd/RNASeq/figures/genes_", genome, "_", start_val, ".svg", sep = ""),
     width=20,
     height=20,
     pointsize=12)
plot_gene_map(dna_segs=dna_segs,
annotations=annot2, annotation_height=1.3)

dev.off()
}else{
  plot_gene_map(dna_segs=dna_segs,
annotations=annot2, annotation_height=1.3)
}

counter <- counter + 1
return(counter)

}

counter <- 1
for(i in 1:nrow(subsetDat)){
  print(i)
  counter <- plot_region(i = i, counter = counter, dat = subsetDat, write_data = T, adj.range = 5000)
  if(counter > 20){
    break
  }
}



```


###Get read depths
```{bash get_read_depths_examples, eval=F}
> ~/phd/RNASeq/tmp/current.values
while read line;
do
echo $line
genome=`echo $line | cut -d ',' -f8`
srna=`echo $line | cut -d ',' -f10`
contig=`echo $line | cut -d ',' -f1`
genus=`echo $line | cut -d ',' -f9`
start=`echo $line | cut -d ',' -f3`
stop=`echo $line | cut -d ',' -f4`

if [[ $start  == "start" ]];then
continue
fi

tmpstart=$(($start - 1000))
tmpstop=$(($start + 1000))

start=$tmpstart
stop=$tmpstop

esl-seqstat -a ~/phd/RNASeq/sequences/${genome}.fna | grep "=" > ~/phd/RNASeq/tmp/tmp.stats
    current_count=0
while read stat_line;
do
chromosome=`echo "$stat_line" | grep $contig | wc -l | cut -d ' ' -f8`
if (( $chromosome > 0 ));
then
tmpstart=$(($start + $current_count))
tmpstop=$(($stop + $current_count))
if (( $tmpstart < $tmpstop  )); then
start=$tmpstart
stop=$tmpstop
else
stop=$tmpstart
start=$tmpstop
fi

if [[ ! -d ~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files ]];
then
echo "Genome: ${genome} has no plot files"
continue
fi
#echo "~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files $start $stop"
> ~/phd/RNASeq/tmp/test.plot
counter="1"
for plotfile in ~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files/*.plot;
do
if [[ $plotfile == *"ncRNA"* ]]; then
continue
elif [[ $plotfile == *"rev"* ]]; then
continue
elif [[ $plotfile == *"fwd"* ]]; then
continue            
fi
echo "$plotfile $genus $genome"
sed -n "${start},${stop}{p;${stop}q;}"  $plotfile > ~/phd/RNASeq/tmp/tmp.plot
if [[  $counter ==  "1" ]];
then
cat ~/phd/RNASeq/tmp/tmp.plot > ~/phd/RNASeq/tmp/test.plot
counter="2"
else
cat ~/phd/RNASeq/tmp/test.plot > ~/phd/RNASeq/tmp/tmp2.plot 
paste ~/phd/RNASeq/tmp/tmp2.plot ~/phd/RNASeq/tmp/tmp.plot > ~/phd/RNASeq/tmp/test.plot
fi
done
  #cp test.plot ~/phd/RNASeq/tmp
#summarise_sRNA_read_depths.R ~/phd/RNASeq/tmp/test.plot
#cat ~/phd/RNASeq/tmp/test.values | sed -e "s/$/ $ID $genus $genome_name $genome $contig $realstart $realstop $start $stop/" >> ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/${group}_read_depths_summary.txt
sRNA_examples_summary.R "${genome}_${start}"

cat ~/phd/RNASeq/tmp/current.values > ~/phd/RNASeq/tmp/tmp2.values 
paste ~/phd/RNASeq/tmp/tmp2.values ~/phd/RNASeq/tmp/tmp.values > ~/phd/RNASeq/tmp/current.values

else
length=`echo $stat_line | cut -d ' ' -f3`
current_count=$(($current_count + $length))
fi

done < ~/phd/RNASeq/tmp/tmp.stats

done < ~/phd/RNASeq/tmp/srna_regions.csv

```


```{r read_heatmap, eval=F}

dat <- data.frame(a = c(1,1,1,1,3,4,5,6,7),
                  b = c(10,4,4,4,9,15,13,12,10),
                  c = c(1,1,1,1,0,0,0,0,0),
                  d = c(1,2,2,5,4,6,7,8,5))
dat <- read.table("~/phd/RNASeq/tmp/current.values", as.is = T, stringsAsFactors = F, fill =T)


dat[is.na(dat)] <- 0

cols <- data.frame(names = colnames(dat), genomes = as.character(dat[1,]))

dat <- dat[-1,]

dat <- dat %>% mutate_all(as.numeric)

col_sum <- colSums(dat)





scaled.dat <- dat


# mat <- scaled.dat %>% as.matrix() 
# 
# meltDat <- melt(data = mat)
# 
# meltDat$Var1 <- meltDat$Var1 - 1
# 
# zooDat <- zoo::zoo(as.numeric(as.character(meltDat$value)))
# 
# smoothDat <- zoo::rollapply(zooDat, width = 10, by = 10, FUN = mean, align = "left", partial = T) 
# smoothDat <- as.data.frame(smoothDat)
# 
# meltDat <- meltDat %>% mutate(row_num = row_number())%>% filter(row_num %% 10 == 1) %>% bind_cols(smoothDat)
# 
# 
# 
# meltDat <- meltDat %>% select(Var1, Var2, smoothDat) %>% dplyr::rename(x= Var1, y = Var2, value = smoothDat) %>% mutate(x = x/10)
#  
scaled.dat <- as.data.frame(scaled.dat)

for(i in 1:ncol(scaled.dat)){
  zooDat <- zoo::zoo(as.numeric(as.character(scaled.dat[,i])))
  smoothDat <- zoo::rollapply(zooDat, width = 25, by = 1, FUN = mean, align = "center", partial = T) 
  
  scaled.dat[,i] <- smoothDat
  
  }

scaled.dat <- scaled.dat %>% mutate_all(as.numeric) %>% mutate(row_num = row_number())

scaled.dat2 <- scaled.dat

for(i in 1:(ncol(scaled.dat2) -1)){
  scaled.dat2[,i] <- scaled.dat2[,i]/sum(scaled.dat2[,i])
  
  maxVal <- max(scaled.dat2[,i])
  adjVal <- 1/maxVal

  scaled.dat2[,i] <- scaled.dat2[,i]*adjVal

  }

mat <- scaled.dat2 %>% as.matrix() 

meltDat <- melt(data = mat)

p <- ggplot() +
  geom_tile(data = meltDat[meltDat$Var2 != "row_num",], aes(x = Var1, y = Var2, fill = value)) +
  scale_fill_gradient(low = 'white', high = 'red')

ggsave(filename = "~/phd/RNASeq/figures/GCA_000438825.1_260_read_depths_heatmap.svg", plot = p, width = 450, height = 450, units = "mm")

p1 <- ggplot() +
  geom_col(data = scaled.dat, aes(y = V1, x = row_num), width=1, color = 'black', fill= 'black')
p2 <- ggplot() +
  geom_col(data = scaled.dat, aes(y = V2, x = row_num), width=1, color = 'black', fill= 'black')
p3 <- ggplot() +
  geom_col(data = scaled.dat, aes(y = V3, x = row_num), width=1, color = 'black', fill= 'black')
p4 <- ggplot() +
  geom_col(data = scaled.dat, aes(y = V4, x = row_num), width=1, color = 'black', fill= 'black')
# p5 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V5, x = row_num), width=1, color = 'black', fill= 'black')
# p6 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V6, x = row_num), width=1, color = 'black', fill= 'black')
# p7 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V7, x = row_num), width=1, color = 'black', fill= 'black')
# p8 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V8, x = row_num), width=1, color = 'black', fill= 'black')
# p9 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V9, x = row_num), width=1, color = 'black', fill= 'black')
# p10 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V10, x = row_num), width=1, color = 'black', fill= 'black')
# p11 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V11, x = row_num), width=1, color = 'black', fill= 'black')
# p12 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V52, x = row_num), width=1, color = 'black', fill= 'black')
# p13 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V53, x = row_num), width=1, color = 'black', fill= 'black')
# p14 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V54, x = row_num), width=1, color = 'black', fill= 'black')
# p15 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V55, x = row_num), width=1, color = 'black', fill= 'black')
# p16 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V56, x = row_num), width=1, color = 'black', fill= 'black')
# p17 <- ggplot() + 
#   geom_col(data = scaled.dat, aes(y = V57, x = row_num), width=1, color = 'black', fill= 'black')
# 
all.p <- ggarrange(p1, p2, p3, p4 + rremove("x.text"),
          labels = cols$genomes[1:4],
          ncol = 1, nrow = 11)
# 
# ggsave(filename = "~/phd/RNASeq/figures/GCA_000015425.1_257_read_depths_example.svg", plot = all.p, width = 450, height = 307, units = "mm")



```


```{bash, eval=F}
> ~/phd/RNASeq/examples/test_example_files/test.fna
esl-sfetch -c 3107843..3110110 all_genomes.fna NC_015554.1 >> ~/phd/RNASeq/examples/test_example_files/test.fna
esl-sfetch -c 1066528..1064263 all_genomes.fna NZ_CP018321.1 >> ~/phd/RNASeq/examples/test_example_files/test.fna
esl-sfetch -c 1067730..1065465 all_genomes.fna NC_019393.1 >> ~/phd/RNASeq/examples/test_example_files/test.fna
esl-sfetch -c 962280..960915 all_genomes.fna NZ_CP018026.1 >> ~/phd/RNASeq/examples/test_example_files/test.fna







```


###examples_setup

```{r examples_setup, eval=F, include=F}
load("~/bin/r_git/R/r_files/predDat.Rda")

new_calls <- read.table("~/phd/RNASeq/genera/new_calls_simple.txt", sep = "\t", fill =  T)
new_calls <- new_calls %>% filter(V5 != "", V5 != "id")
colnames(new_calls) <- c("contig", "start", "stop", "new_feature", "ID")
newCalls <- new_calls %>% select(ID, new_feature)

predDat <- predDat %>% left_join(newCalls, by = "ID")

predDat <- predDat %>% mutate(prediction = ifelse(new_feature == F, 1, prediction))

predNew <- predDat %>% filter(prediction ==  1, new_feature == T)

```




###plots

```{r example_plots, eval=F, include=F}
ggplot() + 
  geom_freqpoly(data = predDat %>% filter(read.max.score> 0), aes(x = read.max.score, y = ..density.., group = prediction, color = as.character(prediction)), binwidth = 20) +
  xlim(c(0, 500))


ggplot() + 
  geom_freqpoly(data = predDat %>% filter(mfe.score < 0), aes(x = mfe.score, y = ..density.., group = prediction, color = as.character(prediction)), binwidth = 5) +
  xlim(c(-100, 0))


ggplot() + 
  geom_freqpoly(data = predDat , aes(x = gc.score, y = ..density.., group = prediction, color = as.character(prediction)), binwidth = 2) +
  xlim(c(10, 90))


ggplot() + 
  geom_freqpoly(data = predDat %>% filter(distance> 0), aes(x = distance, y = ..density.., group = prediction, color = as.character(prediction)), binwidth = 0.05) +
  xlim(c(0, 1))


ggplot() + 
  geom_freqpoly(data = predDat %>% filter(cov.count> 0), aes(x = cov.count, y = ..density.., group = prediction, color = as.character(prediction)), binwidth = 1) +
  xlim(c(0, 50))


ggplot() + 
  geom_freqpoly(data = predDat %>% filter(motif.max.score> 0), aes(x = motif.max.score, y = ..density.., group = prediction, color = as.character(prediction)), binwidth = 1) +
  xlim(c(0, 50))


ggplot() + 
  geom_freqpoly(data = predDat %>% filter(motif.max.score> 0), aes(x = motif.max.score, y = ..density.., group = prediction, color = as.character(prediction)), binwidth = 1) +
  xlim(c(0, 50))

```



#Scripts

***

##callPeaksforGenome.sh {#callpeaksforgenome}

Wrapper for a series of scripts that downloads genomes and fastq files, maps reads and calls peaks for a given genome. The fastq files are downloaded from SRA using a list of available experiment IDs.

```{bash callPeaksforGenome.sh, eval = F, echo=T}
#!/bin/bash

##-----------------------------------------------------------------##
##--------------------------- Setup Variables ---------------------##
##-----------------------------------------------------------------##

FILE_PATH=`dirname $0`
number_of_sra="10"
output_path="./"
CPUS='6'
output_log=/dev/stdout
display_available_files="F"

##-----------------------------------------------------------------##
##------------------------ User Input Options ---------------------##
##-----------------------------------------------------------------##

while getopts "g:n:o:c:qth" arg; do
  case $arg in
    g)
      gca=$OPTARG
      ;;
    n)
      number_of_sra=$OPTARG
      ;;      
    o)
      output_path=$OPTARG
      ;;
	c)
      CPUS=$OPTARG
      ;;                  
	q)
      output_log=$gca.log
      ;;
    t)
    display_available_files="T"
    ;; 
    h)
echo '# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'

      ;;
      
    esac
done    

##-----------------------------------------------------------------##
##-------------------------- Tests For Inputs ---------------------##
##-----------------------------------------------------------------##
if [[ -z $gca ]]; then
echo 'Error: GCA needed. Specify with -g <gca>'
echo ' '
echo 'Use -h for more help.'
echo ' '
exit
fi

counts=`grep $gca ~/phd/RNASeq/SRA_bacteria_RNAseq.txt | grep "PAIRED" | grep "Illumina HiSeq" | wc -l`
if (( $counts == 0 )); then
echo "No valid RNAseq datasets for $gca"

exit
fi

if [[ $display_available_files == "T" ]]; then
grep $gca ~/phd/RNASeq/SRA_bacteria_RNAseq.txt | grep "PAIRED" | grep "Illumina HiSeq"
exit
fi

##-----------------------------------------------------------------##
##---------------------- Set up folders/files ---------------------##
##-----------------------------------------------------------------##

cd $output_path
mkdir -p "$gca.data"
cd "$gca.data"
mkdir gff_files      
echo "Output to $output_log"

if (( $counts > $number_of_sra )); then

grep $gca ~/phd/RNASeq/SRA_bacteria_RNAseq.txt | grep "PAIRED" | cut -f1 | head -n $number_of_sra > tmp1

else

grep $gca ~/phd/RNASeq/SRA_bacteria_RNAseq.txt | grep "PAIRED" | cut -f1 > tmp1

fi


##-----------------------------------------------------------------##
##---------------------- Download Genome and GFF ------------------##
##-----------------------------------------------------------------##

	if [[ -f "${gca}.fna" ]]; then
	echo "$gca.fna already downloaded."
	else
	echo "Downloading $gca Genome and GFF files"
	fetch_genomes_from_GCA.sh -r $gca -g >> $output_log
	fi
	
if [ $? -eq 0 ]; then
    echo " "
else
     echo "Error: Downloading $gca Genome and GFF files failed. See fetch_genomes_from_GCA.sh"
     exit $?
fi


##-----------------------------------------------------------------##
##-------------- Download and Process RNA-Seq Files ----------------##
##-----------------------------------------------------------------##
file_lines=`cat tmp1`

for line in $file_lines ; 
do
	
	if [[ -f "${line}_sra_calls.gff" ]]; then
	
	echo "$line already downloaded."
	
	else
	
	echo "Downloading $line"
    fasterq-dump --split-3 -p $line >> $output_log
	echo "Mapping reads"
    sra2plot.1.0.3.sh -s $line -r $gca -d -n $CPUS  >> $output_log
    
    plot_lenegth=`wc -l $line.plot  | cut -d ' ' -f2`
    rm *.sam    
    	if [ $plot_lenegth -gt 0 ]; then
    	rm ${line}*fwd.plot
    	rm ${line}*.rev.plot
    	rm fastq/${line}*.fastq
    	rm trimmed/${line}*.fastq
    	fi
    rm /Users/thomasnicholson/ncbi/public/sra/*.cache
    echo "Removing CDS"
    removeProteinCodingRNA.R -f $line -g $gca >> $output_log
    echo "Calling Peaks"
    run_rnaPeakCalling.R -f $line  -g $gca >> $output_log
    
    fi
    cp ${line}_sra_calls.gff ./gff_files/
done

##-----------------------------------------------------------------##
##---------------------- Search for rFam models -------------------##
##-----------------------------------------------------------------##

rfamscan() { counts=$( bc -l <<< "scale=2;$(esl-seqstat $1.fna | grep ^"Total" | tr -s ' ' | cut -d ' ' -f4)*2/1000000"); cmscan -Z $counts  --cut_ga --rfam --nohmmonly --tblout $1.tblout --fmt 2 --clanin ~/Downloads/Rfam.clanin.txt ~/Downloads/Rfam.cm $1.fna; cmscanToGffWrapper.R -f $1.tblout -g $1;}

if [[ -f "${gca}_ncRNA.gff" ]]; then
	echo "${gca}_ncRNA.gff exists"
else
	echo "Running cmscan using rfam models"
	rfamscan $gca  >> $output_log
fi

cp $gca.gff ./gff_files/
cp ${gca}_ncRNA.gff ./gff_files


##-----------------------------------------------------------------##
##------------------------ Combine GFF Files ----------------------##
##-----------------------------------------------------------------##

if [[ ! -f "${gca}_new_calls.txt" ]]; then
combine_gff_files.R -f ./gff_files/ -o $gca
fi

echo "Finished."
rm tmp1
```

###fetch_genomes_from_GCA.sh

Downloads a given genome and corresponding annotation file (GFF3 format).

```{bash fetch_genomes_from_GCA.sh, eval = F, echo=T}
#!/bin/bash

##-----------------------------------------------------------------##
##---------------------------- Help Message -----------------------##
##-----------------------------------------------------------------##

usage(){
    echo "fetch_genomes_from_GCA.sh is a script for downloading a genome (and GFF file) from a GCA accession.  
Usage:
 fetch_genomes_from_GCA.sh [opts] [input]

Options:
	-h	Display this help

Input	       
	-r	Reference genome accession (required)
	-o	Output name
	-e Fasta file extension
   	-g include the GFF file

"
}

##-----------------------------------------------------------------##
##------------------------ User Input Options ---------------------##
##-----------------------------------------------------------------##

while getopts "r:o:e:gh" arg; do
case $arg in
	r) 
	GENOME=${OPTARG};;
	o) 
	OUTPUT=${OPTARG};;
	e) 
	EXTENSION=${OPTARG};;
	g)
      GFF='y'
      ;;  
    h)
		usage
		exit
      ;;    
	\?) 
	echo "Unknown option: -${OPTARG}" >&2; exit 1;;
    esac
done

##-----------------------------------------------------------------##
##-------------------------- Tests For Inputs ---------------------##
##-----------------------------------------------------------------##

if [ -z ${GENOME} ]; then
    echo "Error: No input specified." >&2
    usage
    exit 1
fi

if [ -z ${OUTPUT} ]; then

OUTPUT=${GENOME}

fi

if [ -z ${EXTENSION} ]; then

EXTENSION="fna"

fi

##-----------------------------------------------------------------##
##------------------------ Get IDs for download -------------------##
##-----------------------------------------------------------------##

AssemblyName=$(esearch -db assembly -query ${GENOME} | efetch -format docsum | xtract -pattern DocumentSummary -element AssemblyName)
refseqID=$(esearch -db assembly -query ${GENOME} | efetch -format docsum | xtract -pattern DocumentSummary -element RefSeq)

refseq1=$(echo $refseqID | head -c 7 | tail -c 3)
refseq2=$(echo $refseqID | head -c 10 | tail -c 3)
refseq3=$(echo $refseqID | head -c 13 | tail -c 3)



##-----------------------------------------------------------------##
##----------------------- Download fasta file ---------------------##
##-----------------------------------------------------------------##

if [ ! -f $OUTPUT.$EXTENSION ];then

fastaLink="ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/$refseq1/$refseq2/$refseq3/$refseqID._$AssemblyName/$refseqID._$AssemblyName._genomic.fna.gz"

downloadLink=$(echo $fastaLink | sed 's/\._/_/g')

curl $downloadLink > $OUTPUT.$EXTENSION.gz 
sleep 1
gunzip $OUTPUT.$EXTENSION.gz 

if [ $? -eq 0 ]; then
    echo " "
else
    exit $?
fi


echo "$OUTPUT.$EXTENSION downloaded using $downloadLink"

else

fastaLink="ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/$refseq1/$refseq2/$refseq3/$refseqID._$AssemblyName/$refseqID._$AssemblyName._genomic.fna.gz"

downloadLink=$(echo $fastaLink | sed 's/\._/_/g')

echo "$OUTPUT.$EXTENSION already downloaded. To download again use $downloadLink"


fi

##-----------------------------------------------------------------##
##------------------------ Download GFF file ----------------------##
##-----------------------------------------------------------------##

if [[ $GFF = 'y' ]]; then

if [ ! -f $OUTPUT.gff ];then

      
gffLink="ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/$refseq1/$refseq2/$refseq3/$refseqID._$AssemblyName/$refseqID._$AssemblyName._genomic.gff.gz"

downloadLink=$(echo $gffLink | sed 's/\._/_/g')

curl $downloadLink > $OUTPUT.gff.gz 
sleep 1
gunzip $OUTPUT.gff.gz 

if [ $? -eq 0 ]; then
    echo " "
else
     exit $?
fi

echo "$OUTPUT.gff downloaded using $downloadLink"

else

gffLink="ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/$refseq1/$refseq2/$refseq3/$refseqID._$AssemblyName/$refseqID._$AssemblyName._genomic.gff.gz"

downloadLink=$(echo $gffLink | sed 's/\._/_/g')

echo "$OUTPUT.gff already downloaded. To download again use $downloadLink"


fi

fi


```

###sra2plot.1.0.3.sh


Script that maps reads from fastq file to genome and produces a plot file with read depths for each nucleotide.

```{bash sra2plot.1.0.3.sh, eval=F, echo=T}
#!/bin/sh
#Downloads fastq files from SRA, trims, maps and generates plotfiles for visualisation in artemis

#Dependencies:
#curl
#sratoolkit
#samtools 1.6 (older versions may not work for generating plotfiles)
#bowtie2
#trimmomatic 0.36

usage(){
    echo "sra2plot.sh is a wrapper script for downloading, mapping and visualising RNA-seq data from the NCBI Sequence Read Archive (SRA). Currently assumes paired end reads with TruSeq3 adaptors. Path for trimmomatic needs to be set to run. 
Usage sra2plot [opts] [input]
    
    Options:
		-h	Display this help

		Input	       
	       	-r	Reference genome accession (required)
		-s	SRA run accession or name of split fastq files (Required. Format: FILE_1.fastq FILE_2.fastq)
    		-n	Number of cores

		Turn off defaults
		-d	Turn off download. Default: download genome and SRA from NCBI if not found in working directory. 
			(Genome accession must be in Genbank nucleotide format: https://www.ncbi.nlm.nih.gov/Sequin/acc.html)
		-t	Turn off trimming
		-m	Turn off mapping
		-p	Don't make plotfiles
		-x	Don't cleanup files"
}
TPATH="/Users/thomasnicholson/bin/Trimmomatic_binary-0.36"
OUTDIR=""
SRA=""
GENOME=""
TRIM=true
MAP=true
PLOT=true
CLEAN=true
DOWNLOAD=true
THREADS=1

while getopts :s:r:n:thdmpx opt; do
    case "${opt}" in
	h) usage;exit;;
	t) TRIM=false;;
	s) SRA=${OPTARG};;
	r) GENOME=${OPTARG};;
	d) DOWNLOAD=false;;
	m) MAP=false;;
	p) PLOT=false;;
	x) CLEAN=false;;
	n) THREADS=${OPTARG};;
	\?) echo "Unknown option: -${OPTARG}" >&2; exit 1;;
	:) echo "Missing option argument for -${OPTARG}" >&2; exit 1;;
	*) echo "Unimplemented option: -${OPTARG}" >&2; exit;;
    esac
done
shift $((${OPTIND}-1))

if [ -z ${GENOME} ] || [ -z ${SRA} ]; then
    echo "Error: No input specified." >&2
    usage
    exit 1
fi

if [ -z ${TPATH} ]; then
    echo "Error: Path to trimmomatic install folder is not set.\n" >&2
    exit 1
fi

if $DOWNLOAD;then
    if [ ! -f ${GENOME}.fna ];then
	fetch_genomes_from_GCA.sh -r ${GENOME} -g
    fi
    if [ ! -f ${SRA}_*.fastq ];then
	fastq-dump --split-3 ${SRA}
    fi
fi

if $TRIM;then 
    if [ ! -d trimmed ];then
	mkdir trimmed
    fi
    java -jar ${TPATH}/trimmomatic-0.36.jar PE -threads `echo $((2*${THREADS}))` ${SRA}_1.fastq ${SRA}_2.fastq trimmed/${SRA}_1_paired.fastq trimmed/${SRA}_1_unpaired.fastq trimmed/${SRA}_2_paired.fastq trimmed/${SRA}_2_unpaired.fastq ILLUMINACLIP:${TPATH}/adapters/TruSeq3-PE.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36
fi

if $MAP; then
    #Build index of genome if necessary
    if [ ! -d index ]; then
	mkdir index 
	fi
	bowtie2-build ${GENOME}.fna ${GENOME} &&

	mv *.bt2* index/
    
    bowtie2 -p `echo "$((${THREADS}))"` -x index/${GENOME} -1 trimmed/${SRA}_1_paired.fastq -2 trimmed/${SRA}_2_paired.fastq -S ${SRA}.sam
fi

if $PLOT;then
    samtools view -bS -@ ${THREADS} ${SRA}.sam > ${SRA}.bam
    samtools sort -@ ${THREADS} ${SRA}.bam > ${SRA}.sorted.bam
    # Forward strand.
    #alignments of the second in pair if they map to the forward strand
    samtools view -b -f 128 -F 16 -@ ${THREADS} ${SRA}.sorted.bam > ${SRA}.fwd1.bam
    samtools index ${SRA}.fwd1.bam
    #alignments of the first in pair if they map to the reverse strand
    samtools view -b -f 80 -@ ${THREADS} ${SRA}.sorted.bam > ${SRA}.fwd2.bam
    samtools index ${SRA}.fwd2.bam
    #combine alignments that originate on the forward strand
    samtools merge -f ${SRA}.fwd.bam ${SRA}.fwd1.bam ${SRA}.fwd2.bam
    samtools index ${SRA}.fwd.bam

    # Reverse strand
    #alignments of the second in pair if they map to the reverse strand
    samtools view -b -f 144 -@ ${THREADS} ${SRA}.sorted.bam > ${SRA}.rev1.bam
    samtools index ${SRA}.rev1.bam
    #alignments of the first in pair if they map to the forward strand
    samtools view -b -f 64 -F 16 -@ ${THREADS} ${SRA}.sorted.bam > ${SRA}.rev2.bam
    samtools index ${SRA}.rev2.bam
    #combine alignments that originate on the reverse strand.
    samtools merge -f ${SRA}.rev.bam ${SRA}.rev1.bam ${SRA}.rev2.bam
    samtools index ${SRA}.rev.bam

    #Generate plotfiles
    samtools mpileup -aa ${SRA}.fwd.bam > ${SRA}.fwd.mpileup
    samtools mpileup -aa ${SRA}.rev.bam > ${SRA}.rev.mpileup
    cat ${SRA}.fwd.mpileup | cut -f4 > ${SRA}.fwd.plot
    cat ${SRA}.rev.mpileup | cut -f4 > ${SRA}.rev.plot
    paste ${SRA}.rev.plot ${SRA}.fwd.plot > ${SRA}.plot   
fi

if $CLEAN; then
    rm *.bam *.mpileup *.bai
	if [ ! -d fastq ]; then
	    mkdir fastq
	fi
	mv ${SRA}_*.fastq fastq/
fi



#To-do
#add install checks
#add opts for directory outputs
#write readme
#make logs/verbose?


```

###removeProteinCodingRNA.R


In order to call non-coding RNA expression, expression of coding regions must be ignored as not all of the RNA-Seq experiemtns are focused on ncRNA. This script does this by setting coding regions (defined based on the annotation file) to a read depth of 0.

```{r removeProteinCodingRNA.R, eval = F, echo=T}
#!/usr/bin/env Rscript
suppressMessages(library('getopt'))



spec = matrix(c(
  'sra', 'f', 1, "character",
  'help' , 'h', 0, "logical",
  'stranded' , 's', 0, "logical",
  'gff' , 'g', 1, "character",
  'file_path', 'p', 2, "character",
  'range', 'r', 2, "integer",
  'out_name', 'o', 2, "character"
), byrow=TRUE, ncol=4)


opt = getopt(spec)

if ( !is.null(opt$help) ) {
  cat("removeProteinCoding.R version 1.0\n")
  cat(" \n")
  cat("Use removeProteinCoding.R <options> -f <sra plot file> -g <gff file>\n")
  cat(" \n")
  cat("Options:\n")
  cat("  -f <sra plot file> The file that contains the plot data. Do not inclue the .plot file extension\n")
  cat("  -g <gff file> The file that contains the gff data. Do not inclue the gff file extension\n")
  cat("  -s <stranded data> The data is stranded\n")
  cat("  -p <file path> The location of the other files and the output file\n")
  cat("  -r <protein coding range> The number of nucleotides either side of a CDS region that should also be set to zero\n")
  cat("  -o <output file name> The name of the output file. Do not inclue the gff file extension. The default is the same as the sra input\n")
  q(status=1)
}

if ( is.null(opt$sra) ) {
  cat("Error: -f <sra plot file> is required.\n")
  q(status=1)
}
if ( is.null(opt$gff) ) {
  cat("Error: -g <gff file> is required.\n")
q(status=1)
}
suppressMessages(library(tidyverse))
suppressMessages(library(tjnFunctions))

if ( is.null(opt$file_path ) ) { opt$file_path = "." }
if ( is.null(opt$range ) ) { opt$range = 50 }
if ( is.null(opt$out_name ) ) { opt$out_name = opt$sra }
if(is.null(opt$stranded)){
  stranded <- F
}else{
  stranded <- T
}
sraName <- opt$sra
gffName <- opt$gff
filePath <- opt$file_path


plotDat <- read.table(paste(filePath, "/", sraName, ".plot", sep = ""))
gffDat <- read.table(paste(filePath, "/", gffName, ".gff", sep = ""), sep = "\t", fill = T, comment.char = "#", quote = "")

colnames(gffDat) <- c("sequence", "source", "feature", "start", "end", "score", "strand", "phase", "Atrribute")

plotDat <- removeCDSregions(plotDat = plotDat, gffDat = gffDat, stranded = stranded, time.it = T)



cat(paste("Writing the plot output to ", filePath, "/", opt$out_name, "_ncRNA.plot\n", sep = ""))
write.table(plotDat%>%select(V1,V2), file = paste(filePath, "/", opt$out_name, "_ncRNA.plot", sep = ""), quote = F, row.names = F, col.names = F, sep = "\t")


```

###run_rnaPeakCalling.R


Regions of expression are called on each individual RNA-Seq experiment by looking for regions where read depths are > 15 for atleast 50nt.

```{r run_rnaPeakCalling.R, eval = F, echo=T}
#!/usr/bin/env Rscript

##no idea which packages are needed
library(tidyverse)
library(devtools)
library(lubridate)
library(genoPlotR)
library(drake)
library(ape)
library(Biostrings)
library(ROSE)
library(reshape2)

suppressMessages(library(tidyverse))
suppressMessages(library(comparativeSRA))
genera_list <- list.files("~/phd/RNASeq/genera/")

genera <- "Acinetobacter"

for(genera in genera_list){
  print(genera)
  if(genera == "Escherichia"){
    next
  }

  
  accession_list <- list.files(paste("~/phd/RNASeq/genera/",  genera, "/", sep = ""), pattern = ".data$")
  accessionsDat <- data.frame(accession_list = accession_list)
  
  accessionsDat <- accessionsDat %>% mutate_all(as.character)
  accession_folder <-  accessionsDat$accession_list[2]
  
  
  for(accession_folder in accessionsDat$accession_list){
    accession <- unlist(strsplit(accession_folder, "\\."))[c(1,2)]
    accession <- paste(accession, collapse = ".")
    files <- list.files(paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/plot_files/", sep = ""), pattern = ".plot$")
    files_done <- list.files(paste("~/phd/RNASeq/tmp/done/", sep = ""), pattern = ".plot$")
    
    list_ignored <- files_done[files_done %in% files]
    
    if(length(list_ignored) > 0){
    print("Skipping files already done:")
    print(list_ignored)
    }
    
    files <- files[files %in% files_done == F]
    
    filesDat <- data.frame(files = files)
    
    filesDat <- filesDat %>% filter(grepl(pattern = "ncRNA", x = files)==F,
                                    grepl(pattern = "fwd", x = files)==F,
                                    grepl(pattern = "rev", x = files)==F,
                                    grepl(pattern = accession, x = files)==F) %>% mutate_all(as.character)
    
    
    
    
    if(nrow(filesDat) == 0){
      next
    }
    print(accession)
    
    gffDat <- read.table(paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/gff_files/", accession, ".gff", sep = ""), sep = "\t", fill = T, comment.char = "#", quote = "")
    colnames(gffDat) <- c("sequence", "source", "feature", "start", "end", "score", "strand", "phase", "Atrribute")
    
    regions <- gffDat %>% filter(feature == "region", start == "1") %>% select(sequence, start, end)
    
    current_pos <- 0
    for(i in 1:nrow(regions)){
      regions$end[i] <- regions$end[i] + current_pos
      regions$start[i] <- regions$start[i] + current_pos
      current_pos <- regions$end[i]
      
    }
    
    file_name <-  filesDat$files[1]
    cdsDat <- gffDat %>% filter(feature == "CDS")
    for(i in 1:nrow(regions)){
      contig <- regions$sequence[i]
      increase_val <- regions$start[i]
      cdsDat <- cdsDat %>% mutate(start = ifelse(sequence == contig, start + increase_val, start),
                                  end = ifelse(sequence == contig, end + increase_val, end))
      
    }
    
    positions <- cdsDat %>% select(sequence,start, end) %>% mutate(start = start - 149) %>% mutate(start = ifelse(start < 1, 1, start))  %>% mutate(end = end + 149) %>% mutate(end = ifelse(end > max(regions$end), max(regions$end), end))
    
    
    
    
    
    
    positions$new <- do.call(paste, c(positions, sep=":")) 
    positions$new <- Map(":", positions$start, positions$end)
    
    if(nrow(positions) <= 1000){
      next
    }
    
    values <- unlist(positions$new)
    
    
    positions <- data.frame(rowNum = values, type="CDS")
    
    starts <- data.frame(rowNum = cdsDat$start, type2 ="start")
    stops <- data.frame(rowNum = cdsDat$end, type2 ="stop")
    starts <- starts %>% mutate(rowNum = rowNum - 149) %>% mutate(rowNum = ifelse(rowNum < 1, 1, rowNum))
    stops <- stops %>% mutate(rowNum = rowNum + 149) %>% mutate(rowNum = ifelse(rowNum > max(regions$end), max(regions$end), rowNum))
    
    starts_and_stops <- starts %>% bind_rows(stops)
    
    positions <- positions %>% 
      left_join(starts_and_stops, by = "rowNum") %>% 
      mutate(type2 = ifelse(is.na(type2), "remove", type2))
    file_name <- "ERR519399.plot"
    for(file_name in filesDat$files){
      print(file_name)
      sra_id <- unlist(strsplit(file_name, "\\."))[1]
      
      
      plotFile  <- tryCatch({
        plotFile <- read.table(paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/plot_files/", file_name, sep = ""))
        plotFile
      }, error =  function(e) {
        cat(paste("Error: ","~/phd/RNASeq/genera/",  genera, "/", accession ,".data/plot_files/", file_name, " failed.\n", sep = ""))
        fileConn <- file(paste("~/phd/RNASeq/tmp/done/", sra_id, ".plot", sep = ""))
        writeLines("done", fileConn)
        close(fileConn)
        next
      })
      
      
      
      plotDat <- plotFile %>% mutate(value = ifelse(V1 > V2, V1, V2)) %>% select(value) %>% mutate(rowNum = row_number())
      
      plotDat <- plotDat %>% left_join(positions, by = "rowNum") %>% mutate(type2 = ifelse(is.na(type2), "intergenic", type2)) %>% 
        filter(type2 != "remove")
      
      
      plotDat <- plotDat %>% unique()
      
      
      
      plotDat <- plotDat %>% mutate(type = ifelse(is.na(type), "intergenic", "CDS"))
      
      total <- sum(plotDat$value)/1000000
      
      plotDat$value <- plotDat$value/total

      checkDat <- plotDat %>% filter(value > 15/total & type == "intergenic" )

      
      plotDat <- checkDat
      
      callsDat <- data.frame(start = rep(as.character("0"), 20000), stop = rep(as.character("0"), 20000), stringsAsFactors = F)
      start <- 0
      stop <- 0
      current_feature <- F
      cds <- F
      id_pos <- 0
      
      
      i <- 1
      for(i in 1:nrow(plotDat)){
        printRemaining(i = i, length = nrow(plotDat))
        if(i == nrow(plotDat)){
          if(current_feature){
            if((plotDat$rowNum[i] - 25) < stop){
              stop <- plotDat$rowNum[i]
              if(plotDat$type[i] == "CDS"){
                cds <- T
              }
            }
            if(cds){
              current_feature <- F
              cds <- F
              next
            }
            id_pos <- id_pos + 1
            # print(paste(start,stop, id_pos))
            callsDat$start[id_pos] <- start
            callsDat$stop[id_pos] <- stop
            current_feature <- F
            cds <- F
          }
        }
        
        if(current_feature == F){
          start <- plotDat$rowNum[i]
          stop <- plotDat$rowNum[i]
          if(plotDat$type[i] == "CDS"){
            cds <- T
          }
          current_feature <- T
          next
        }
        
        if(plotDat$type2[i] == "stop"){
          stop <- plotDat$rowNum[i]
          cds <- T
          next
        }
        
        if((plotDat$rowNum[i] - 25) < stop){
          stop <- plotDat$rowNum[i]
          if(plotDat$type[i] == "CDS"){
            cds <- T
          }
          next
        }else{
          if(cds){
            current_feature <- F
            cds <- F
            start <- plotDat$rowNum[i]
            stop <- plotDat$rowNum[i]
            next
          }
          id_pos <- id_pos + 1
          # print(paste(start,stop, id_pos))
          callsDat$start[id_pos] <- start
          callsDat$stop[id_pos] <- stop
          current_feature <- F
          cds <- F 
        }
      }  
      
      
      
      
      
      
      combinedCalls <- callsDat %>% filter(start != 0) %>% mutate_all(as.numeric) %>% filter((stop - start) > 50)
      
      
      
      
      gffMain <- readLines(paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/gff_files/", accession, ".gff", sep = ""))
      gffMain <- data.frame(text = gffMain)
      genomeInfo <- as.character(gffMain[8,1])
      genomeBuild <- as.character(gffMain[4,1])
      genomeSpecies <- as.character(gffMain[9,1])
      accession_contig <- strsplit(genomeInfo, " ")[[1]][2]
      
      
      
      gffFwd <- combinedCalls%>%mutate(strand = "+",
                                       source = "sraAlignedncRNAExpression",
                                       seqname = accession_contig,
                                       median.val = 0,
                                       feature = "ncRNA",
                                       frame = ".",
                                       attribute = paste("ID=rna_fwd_", row_number(), sep = ""))%>%
        select(seqname, source, feature, start, stop, median.val, strand, frame, attribute)
      
      
      
      
      fileConn<-file(paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/gff_files/", sra_id, "_snra_calls.gff", sep = ""))
      writeLines(c("##gff-version 3",
                   "#!gff-spec-version 1.21",
                   "#!processor R script (local) with manual add of top section",
                   genomeBuild,
                   paste("#!genome-build-accession NCBI_Assembly:", "GCA_000017745.1", sep = ""),
                   paste("#!annotation-date ", Sys.Date(), sep = ""),
                   "#!annotation-source snraCalls (local version)",
                   genomeInfo,
                   genomeSpecies), fileConn)
      close(fileConn)
      
      print(paste("Writing to ~/phd/RNASeq/genera/",  genera, "/", accession ,".data/gff_files/", sra_id, "_snra_calls.gff", sep = ""))
      write.table(x = gffFwd, file = paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/gff_files/", sra_id, "_snra_calls.gff", sep = ""), row.names = F, col.names = F, quote = F, sep = "\t", append = T)
      
      fileConn<-file(paste("~/phd/RNASeq/tmp/done/", sra_id, ".plot", sep = ""))
      writeLines("done", fileConn)
      close(fileConn)

    }
    
    
  }
}
```

###rfamscan


Annotations of known sRNAs in the downloaded annotation file were supplemented by searching for known rFam families in each genome.

```{bash rfamscan, eval = F, echo=T}
rfamscan() { counts=$( bc -l <<< "scale=2;$(esl-seqstat $1.fna | grep ^"Total" | tr -s ' ' | cut -d ' ' -f4)*2/1000000"); cmscan -Z $counts  --cut_ga --rfam --nohmmonly --tblout $1.tblout --fmt 2 --clanin ~/Downloads/Rfam.clanin.txt ~/Downloads/Rfam.cm $1.fna; cmscanToGffWrapper.R -f $1.tblout -g $1;}
```

####cmscanToGFFWrapper.R


The output from running cmscan needs to be in the same format as the rest of the data (GFF3).

```{r cmscanToGFFWrapper.R, eval=F, echo=T}
#!/usr/bin/env Rscript
library('getopt')


spec = matrix(c(
  'cmscanOutput', 'f', 1, "character",
  'gcf', 'g', 1, "character",
  'help' , 'h', 0, "logical",
  'file_path', 'p', 2, "character",
  'out_name', 'o', 2, "character"
), byrow=TRUE, ncol=4)


opt = getopt(spec)
#
# opt$cmscanOutput <- "GCA_000017745.1.tblout"
# opt$gcf <- "GCA_000017745.1"
# opt$file_path <- "~/phd/RNASeq/escherichia/"
# opt$output <- "escherichia_test"

if ( !is.null(opt$help) ) {
  cat("cmscanToGffWrapper.R version 1.0\n\n")
  cat("Use cmscanToGffWrapper.R <options> -f <cmscan ouptut file> -g <gff file>\n\n")
  cat("Options:\n")
  cat("  -f <cmscan ouptut file> The file that contains the cmscan output\n")
  cat("  -g <gff file> The file that contains the gff data. Do not inclue the gff file extension\n")
  cat("  -f <file path> The location of the other files and the output file\n")
  cat("  -o <output file name> The name of the output file. Do not inclue the gff file extension. The default is the same as the gca input\n")
   q(status=1)
}

if ( is.null(opt$cmscanOutput) ) {
  cat("Error: -f <cmscan ouptut file> is required.\n")
  q(status=1)
}
if ( is.null(opt$gcf) ) {
  cat("Error: -g <gff file> is required.\n")
  q(status=1)
}

library(tidyverse)
library(tjnFunctions)

if ( is.null(opt$file_path ) ) { opt$file_path = "." }
if ( is.null(opt$output ) ) { opt$output = opt$gcf }

rfamRes <- read.table(paste(opt$file_path, opt$cmscanOutput, sep = "/"), header = F, comment.char = "#",quote = "", fill = T)


gff <- cmscanToGff(rfamRes = rfamRes)


gffMain <- readLines(paste(opt$file_path, "/", opt$gcf, ".gff", sep = ""))
gffMain <- data.frame(text = gffMain)
genomeInfo <- as.character(gffMain[8,1])
genomeBuild <- as.character(gffMain[4,1])
genomeSpecies <- as.character(gffMain[9,1])
accession <- strsplit(genomeInfo, " ")[[1]][2]

fileConn<-file(paste(opt$file_path, "/",opt$output, "_ncRNA.gff", sep = ""))
writeLines(c("##gff-version 3",
             "#!gff-spec-version 1.21",
             "#!processor R script (local)",
             genomeBuild,
             paste("#!genome-build-accession NCBI_Assembly:", opt$gcf, sep = ""),
             paste("#!annotation-date ", Sys.Date(), sep = ""),
             "#!annotation-source cmscan (rFam) (local version)",
             genomeInfo,
             genomeSpecies), fileConn)
close(fileConn)


write.table(x = gff, file = paste(opt$file_path, "/",opt$output, "_ncRNA.gff", sep = ""), row.names = F, col.names = F, quote = F, sep = "\t", append = T)

```

###cmscanToLookupTable.R



The output from running cmscan needs to be in the same format as the rest of the data (GFF3).

```{r cmscanToLookupTable.R, eval=F, echo=T}
#!/usr/bin/env Rscript
library('getopt')

cmscanToLookup <- function(rfamRes){
  colnames(rfamRes) <- c("idx", "target.name", "accession1", "query.name", "accession2", "clan.name", "mdl", "mdl.from",  "mdl.to", "seq.from",   "seq.to",
                         "strand", "trunc", "pass",   "gc",  "bias",  "score",   "E.value", "inc", "olp", "anyidx", "afrct1", "afrct2", "winidx", "wfrct1", "wfrct2", "description.of.target")
  
  rfamRes <- rfamRes%>%
    mutate(seq.from2 = seq.from)%>%
    mutate(seq.from = ifelse(seq.from > seq.to, seq.to, seq.from))%>%
    mutate(seq.to = ifelse(seq.from2 > seq.to, seq.from2, seq.to))
  
  gff <- data.frame(seqname = rfamRes$query.name,
                    source = rep("rfam", nrow(rfamRes)),
                    feature = rep("ncRNA", nrow(rfamRes)),
                    start = rfamRes$seq.from,
                    end = rfamRes$seq.to,
                    score = rfamRes$score,
                    strand = rfamRes$strand,
                    frame = rep(".", nrow(rfamRes)),
                    attribute = rfamRes$accession1)
  return(gff)
}


spec = matrix(c(
  'cmscanOutput', 'f', 1, "character",
  'gcf', 'g', 1, "character",
  'help' , 'h', 0, "logical",
  'file_path', 'p', 2, "character",
  'out_name', 'o', 2, "character"
), byrow=TRUE, ncol=4)


opt = getopt(spec)
#
# opt$cmscanOutput <- "GCA_000017745.1.tblout"
# opt$gcf <- "GCA_000017745.1"
# opt$file_path <- "~/phd/RNASeq/escherichia/"
# opt$output <- "escherichia_test"

if ( !is.null(opt$help) ) {
  cat("cmscanToGffWrapper.R version 1.0\n\n")
  cat("Use cmscanToGffWrapper.R <options> -f <cmscan ouptut file> -g <gff file>\n\n")
  cat("Options:\n")
  cat("  -f <cmscan ouptut file> The file that contains the cmscan output\n")
  cat("  -g <gff file> The file that contains the gff data. Do not inclue the gff file extension\n")
  cat("  -f <file path> The location of the other files and the output file\n")
  cat("  -o <output file name> The name of the output file. Do not inclue the gff file extension. The default is the same as the gca input\n")
  q(status=1)
}

if ( is.null(opt$cmscanOutput) ) {
  cat("Error: -f <cmscan ouptut file> is required.\n")
  q(status=1)
}
if ( is.null(opt$gcf) ) {
  cat("Error: -g <gff file> is required.\n")
  q(status=1)
}

library(tidyverse)
library(tjnFunctions)

if ( is.null(opt$file_path ) ) { opt$file_path = "." }
if ( is.null(opt$output ) ) { opt$output = opt$gcf }

rfamRes <- read.table(paste(opt$file_path, opt$cmscanOutput, sep = "/"), header = F, comment.char = "#",quote = "", fill = T)


gff <- cmscanToLookup(rfamRes = rfamRes)
gff <- gff %>% arrange(start)


write.table(x = gff, file = paste(opt$file_path, "/",opt$output, "_ncRNA.lookup", sep = ""), row.names = F, col.names = F, quote = F, sep = "\t")

```



###combine_gff_files.R


For each genome all of the individual annotation files are combined into a single file with the description column incuding details of the origin of each annotation.

```{r combine_gff_files.R, eval=F, echo=T}
#!/usr/bin/env Rscript
suppressMessages(library('getopt'))


# getopts -----------------------------------------------------------------


spec = matrix(c(
  'sra', 'f', 1, "character",
  'gff', 'g', 1, 'character',
  'help' , 'h', 0, "logical",
  'stranded' , 's', 0, "logical",
  'quiet' , 'q', 0, "logical",
  'file_path', 'p', 2, "character",
  'out_name', 'o', 2, "character",
  'random_data', 'r', 1, "character"
), byrow=TRUE, ncol=4)


opt = getopt(spec)

if ( !is.null(opt$help) ) {
  cat("combine_gff_files.R version 1.0\n")
  cat(" \n")
  cat("Use combine_gff_files.R <options> -f <files>\n")
  cat(" \n")
  cat("Options:\n")
  cat("  -f <files> The gff files\n")
  cat("  -s <stranded data> The data is stranded\n")
  cat("  -r <random data> The file to remove CDS regions from\n")
  cat("  -q <quiet> Do not print any updates\n")
  cat("  -p <file path> The location of the other files and the output file\n")
  cat("  -o <output file name> The name of the output file. Do not inclue the gff file extension. The default is the same as the sra input\n")
  q(status=1)
}

if ( is.null(opt$sra) ) {
  cat("Error: -f <files> is required.\n")
  q(status=1)
}

if ( is.null(opt$out_name) ) {
  cat("Error: -o <output file name> is required.\n")
  q(status=1)
}


# packages ----------------------------------------------------------------


suppressMessages(library(tidyverse))
suppressMessages(library(comparativeSRA))

# defining variables ------------------------------------------------------


if ( is.null(opt$file_path ) ) { opt$file_path = "." }
if ( is.null(opt$out_name ) ) { opt$out_name = opt$sra }
if(is.null(opt$stranded)){
  stranded <- F
}else{
  stranded <- T
}

if(is.null(opt$quiet)){
  quiet <- F
}else{
  quiet <- T
}


#####

file_path <- opt$file_path
files <- list.files(paste(file_path, opt$sra, sep = "/"), pattern = ".gff$")
# import data -------------------------------------------------------------


#print(files)
dat <- data.frame(sequence = as.character("0"), source = as.character("0"), feature = as.character("0"),
                  start = as.integer("0"), end = as.integer("0"), score = as.character("0"),
                  strand = as.character("0"), phase = as.character("0"), Atrribute = as.character("0"), file_name = as.character("start_row"), stringsAsFactors = F)
i <- 2
for(i in 1:length(files)){
  tmp  <- tryCatch({
    suppressWarnings(tmp <- read.table(paste(file_path, opt$sra, files[i], sep = "/"), comment.char = "#", quote = "", sep = "\t", as.is = T))
  }, error =  function(e) {
    cat(paste("Error: ", "row ", i, ", ", file_path, "/", opt$sra, "/", files[i], " cannot be opened.\n", sep = ""))
    cat(paste(e, "\n"))
  })

  if(class(tmp) == "NULL"){
    next
  }

  if(ncol(tmp) != 9){
    cat(paste("Error: ", "row ", i, ", ", file_path, "/", opt$sra, "/", files[i], " contains ", ncol(tmp), " columns.\n", sep = ""))
    next
  }

  colnames(tmp) <- c("sequence", "source", "feature", "start", "end", "score", "strand", "phase", "Atrribute")

  tmp <- tmp%>%mutate(file_name = files[i])%>%mutate(score = as.character(score))

  if(files[i] == opt$random_data){
    tmp <- tmp%>%
  filter(feature != "CDS", feature != "gene", feature != "pseudogene", feature != "exon", feature != "region")
  }else{
  
  dat <- dat%>%bind_rows(tmp)
}
}
if(!is.null(opt$random_data)){
   ncRNAgff <- dat%>%
     filter(feature != "gene", feature != "pseudogene", feature != "exon", feature != "region")
}else{
ncRNAgff <- dat%>%
  filter(feature != "CDS", feature != "gene", feature != "pseudogene", feature != "exon", feature != "region")
}

# main section  -------------------------------------------------------------------


ncRNAgff <- ncRNAgff%>%arrange(start) %>% filter((end - start) > 0)# %>% arrange(strand)


mergedDat <- data.frame(sequence = as.character("0"), feature = as.character("0"),
                        start = as.integer("0"), end = as.integer("0"),
                        strand = as.character("0"), file_names = as.character("start_row"),
                        row_numbers = as.character("0"), prop_overlap = as.numeric(0), new_feature = F,
                        number_of_rnaseq_files = as.integer("0"),
                        score = as.character("0"),
                        stringsAsFactors = F)

##loop through the combined gff files and combine features that overlap
i <- 3
current_feature <- F #is there a current feature being written?
new_feature <- T

for(i in 1:(nrow(ncRNAgff))){
  ##check if the feature is already known
  if(ncRNAgff$source[i] != "sraAlignedncRNAExpression"){
    new_feature <- F
  }

  ##if there is no current feature then set a new start value
  if(current_feature == F){
  start_val <- ncRNAgff$start[i]
  start_i <- i
  end_val <- ncRNAgff$end[i]
  }



  ##set the new end value
  if(ncRNAgff$end[i] > end_val){
  end_val <- ncRNAgff$end[i]
  }

  if(i == nrow(ncRNAgff)){
    
    ##check if the subsequent feature was contained within the first feature
    if(ncRNAgff$end[start_i] < end_val){
      prop_val <- (ncRNAgff$end[start_i] - ncRNAgff$start[i])/(end_val - start_val)
    }else{
      prop_val <- 1
    }
    
    tmp <- data.frame(sequence = ncRNAgff$sequence[i],
                      feature = ncRNAgff$feature[i],
                      start = start_val, end = end_val,
                      strand = ncRNAgff$strand[i],
                      file_names = paste(ncRNAgff$file_name[start_i:i], collapse = ","),
                      row_numbers = paste(c(start_i:i), collapse = ","),
                      prop_overlap = prop_val,
                      new_feature = new_feature,
                      number_of_rnaseq_files = length(start_i:i),
                      score = as.character(ncRNAgff$score[i]),
                      stringsAsFactors = F)
    mergedDat <- mergedDat%>%bind_rows(tmp)
    current_feature <- F
    new_feature <- T
  }else{
    
    
  ##check if the cuurent end value overlaps with the next starting value and update the end value if it does
  if(end_val > ncRNAgff$start[i + 1]){
    end_val <- ncRNAgff$end[i + 1]
    current_feature <- T
  }else{

    ##check if the subsequent feature was contained within the first feature
    if(ncRNAgff$end[start_i] < end_val){
    prop_val <- (ncRNAgff$end[start_i] - ncRNAgff$start[i])/(end_val - start_val)
    }else{
      prop_val <- 1
    }

    tmp <- data.frame(sequence = ncRNAgff$sequence[i],
                      feature = ncRNAgff$feature[i],
                      start = start_val, end = end_val,
                      strand = ncRNAgff$strand[i],
                      file_names = paste(ncRNAgff$file_name[start_i:i], collapse = ","),
                      row_numbers = paste(c(start_i:i), collapse = ","),
                      prop_overlap = prop_val,
                      new_feature = new_feature,
                      number_of_rnaseq_files = length(start_i:i),
                      score = as.character(ncRNAgff$score[i]),
                      stringsAsFactors = F)
    mergedDat <- mergedDat%>%bind_rows(tmp)
    current_feature <- F
    new_feature <- T
  }
  }
}





mergedDat <- mergedDat%>%filter(number_of_rnaseq_files > 0, file_names != "start_row")

# if(!is.null(opt$random_data)){
#   mergedDat <- mergedDat %>% filter(file_names != opt$gff)
# }

mergedDat <- mergedDat %>% mutate(id =  paste(opt$out_name, row_number(), sep = "_"))

cat(paste("Writing the output to ", file_path, "/", opt$out_name, "_new_calls.txt\n", sep = ""))
write.table(x = mergedDat, file = paste(file_path, "/", opt$out_name, "_new_calls.txt", sep = ""), row.names = F, col.names = T, quote = F, sep = "\t")




```







##run_rnapeakcalling.2.0.r


Regions of expression are called on each individual RNA-Seq experiment by looking for regions where read depths are > 15 for atleast 50nt.

```{r run_rnaPeakCalling2.0.R, eval = F, echo=T}
#!/usr/bin/env Rscript

##no idea which packages are needed
library(tidyverse)
library(devtools)
library(lubridate)
library(genoPlotR)
library(drake)
library(ape)
library(Biostrings)
library(ROSE)
library(reshape2)

suppressMessages(library(tidyverse))
suppressMessages(library(comparativeSRA))
genera_list <- list.files("~/phd/RNASeq/genera/")

genera <- "Acinetobacter"

for(genera in genera_list){
  print(genera)
  if(genera == "Escherichia"){
    next
  }
  
  
  accession_list <- list.files(paste("~/phd/RNASeq/genera/",  genera, "/", sep = ""), pattern = ".data$")
  accessionsDat <- data.frame(accession_list = accession_list)
  
  accessionsDat <- accessionsDat %>% mutate_all(as.character)
  accession_folder <-  accessionsDat$accession_list[3]
  
  
  for(accession_folder in accessionsDat$accession_list){
    accession <- unlist(strsplit(accession_folder, "\\."))[c(1,2)]
    accession <- paste(accession, collapse = ".")
    files <- list.files(paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/plot_files/", sep = ""), pattern = ".plot$")
    
    filesDat <- data.frame(files = files)
    
    filesDat <- filesDat %>% filter(grepl(pattern = "ncRNA", x = files)==F,
                                    grepl(pattern = "fwd", x = files)==F,
                                    grepl(pattern = "rev", x = files)==F,
                                    grepl(pattern = accession, x = files)==F) %>% mutate_all(as.character)
    
    
    if(nrow(filesDat) == 0){
      next
    }
    print(accession)
    
    gffDat <- read.table(paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/gff_files/", accession, ".gff", sep = ""), sep = "\t", fill = T, comment.char = "#", quote = "")
    colnames(gffDat) <- c("sequence", "source", "feature", "start", "end", "score", "strand", "phase", "Atrribute")
    
    regions <- gffDat %>% filter(feature == "region", start == "1") %>% select(sequence, start, end)
    
    current_pos <- 0
    for(i in 1:nrow(regions)){
      # print(regions$start[i])
      regions$end[i] <- regions$end[i] + current_pos
      regions$start[i] <- regions$start[i] + current_pos
      current_pos <- regions$end[i]
      
    }
    
    file_name <-  filesDat$files[10]
    cdsDat <- gffDat %>% filter(feature == "CDS")
          for(i in 1:nrow(regions)){
        contig <- regions$sequence[i]
        increase_val <- regions$start[i]
        cdsDat <- cdsDat %>% mutate(start = ifelse(sequence == contig, start + increase_val, start),
                                    end = ifelse(sequence == contig, end + increase_val, end))
        
          }
    
    positions <- cdsDat %>% select(sequence,start, end) %>% mutate(start = start - 149) %>% mutate(start = ifelse(start < 1, 1, start))  %>% mutate(end = end + 149) %>% mutate(end = ifelse(end > max(regions$end), max(regions$end), end))
      
      
      
      
      
      
      positions$new <- do.call(paste, c(positions, sep=":")) 
      positions$new <- Map(":", positions$start, positions$end)
      
      
      values <- unlist(positions$new)
      
      
      positions <- data.frame(rowNum = values, type="CDS")
      
      starts <- data.frame(rowNum = cdsDat$start, type2 ="start")
      stops <- data.frame(rowNum = cdsDat$end, type2 ="stop")
      starts <- starts %>% mutate(rowNum = rowNum - 149) %>% mutate(rowNum = ifelse(rowNum < 1, 1, rowNum))
      stops <- stops %>% mutate(rowNum = rowNum + 149) %>% mutate(rowNum = ifelse(rowNum > max(regions$end), max(regions$end), rowNum))
      
      starts_and_stops <- starts %>% bind_rows(stops)
      
      positions <- positions %>% 
        left_join(starts_and_stops, by = "rowNum") %>% 
        mutate(type2 = ifelse(is.na(type2), "remove", type2))
    
    for(file_name in filesDat$files){
      print(file_name)
      sra_id <- unlist(strsplit(file_name, "\\."))[1]
      
      
      plotFile <- read.table(paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/plot_files/", file_name, sep = ""))

      
      
      plotDat <- plotFile %>% mutate(value = ifelse(V1 > V2, V1, V2)) %>% select(value) %>% mutate(rowNum = row_number())
      
      plotDat <- plotDat %>% left_join(positions, by = "rowNum") %>% mutate(type2 = ifelse(is.na(type2), "intergenic", type2)) %>% 
        filter(type2 != "remove")
      
      
      plotDat <- plotDat %>% unique()
      
      
      
      plotDat <- plotDat %>% mutate(type = ifelse(is.na(type), "intergenic", "CDS"))
      
      total <- sum(plotDat$value)/1000000
      
      plotDat$value <- plotDat$value/total
      
      # save(plotDat, file = "~/phd/RNASeq/tmp/plotDat.Rda")
      # 
      # load("~/phd/RNASeq/tmp/plotDat.Rda")
      
      checkDat <- plotDat %>% filter(value > 15/total & type == "intergenic" )
      
      
      # checkDat <- data.frame(value = "0.04", rowNum = c(1,2,3,4,5,15,16,17,18,21,22,23,50,51,52,56,61,62,63,64,100,101,102,103),
      #                        type = "intergenic")
      # checkDat <- checkDat %>% mutate(type = ifelse(rowNum > 15 & rowNum < 30, "CDS", "intergenic"))
      
      plotDat <- checkDat
      
      callsDat <- data.frame(start = rep(as.character("0"), 20000), stop = rep(as.character("0"), 20000), stringsAsFactors = F)
      start <- 0
      stop <- 0
      current_feature <- F
      cds <- F
      id_pos <- 0
      
      
      i <- 1
      for(i in 1:nrow(plotDat)){
        printRemaining(i = i, length = nrow(plotDat))
        if(i == nrow(plotDat)){
          if(current_feature){
            if((plotDat$rowNum[i] - 25) < stop){
              stop <- plotDat$rowNum[i]
              if(plotDat$type[i] == "CDS"){
                cds <- T
              }
            }
            if(cds){
              current_feature <- F
              cds <- F
              next
            }
            id_pos <- id_pos + 1
            # print(paste(start,stop, id_pos))
            callsDat$start[id_pos] <- start
            callsDat$stop[id_pos] <- stop
            current_feature <- F
            cds <- F
          }
        }
        
        if(current_feature == F){
          start <- plotDat$rowNum[i]
          stop <- plotDat$rowNum[i]
          if(plotDat$type[i] == "CDS"){
            cds <- T
          }
          current_feature <- T
          next
        }
        
        if(plotDat$type2[i] == "stop"){
          stop <- plotDat$rowNum[i]
          cds <- T
          next
        }
        
        if((plotDat$rowNum[i] - 25) < stop){
          stop <- plotDat$rowNum[i]
          if(plotDat$type[i] == "CDS"){
            cds <- T
          }
          next
        }else{
          if(cds){
            current_feature <- F
            cds <- F
            start <- plotDat$rowNum[i]
            stop <- plotDat$rowNum[i]
            next
          }
          id_pos <- id_pos + 1
          # print(paste(start,stop, id_pos))
          callsDat$start[id_pos] <- start
          callsDat$stop[id_pos] <- stop
          current_feature <- F
          cds <- F 
        }
      }  
      
      
      
      
      
      
      combinedCalls <- callsDat %>% filter(start != 0) %>% mutate_all(as.numeric) %>% filter((stop - start) > 50)
      
      
      
      
      gffMain <- readLines(paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/gff_files/", accession, ".gff", sep = ""))
      gffMain <- data.frame(text = gffMain)
      genomeInfo <- as.character(gffMain[8,1])
      genomeBuild <- as.character(gffMain[4,1])
      genomeSpecies <- as.character(gffMain[9,1])
      accession_contig <- strsplit(genomeInfo, " ")[[1]][2]
      
      
      
      gffFwd <- combinedCalls%>%mutate(strand = "+",
                                       source = "sraAlignedncRNAExpression",
                                       seqname = accession_contig,
                                       median.val = 0,
                                       feature = "ncRNA",
                                       frame = ".",
                                       attribute = paste("ID=rna_fwd_", row_number(), sep = ""))%>%
        select(seqname, source, feature, start, stop, median.val, strand, frame, attribute)
      
      
      
      
      fileConn<-file(paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/gff_files/", sra_id, "_snra_calls.gff", sep = ""))
      writeLines(c("##gff-version 3",
                   "#!gff-spec-version 1.21",
                   "#!processor R script (local) with manual add of top section",
                   genomeBuild,
                   paste("#!genome-build-accession NCBI_Assembly:", "GCA_000017745.1", sep = ""),
                   paste("#!annotation-date ", Sys.Date(), sep = ""),
                   "#!annotation-source snraCalls (local version)",
                   genomeInfo,
                   genomeSpecies), fileConn)
      close(fileConn)
      
      print(paste("Writing to ~/phd/RNASeq/genera/",  genera, "/", accession ,".data/gff_files/", sra_id, "_snra_calls.gff", sep = ""))
      write.table(x = gffFwd, file = paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/gff_files/", sra_id, "_snra_calls.gff", sep = ""), row.names = F, col.names = F, quote = F, sep = "\t", append = T)
      
      
      # plotDat <- plotDat %>% mutate(value = ifelse(is.na(type), value, 0))
      # 
      # 
      # outDat <- plotDat %>% select(value)
      # 
      # 
      # write.table(outDat, paste("~/phd/RNASeq/genera/",  genera, "/", accession ,".data/plot_files/", file_name, "_ncRNA_no_buffer.plot", sep = ""), quote = F, row.names = F, col.names = F)
    }
    
    
  }
}
```



##get_sRNA_sequences.py


```{python get_sRNA_sequences.py, eval=F, include=T}
#!/usr/bin/python
import sys
from Bio import SeqIO
from Bio.Alphabet import generic_dna
import getopt
import os



help = '''
    get_sRNA_sequences.py v 0.1 (August 2020) is a script for taking predicted sRNA regions and extracting the DNA sequence from 
    fasta files.
    Usage:
     get_sRNA_sequences.py <accession>
    
    Options:
        -h	Display this help
        -q  Supress messages
    Input
        -a	<accession> the genome accession to use for the input and output files

    
'''

def usage():
    print help

def rungetopts():
    try:
        opts, args = getopt.getopt(sys.argv[1:], "a:qh", ["accession", "quiet", "help"])
    except getopt.GetoptError as err:
        print(err)
        usage()
        sys.exit(2)
    accession = ""
    for o, a in opts:
            if o in ("-h", "--help"):
                usage()
                sys.exit()
            elif o in ("-a", "--accession"):
                accession = a
            else:
                assert False, "unhandled option"
    if accession == "":
        print "-a <accession> missing. For more help use -h"
        sys.exit(2)
    return(accession)

def main():

    accession = rungetopts()

    try:
        inFile = open("/Users/thomasnicholson/phd/RNASeq/new_calls/%s_new_calls.txt" % accession, 'r')
    except IOError:
        print "/Users/thomasnicholson/phd/RNASeq/new_calls/%s_new_calls.txt not found" % accession
        sys.exit(2)
    try:
        fastaFile = list(SeqIO.parse("/Users/thomasnicholson/phd/RNASeq/sequences/%s.fna" % accession, "fasta"))
    except IOError:
        print "/Users/thomasnicholson/phd/RNASeq/sequences/%s.fna not found" % accession
        sys.exit(2)


    write_path = "/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1"

    print "Combining contigs"
    my_seq = srna.concatenateSequence(fastaFile)

    print "Writing sequences"
    srna.writeSequences(inFile,my_seq,accession,write_path)


if __name__ == "__main__":
    main()






```

##get_random_srna_sequence.py

```{python get_random_srna_sequences.py, eval = F, python.reticulate = FALSE, echo=T}
#!/usr/bin/python

'''
file paths are hard coded
'''


import sys
from Bio import SeqIO
import getopt
import os
from BCBio import GFF
from Bio.Seq import Seq
from Bio.Alphabet import generic_dna
import random
import comparativeSRNA as srna


help = '''

'''

def usage():
    print help

def rungetopts():
    try:
        opts, args = getopt.getopt(sys.argv[1:], "a:sqh", ["accession", "shuffle", "quiet", "help"])
    except getopt.GetoptError as err:
        # print help information and exit:
        print(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    accession = ""
    shuffled = False
    for o, a in opts:
            if o in ("-h", "--help"):
                usage()
                sys.exit()
            elif o in ("-a", "--accession"):
                accession = a
            elif o in ("-s", "--shuffle"):
                shuffled = True
            else:
                assert False, "unhandled option"
    if accession == "":
        print "-a <accession> missing. For more help use -h"
        sys.exit(2)
    return(accession, shuffled)


def main():

    accession, shuffled = rungetopts()
    print "Reading files"
    try:
        inFile = open("/Users/thomasnicholson/phd/RNASeq/new_calls/%s_new_calls.txt" % accession, 'r')

        fileLength = file_len("/Users/thomasnicholson/phd/RNASeq/new_calls/%s_new_calls.txt" % accession)
    except IOError:
        print "/Users/thomasnicholson/phd/RNASeq/new_calls/%s_new_calls.txt not found" % accession
        sys.exit(2)
    try:
        fastaFile = list(SeqIO.parse("/Users/thomasnicholson/phd/RNASeq/sequences/%s.fna" % accession, "fasta"))
    except IOError:
        print "/Users/thomasnicholson/phd/RNASeq/sequences/%s.fna not found" % accession
        sys.exit(2)

    print "Combining contigs"
    my_seq = srna.concatenateSequence(fastaFile)



    print "Getting intergenic sequence"
    random_seq = srna.intergenicSequence(accession, my_seq, shuffled)


    print "Getting intergenic positions"
    positions = srna.intergenicPositions(accession)

    print "Selecting random sRNAs"
    srna.selectRandomLocation(inFile, positions,fileLength, random_seq, accession)





if __name__ == "__main__":
    main()






```



##single_fasta_files.py

```{python single_fasta_files.py, eval = F}
#!/usr/bin/python
import sys
from Bio import SeqIO
import getopt
import os
from BCBio import GFF
from Bio.Seq import Seq
from Bio.Alphabet import generic_dna
import random
import pandas as pd
import comparativesrna as srna

help = '''
    {script_name} -c com_port [-o output_file] [--loglevel level]

    Reads the temperature data from a radio.  The temperature data is output in csv form.

    examples:
        Read table from radio attached to com4 and write the table to the file
        output.csv.

            {script_name} -c com4 -o output.csv

        Read table from radio attached to com3 and write the table to stdout. 
        You can use IO redirection to send the contents where every you want.

            # just print to the terminal 
            {script_name} -c com3

            # redirect to another file
            {script_name} -c com3 > somefile.csv

            # filter out temperatures that are -100
            {script_name} -c com3 | grep -v '^-100' 


    -c com_port
    --com_port comport
        Name of the COM port attached to the radio

    -o output_file
    --output output_file
        If specified write the table data to the given file.  If not specified
        the data will be written to stdout.

    --loglevel critical | error | warning | info | debug | notset
        Control the verbosity of the script by setting the log level.  Critical
        is the least verbose and notset is the most verbose.

        The default loglevel is {default_loglevel}.

        These values correspond directly to the python logging module levels. 
        (i.e. https://docs.python.org/3/howto/logging.html#logging-levels)


    -h 
    --help 
        print this message

'''

def usage():
    print help

def rungetopts():
    try:
        opts, args = getopt.getopt(sys.argv[1:], "i:f:qh", ["infile", "folder", "quiet", "help"])
    except getopt.GetoptError as err:
        # print help information and exit:
        print(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    file = ""
    for o, a in opts:
            if o in ("-h", "--help"):
                usage()
                sys.exit()
            elif o in ("-i", "--infile"):
                file = a
            elif o in ("-f", "--folder"):
                folder = a
            else:
                assert False, "unhandled option"
    if file == "":
        print "-f <file> missing. For more help use -h"
        sys.exit(2)
    return(file, folder)

# def single_fasta(fastaFile, folder):
#     for seq in fastaFile:
#         id = seq.id
#         outname = id.split("[")
#         outname = outname[0]
#         my_seq = seq.seq
#         outFile = open("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/%s/%s.fna" % (folder, outname), "w")
#         outFile.write(">%s\n%s\n" % (id, my_seq))



def main():

    filename, folder = rungetopts()
    print filename, folder
    print "Reading files"
    try:
        fastaFile = list(SeqIO.parse("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/%s" % filename, "fasta"))
    except IOError:
        print "/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/%s not found" % filename
        sys.exit(2)

    srna.single_fasta(fastaFile, folder)


if __name__ == "__main__":
    main()


```

##run_srna_nhmmer.sh

```{bash run_srna_nhmmer.sh, eval=F}
#!/bin/bash

# Setup Variables #

usage(){
    echo "run_sRNA_nhmmer.sh is a script for running nhmmer and sorting the results.  
Usage:
 run_sRNA_nhmmer.sh [opts] [input]

Required:	       
	-d	<database> The nucleotide database to be searched against as the nhmmer target
	-f	<folder> The folder containing the query file for nhmmer
	-e	<extension> The file extension of the query file in <folder>

Options:
	-h	Display this help
	-c	Check if the sequences are >50 nt (only works on fasta files)
"
}

check_seq_lengths=""
database=""
folder=""
extension=""
outfolder="."
missing=""
exitTrue="F"
evalue="1e-5"

# User Input Options #

while getopts "d:o:f:E:e:ch" arg; do
case $arg in
	d) 
	database=${OPTARG};;
	f)
	folder=${OPTARG};;
	o)
	outfolder=${OPTARG};;
	E)
	evalue=${OPTARG};;
	e)
	extension=${OPTARG};;	
	c)
	check_seq_lengths="T";;
    h)
		usage
		exit
      ;;    
	\?) 
	echo "Unknown option: -${OPTARG}" >&2; exit 1;;
    esac
done

# Tests for inputs #

if [[ $database == "" ]]; then
	missing="$missing -d <database> "
	exitTrue="T"
fi

if [[ $folder == "" ]]; then
	missing="$missing -f <folder> "
	exitTrue="T"	
fi

if [[ $extension == "" ]]; then
	missing="$missing -e <extension> "
	exitTrue="T"
fi

if [[ $exitTrue == "T" ]];then
	echo "$missing not found. Use -h for more help."
	exit
fi

if [[ $extension == "stk" ]]; then
	check_seq_lengths=""
fi

echo "extension value: $extension"

if [[ $check_seq_lengths == "T" ]]; then

	echo "checking for short seqs"
	mkdir -p $folder/short_seqs
	
	let "fileNum = 0"
	for file in $folder/*.$extension
	do
	
	seqlength=`grep -v ^">" $file | wc -c`
	if (( $seqlength < 50 )); then
	mv $file  single_seqs/short_seqs/
	fi
	
	done

fi

# Set up folders/files #

echo "making directories in `pwd`"
mkdir -p $outfolder/alignments
mkdir -p $outfolder/hmm
mkdir -p $outfolder/output

# Run nhmmer #

echo "running nhmmer"
let "fileNum = 0"
for file in $folder/*.$extension

do

echo $file
tmpname=`basename $file`
outname=`basename $tmpname .${extension}`


if [ -f "$outfolder/output/$outname.res" ]; then
	echo "Already exists: $file"
	continue
fi


nseqs=`esl-alistat $file | grep "Number of sequences" | cut -d ":" -f2`
length=`esl-alistat $file | grep "Alignment length:" | cut -d ":" -f2`
echo "Running nhmmer on $file (length: $length, nseqs: $nseqs)"


nhmmer -E $evalue --tblout $outfolder/output/$outname.tbl -A $outfolder/alignments/tmp.stk --tformat FASTA  $file $database > $outfolder/output/$outname.res

lines=`wc -l < $outfolder/alignments/tmp.stk`


if (( $lines > 0 )); then


##esl-weight!!!
esl-alimanip   --lnfract 0.8 --lxfract 1.2 --lmin 50 --lmax 500 --detrunc 30  $outfolder/alignments/tmp.stk | esl-alimask -g --gapthresh 0.8 -p --pfract 0.5 --pthresh 0.5 --keepins - > $outfolder/alignments/$outname.stk


grep ^"#=GS" alignments/${outname}.stk  | cut -d '[' -f1 | rev | cut -d ' ' -f1 | rev > single_seqs/move_files.txt


while read line; 
do

mv single_seqs/$line.fna single_seqs/done

done < single_seqs/move_files.txt



#hmmbuild $outfolder/hmm/$outname.hmm $outfolder/alignments/$outname

else

echo "No hits found for $outname"

fi

done




```


##run_RNAcode.sh

```{bash run_RNAcode.sh, eval=F, include=F}
#!/bin/bash

##makes alignments and running alifoldz and r-scape
##GCA accession number.

usage(){
    echo "sraAlignAndFold.sh is a script for making a multiple sequence alignment and
    getting secondary structure information.  
Usage:
 fetchGenomeGCA.sh [opts] [input]

Options:
	-h	Display this help

Input	       
	-r	Folder location

"
}

while getopts "i:o:h" arg; do
case $arg in
	i) 
	FOLDER=${OPTARG};;
	o) 
	OUTPUT=${OPTARG};;
    h)
		usage
		exit
      ;;    
	\?) 
	echo "Unknown option: -${OPTARG}" >&2; exit 1;;
    esac
done

if [ -z ${FOLDER} ]; then
	FOLDER="./"
fi




mkdir -p "$FOLDER/rnacode_out"



let "fileNum = 0"
for file in alignments/*.stk; #change to _R for positive control
do

checkname=`basename $file .stk`
if [ -f "./rnacode_out/${checkname}.rnacode" ]; then
echo "Already exists: $file"
continue
else

	
nseqs=`esl-alistat $file | grep "Number of sequences" | cut -d ":" -f2`

length=`esl-alistat $file | grep "Alignment length:" | cut -d ":" -f2`
largest_length=`esl-alistat $file | grep "Largest" | cut -d ":" -f2`


if (( $length < 500 )); then

diffLength=`expr $largest_length - $length`

if (( $diffLength > $length ));then
echo "Alignment is poor: $file"
continue
fi

if (( $nseqs > 5000 )); then
echo "Skipping $file (length: $length, nseqs: $nseqs)"
echo "$file (length: $length, nseqs: $nseqs)" >> skipped_alignments.txt
continue
fi

if (( $nseqs < 3 )); then
echo "Skipping $file (length: $length, nseqs: $nseqs)"
#echo "$file (length: $length, nseqs: $nseqs)" >> skipped_alignments.txt
continue
fi

echo "Running RNAcode on $file (length: $length, nseqs: $nseqs)"
	
esl-reformat clustal $file | RNAcode --outfile ./rnacode_out/$checkname.rnacode

fi
fi

done


```
##run_RNAAlifold.sh

```{bash run_RNAAlifold.sh, eval=F, include=T}
#!/bin/bash

##makes alignments and running alifoldz and r-scape
##GCA accession number.

usage(){
    echo "sraAlignAndFold.sh is a script for making a multiple sequence alignment and
    getting secondary structure information.  
Usage:
 fetchGenomeGCA.sh [opts] [input]

Options:
	-h	Display this help

Input	       
	-r	Folder location

"
}

while getopts "i:o:h" arg; do
case $arg in
	i) 
	FOLDER=${OPTARG};;
	o) 
	OUTPUT=${OPTARG};;
    h)
		usage
		exit
      ;;    
	\?) 
	echo "Unknown option: -${OPTARG}" >&2; exit 1;;
    esac
done

if [ -z ${FOLDER} ]; then
	FOLDER="./"
fi




mkdir -p "$FOLDER/alifold/post_script"
mkdir -p "$FOLDER/RNAAlifold"
mkdir -p alignments_rnaalifold


let "fileNum = 0"
for file in alignments/*.stk

do
lines=`wc -l < $file`
if (( $lines < 1));then
continue
fi

outname=`basename $file`


if [ -f "$FOLDER/RNAAlifold/$outname.rnaalifold" ]; then
	echo "Already exists: $file"
	continue
fi



nseqs=`esl-alistat $file | grep "Number of sequences" | cut -d ":" -f2`



length=`esl-alistat $file | grep "Alignment length:" | cut -d ":" -f2`
largest_length=`esl-alistat $file | grep "Largest" | cut -d ":" -f2`


if (( $length < 500 )); then

diffLength=`expr $largest_length - $length`

if (( $diffLength > $length ));then
echo "Alignment is poor: $file"
continue
fi

if (( $nseqs > 5000 )); then
echo "Skipping $file (length: $length, nseqs: $nseqs)"
echo "$file (length: $length, nseqs: $nseqs)" >> skipped_alignments.txt
continue
fi


echo "Running RNAAlifold on $file (length: $length, nseqs: $nseqs)"


esl-reformat  clustal $file  | RNAalifold --aln-stk=${file} >> ./RNAAlifold/$outname.rnaalifold
cat alirna.ps > ./alifold/post_script/$outname.ps      
else
	echo "Skipping: $file. Length: $length"
fi

done


for file in alignments_G*; #change to _R for positive control
do
outname=`basename $file .stk.stk`

mv $file ./alignments_rnaalifold/$outname.stk

done
```

##run_R-scape.sh

```{bash run_R-scape.sh, eval=F, include=T}
#!/bin/bash

##makes alignments and running alifoldz and r-scape
##GCA accession number.

usage(){
    echo "sraAlignAndFold.sh is a script for making a multiple sequence alignment and
    getting secondary structure information.  
Usage:
 fetchGenomeGCA.sh [opts] [input]

Options:
	-h	Display this help

Input	       
	-r	Folder location

"
}

while getopts "i:o:h" arg; do
case $arg in
	i) 
	FOLDER=${OPTARG};;
	o) 
	OUTPUT=${OPTARG};;
    h)
		usage
		exit
      ;;    
	\?) 
	echo "Unknown option: -${OPTARG}" >&2; exit 1;;
    esac
done

if [ -z ${FOLDER} ]; then
	FOLDER="./"
fi




mkdir -p "$FOLDER/rscape_out"



let "fileNum = 0"
for file in alignments_G*;
do

checkname=`basename $file .stk`
if [ -f "../rscape_out/${checkname}_1.R2R.sto" ]; then
echo "Already exists: $file"
continue
else

echo "Running R-scape on: $file"
	
fi

time R-scape --r2rall --outdir ../rscape_out/ $file > rsacpe.out

done
```

##run_alifold.sh

```{bash run_Alifold.sh, eval=F, include=T}
#!/bin/bash

##makes alignments and running alifoldz and r-scape
##GCA accession number.

usage(){
    echo "sraAlignAndFold.sh is a script for making a multiple sequence alignment and
    getting secondary structure information.  
Usage:
 fetchGenomeGCA.sh [opts] [input]

Options:
	-h	Display this help

Input	       
	-r	Folder location

"
}

while getopts "i:o:h" arg; do
case $arg in
	i) 
	FOLDER=${OPTARG};;
	o) 
	OUTPUT=${OPTARG};;
    h)
		usage
		exit
      ;;    
	\?) 
	echo "Unknown option: -${OPTARG}" >&2; exit 1;;
    esac
done

if [ -z ${FOLDER} ]; then
	FOLDER="./"
fi




mkdir -p "$FOLDER/alifold/post_script"



let "fileNum = 0"
for file in alignments_rnaalifold/*.stk


do

outname=`basename $file`
if [ -f "$FOLDER/alifold/$outname.alifold" ]; then
	#echo "$FOLDER/alifold/$file.alifold"
	echo "Already exists: $file"
	continue
else
	echo "Checking size: $file"
fi


lines=`wc -l < $file`
if (( $lines < 1));then
continue
fi


nseqs=`grep "#=" $file | cut -d ' ' -f2 | sort | uniq | wc -l`


start=`grep "GCA" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f1`
end=`grep "GCA" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f2`

if [[ $start == "" ]]; then
	start=`grep "NC_" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f1`
	end=`grep "NC_" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f2`

fi

if [[ $start == "" ]]; then
	start=`grep "NZ_" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f1`
	end=`grep "NZ_" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f2`

fi

if [[ $start == "" ]]; then
	head $file
fi




length=`expr $end - $start`

if (( $length < 0 )); then
	length=$(( -1 * $length ))
fi

if (( $length < 500 )); then

ID=`grep "NC_" $file | head -n 1 | cut -d " " -f2`

if [[ $ID == "" ]]; then
	ID=`grep "NZ_" $file | head -n 1 | cut -d " " -f2`
fi

if [[ $ID == "" ]]; then
	ID=`grep GCA_" $file | head -n 1 | cut -d " " -f2`
fi

if [[ $ID == "" ]]; then
	head $file
else
alignmentLength=`grep $ID $file | grep -v "#" | tr -s ' ' | cut -d ' ' -f2 | wc -c`

diffLength=`expr $alignmentLength - $length`

if (( $diffLength > $length ));then
echo "Alignment is poor: $file"
continue
fi
fi




echo "Running alifoldz.pl on $file (length: $length, nseqs: $nseqs)"

time  esl-alimanip   --lnfract 0.8 --lxfract 1.2 --lmin 50 --lmax 500 --detrunc 30 $file | esl-alimask --rf-is-mask - | esl-reformat clustal - | alifoldz.pl -t 0 > ./alifold/$outname.alifold         
 

else

	echo "Skipping: $file"


fi

done
```


## run_rmfamscan.sh


```{bash run_rmfamscan.sh, eval=F, include=T}
#!/bin/bash

##Run rmfam over all fasta files

usage(){
    echo "run_rmfam_scan.sh is a script for running rmfam_scan over a set of fasta
    files.  
Usage:
 run_rmfam_scan.sh [opts] [extension]

Options:
	-h	Display this help

Input
	-e extension	       
	-a	align
	-o output
	-k keep tmp files

"
}

align="F"
keep="F"
while getopts "e:ao:hk" arg; do
case $arg in
	e)
		extension=${OPTARG}
		;;
	a) 
		align="T"
		;;
    h)
		usage
		exit
      ;;    
    k)
		keep="T"
      	;;   
	\?) 
	echo "Unknown option: -${OPTARG}" >&2; exit 1;;
    esac
done

COUNTER=0
mkdir -p "rmfam_cmscan"
mkdir -p "rmfam_gff_files"
mkdir -p "rmfam_tblout"


let "fileNum = 0"
if [[ $extension == "fna" ]]; then

	for file in *.$extension
	do
		if [ -f "rmfam_tblout/$file.out.tblout" ]; then
			echo "Already exists: $file"
 			continue
		fi
		length=`grep -v ">" $file | wc -c`
		if (( $length < 500 )); then
			echo "Running rmfam_scan on $file (length: $length)"
			time rmfam_scan.pl -g -f ~/phd/RNASeq/RMfam/scripts/RMfam.cm $file -o $file.out 
			mv *.tblout rmfam_tblout
			mv *.cmscan rmfam_cmscan
			mv *.gff rmfam_gff_files
		else
			echo "Skipping: $file"
		fi
	done
else


for file in *.$extension

do


if [ -f "rmfam_tblout/$file.out.tblout" ]; then
	echo "Already exists: $file"
 	continue
else
echo "Checking size: $file"
fi


lines=`wc -l < $file`
if (( $lines < 1));then
continue
fi

# COUNTER=$((COUNTER+1))
# 
# if (( $COUNTER > 100 )); then
# echo "waiting"
# COUNTER=1
# time wait
# 
# 
# 
# fi


# if [[ $align == "T" ]]; then

# echo "Aligning $file"
# esl-reformat  clustal $file > $file.clustal

nseqs=`grep "#=" $file | cut -d ' ' -f2 | sort | uniq | wc -l`


start=`grep "GCA" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f1`
end=`grep "GCA" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f2`

if [[ $start == "" ]]; then
	start=`grep "NC_" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f1`
	end=`grep "NC_" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f2`

fi

if [[ $start == "" ]]; then
	start=`grep "NZ_" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f1`
	end=`grep "NZ_" $file | head -n 1 | cut -d " " -f2 | cut -d "/" -f2 | cut -d "-" -f2`

fi

if [[ $start == "" ]]; then
	head $file
fi




length=`expr $end - $start`

if (( $length < 0 )); then
	length=$(( -1 * $length ))
fi

if (( $length < 500 )); then

ID=`grep "NC_" $file | head -n 1 | cut -d " " -f2`

if [[ $ID == "" ]]; then
	ID=`grep "NZ_" $file | head -n 1 | cut -d " " -f2`
fi

if [[ $ID == "" ]]; then
	ID=`grep GCA_" $file | head -n 1 | cut -d " " -f2`
fi

if [[ $ID == "" ]]; then
	head $file
else
alignmentLength=`grep $ID $file | grep -v "#" | tr -s ' ' | cut -d ' ' -f2 | wc -c`

diffLength=`expr $alignmentLength - $length`

if (( $diffLength > $length ));then
echo "Alignment is poor: $file"
continue
fi
fi




echo "Running rmfam_scan on $file (length: $length, nseqs: $nseqs)"

 time rmfam_scan.pl -g -f ~/phd/RNASeq/RMfam/scripts/RMfam.cm $file -o $file.out 
 
 
 mv *.tblout rmfam_tblout
mv *.cmscan rmfam_cmscan
mv *.gff rmfam_gff_files
 
else

	echo "Skipping: $file"


fi

done

fi

cd rmfam_tblout

let "fileNum = 0"

for file in *.tblout

do

sed 's/  /__/g' $file | sed 's/ /--/g' | sed 's/__/ /g' | tr -s ' ' | sed 's/ --/ /g' | sed 's/-- / /g' | sed 's/--!/ !/g' | tr ' ' '\t' | sed 's/--/_/g' > $file.formatted.tblout

done

```